{"version":3,"sources":["webpack://typedjson/webpack/universalModuleDefinition","webpack://typedjson/webpack/bootstrap","webpack://typedjson/./src/typedjson/helpers.ts","webpack://typedjson/./src/typedjson/metadata.ts","webpack://typedjson/./src/typedjson/options-base.ts","webpack://typedjson/./src/typedjson/type-descriptor.ts","webpack://typedjson/./src/typedjson/deserializer.ts","webpack://typedjson/./src/typedjson/json-array-member.ts","webpack://typedjson/./src/typedjson/serializer.ts","webpack://typedjson/./src/parser.ts","webpack://typedjson/./src/typedjson/json-object.ts","webpack://typedjson/./src/typedjson/json-member.ts","webpack://typedjson/./src/typedjson/json-set-member.ts","webpack://typedjson/./src/typedjson/json-map-member.ts","webpack://typedjson/./src/typedjson/to-json.ts","webpack://typedjson/./src/typedjson.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","m","MISSING_REFLECT_CONF_MSG","parseToJSObject","json","expectedType","jsonStr","expectsTypesSerializedAsStrings","String","ArrayBuffer","DataView","hasQuotes","length","isInteger","test","trim","Date","JSON","parse","isSubtypeOf","A","B","prototype","logError","message","console","error","optionalParams","log","logWarning","warn","isValueDefined","value","isInstanceOf","constructor","Number","Boolean","isReflectMetadataSupported","Reflect","getMetadata","nameof","fn","name","identity","arg","METADATA_FIELD_KEY","getJsonObjectName","ctor","metadata","JsonObjectMetadata","getFromConstructor","classType","hasOwnProperty","isExplicitlyMarked","doesHandleWithoutAnnotation","primitiveMeta","ensurePresentInPrototype","objectMetadata","parentMetadata","dataMembers","forEach","memberMetadata","propKey","set","knownTypes","knownType","add","typeResolver","typeHintEmitter","Object","defineProperty","enumerable","configurable","writable","getKnownTypeNameFromType","indexOf","Float32Array","Float64Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Map","Set","isHandledWithoutAnnotation","injectMetadataInformation","decoratorName","type","deserializer","getTypes","keys","key","undefined","kAllOptions","extractOptionBase","from","options","filter","reduce","obj","getOptionValue","getDefaultOptionOf","mergeOptions","existing","moreSpecific","TypeDescriptor","GenericTypeDescriptor","concat","elementType","Array","ArrayT","ArrayTypeDescriptor","ensureTypeDescriptor","SetT","SetTypeDescriptor","keyType","valueType","getCompleteOptions","shape","MapT","MapTypeDescriptor","isTypelike","ConcreteTypeDescriptor","defaultTypeResolver","sourceObject","__type","get","setNameResolver","nameResolverCallback","nameResolver","setTypeResolver","typeResolverCallback","TypeError","getTypeResolver","setErrorHandler","errorHandlerCallback","errorHandler","getErrorHandler","convertSingleValue","typeDescriptor","memberName","memberOptions","retrievePreserveNull","deserializationStrategy","expectedSelfType","sourceObjectMetadata","knownTypeConstructors","mergeKnownTypes","createKnownTypesMap","typeFromTypeHint","objMemberMetadata","revivedValue","objMemberValue","objMemberDebugName","objMemberOptions","isRequired","targetObject","initializerCallback","e","instantiateType","assign","onDeserializedMethodName","sourceKey","convertAsObject","result","knownTypeMaps","knowTypes","map","knownTypeMeta","isExpectedMapShape","source","expectedShape","isArray","deserializeDirectly","deserializeDate","stringToArrayBuffer","stringToDataView","convertAsArray","convertAsSet","convertAsMap","convertAsFloatArray","convertAsUintArray","throwTypeMismatchError","targetType","expectedSourceType","actualSourceType","makeTypeErrorMessage","actualType","srcTypeNameForDebug","objectName","element","resultSet","i","resultMap","resultKey","createArrayBufferFromString","input","buf","bufView","strLen","charCodeAt","every","elem","isNaN","jsonArrayMember","elementConstructor","target","dimensions","createArrayType","emitDefaultValue","toString","serializer","defaultTypeEmitter","sourceTypeMetadata","setTypeHintEmitter","typeEmitterCallback","getTypeHintEmitter","serializationStrategy","beforeSerializationMethodName","serialized","expectedName","actualName","convertAsArrayBuffer","convertAsDataView","convertAsTypedArray","expectedTypeName","actualTypeName","resultArray","resultElement","push","resultShape","preserveNull","resultKeyValuePairObj","keyDefined","valueDefined","buffer","charCode","fromCharCode","join","dataView","object","rootType","settings","TypedJSON","parseAsArray","parseAsSet","parseAsMap","toPlainJson","toPlainArray","toPlainSet","toPlainMap","keyCtor","valueCtor","stringify","stringifyAsArray","stringifyAsSet","stringifyAsMap","setGlobalConfig","config","_globalConfig","replacer","indent","globalKnownTypes","rootConstructor","rootMetadata","ktc","knownTypeCtor","_mapKnownTypes","keyConstructor","constructors","jsonObject","optionsOrTarget","decorator","onDeserialized","beforeSerialization","initializer","optionsBase","jsonMember","optionsOrPrototype","_propKey","reflectCtor","isSpecialPropertyType","reflectPropCtor","jsonSetMember","jsonMapMember","valueConstructor","toJson","toJsonDecorator","overwrite","toJSON","Error","getPrototypeOf","c","d","getter","o","r","Symbol","toStringTag","t","mode","__esModule","ns","create","bind","n","property","call","p","s","moduleId","l","modules"],"mappings":"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","file":"typedjson.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"typedjson\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"typedjson\"] = factory();\n\telse\n\t\troot[\"typedjson\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import {Serializable} from './types';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport const MISSING_REFLECT_CONF_MSG = 'Are you sure, that you have both \"experimentalDecorators\"'\n    + ' and \"emitDecoratorMetadata\" in your tsconfig.json?';\n\n/**\n * Determines whether the specified type is a type that can be passed on \"as-is\" into `JSON.stringify`.\n * Values of these types don't need special conversion.\n * @param type The constructor of the type (wrapper constructor for primitive types, e.g. `Number` for `number`).\n */\nexport function isDirectlySerializableNativeType(type: Function): boolean {\n    return Boolean(~[Date, Number, String, Boolean].indexOf(type as any));\n}\n\nexport function isDirectlyDeserializableNativeType(type: Function): boolean {\n    return Boolean(~[Number, String, Boolean].indexOf(type as any));\n}\n\nexport function isTypeTypedArray(type: Function): boolean {\n    return Boolean(~[Float32Array, Float64Array, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array]\n        .indexOf(type as any));\n}\n\nexport function isObject(value: any): value is Object {\n    return typeof value === 'object';\n}\n\nfunction shouldOmitParseString(jsonStr: string, expectedType: Function): boolean {\n    const expectsTypesSerializedAsStrings = expectedType === String\n        || expectedType === ArrayBuffer\n        || expectedType === DataView;\n\n    const hasQuotes = jsonStr.length >= 2 && jsonStr[0] === '\"' && jsonStr[jsonStr.length - 1] === '\"';\n    const isInteger = /^\\d+$/.test(jsonStr.trim());\n\n    return (expectsTypesSerializedAsStrings && !hasQuotes) || ((!hasQuotes && !isInteger) && expectedType === Date);\n}\n\nexport function parseToJSObject<T>(json: any, expectedType: Serializable<T>): Object {\n    if (typeof json !== 'string' ||Â shouldOmitParseString(json, expectedType)) {\n      return json;\n    }\n    return JSON.parse(json);\n}\n\n/**\n * Determines if 'A' is a sub-type of 'B' (or if 'A' equals 'B').\n * @param A The supposed derived type.\n * @param B The supposed base type.\n */\nexport function isSubtypeOf(A: Function, B: Function) {\n    return A === B || A.prototype instanceof B;\n}\n\nexport function logError(message?: any, ...optionalParams: Array<any>) {\n    if (typeof console === 'object' && typeof console.error === 'function') {\n        console.error(message, ...optionalParams);\n    } else if (typeof console === 'object' && typeof console.log === 'function') {\n        console.log(`ERROR: ${message}`, ...optionalParams);\n    }\n}\n\nexport function logMessage(message?: any, ...optionalParams: Array<any>) {\n    if (typeof console === 'object' && typeof console.log === 'function') {\n        console.log(message, ...optionalParams);\n    }\n}\n\nexport function logWarning(message?: any, ...optionalParams: Array<any>) {\n    if (typeof console === 'object' && typeof console.warn === 'function') {\n        console.warn(message, ...optionalParams);\n    } else if (typeof console === 'object' && typeof console.log === 'function') {\n        console.log(`WARNING: ${message}`, ...optionalParams);\n    }\n}\n\n/**\n * Checks if the value is considered defined (not undefined and not null).\n * @param value\n */\nexport function isValueDefined<T>(value: T): value is Exclude<T, undefined | null> {\n    return !(typeof value === 'undefined' || value === null);\n}\n\nexport function isInstanceOf<T>(value: any, constructor: Function): boolean {\n    if (typeof value === 'number') {\n        return constructor === Number;\n    } else if (typeof value === 'string') {\n        return constructor === String;\n    } else if (typeof value === 'boolean') {\n        return constructor === Boolean;\n    } else if (isObject(value)) {\n        return value instanceof constructor;\n    }\n\n    return false;\n}\n\nexport const isReflectMetadataSupported =\n    typeof Reflect === 'object' && typeof Reflect.getMetadata === 'function';\n\n/**\n * Gets the name of a function.\n * @param fn The function whose name to get.\n */\nexport function nameof(fn: Function & { name?: string }) {\n    if (typeof fn.name === 'string') {\n        return fn.name;\n    }\n    return 'undefined';\n}\n\nexport function identity<T>(arg: T): T {\n    return arg;\n}\n","import {isDirectlySerializableNativeType, isTypeTypedArray, logError, nameof} from './helpers';\nimport {OptionsBase} from './options-base';\nimport {TypeDescriptor} from './type-descriptor';\nimport {IndexedObject, Serializable} from './types';\n\nexport const METADATA_FIELD_KEY = '__typedJsonJsonObjectMetadataInformation__';\n\nexport type TypeResolver = (sourceObject: IndexedObject, knownTypes: Map<string, Function>) => Function | undefined | null;\nexport type TypeHintEmitter\n    = (\n        targetObject: IndexedObject,\n        sourceObject: IndexedObject,\n        expectedSourceType: Function,\n        sourceTypeMetadata?: JsonObjectMetadata,\n    ) => void;\n\nexport interface JsonMemberMetadata {\n    /** If set, a default value will be emitted for uninitialized members. */\n    emitDefaultValue?: boolean;\n\n    /** Member name as it appears in the serialized JSON. */\n    name: string;\n\n    /** Property or field key of the json member. */\n    key: string;\n\n    /** Type descriptor of the member. */\n    type?: TypeDescriptor;\n\n    /** If set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    options?: OptionsBase;\n\n    /** Custom deserializer to use. */\n    deserializer?: (json: any) => any;\n\n    /** Custom serializer to use. */\n    serializer?: (value: any) => any;\n}\n\nexport class JsonObjectMetadata {\n    // #region Static\n    /**\n     * Gets the name of a class as it appears in a serialized JSON string.\n     * @param ctor The constructor of a class (with or without jsonObject).\n     */\n    static getJsonObjectName(ctor: Function): string {\n        const metadata = JsonObjectMetadata.getFromConstructor(ctor);\n        return metadata ? nameof(metadata.classType) : nameof(ctor);\n    }\n\n    /**\n     * Gets jsonObject metadata information from a class.\n     * @param ctor The constructor class.\n     */\n    static getFromConstructor<T>(ctor: Serializable<T>): JsonObjectMetadata | undefined {\n        const prototype = ctor.prototype;\n        if (!prototype) {\n            return;\n        }\n\n        let metadata: JsonObjectMetadata | undefined;\n        if (prototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n            // The class prototype contains own jsonObject metadata\n            metadata = prototype[METADATA_FIELD_KEY];\n        }\n\n        // Ignore implicitly added jsonObject (through jsonMember)\n        if (metadata && metadata.isExplicitlyMarked) {\n            return metadata;\n        }\n\n        // In the end maybe it is something which we can handle directly\n        if (JsonObjectMetadata.doesHandleWithoutAnnotation(ctor)) {\n            const primitiveMeta = new JsonObjectMetadata(ctor);\n            primitiveMeta.isExplicitlyMarked = true;\n            // we do not store the metadata here to not modify builtin prototype\n            return primitiveMeta;\n        }\n    }\n\n    static ensurePresentInPrototype(prototype: IndexedObject): JsonObjectMetadata {\n        if (prototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n            return prototype[METADATA_FIELD_KEY];\n        }\n            // Target has no JsonObjectMetadata associated with it yet, create it now.\n        const objectMetadata = new JsonObjectMetadata(prototype.constructor);\n\n        // Inherit json members and known types from parent @jsonObject (if any).\n        const parentMetadata: JsonObjectMetadata = prototype[METADATA_FIELD_KEY];\n        if (parentMetadata) {\n            parentMetadata.dataMembers\n                .forEach((memberMetadata, propKey) => objectMetadata.dataMembers.set(propKey, memberMetadata));\n            parentMetadata.knownTypes\n                .forEach((knownType) => objectMetadata.knownTypes.add(knownType));\n            objectMetadata.typeResolver = parentMetadata.typeResolver;\n            objectMetadata.typeHintEmitter = parentMetadata.typeHintEmitter;\n        }\n\n        Object.defineProperty(prototype, METADATA_FIELD_KEY, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: objectMetadata,\n        });\n        return objectMetadata;\n    }\n\n    /**\n     * Gets the known type name of a jsonObject class for type hint.\n     * @param constructor The constructor class.\n     */\n    static getKnownTypeNameFromType(constructor: Function): string {\n        const metadata = JsonObjectMetadata.getFromConstructor(constructor);\n        return metadata ? nameof(metadata.classType) : nameof(constructor);\n    }\n\n    private static doesHandleWithoutAnnotation(ctor: Function): boolean {\n        return isDirectlySerializableNativeType(ctor) || isTypeTypedArray(ctor)\n            || ctor === DataView || ctor === ArrayBuffer;\n    }\n    // #endregion\n\n    constructor(\n        classType: Function,\n    ) {\n        this.classType = classType;\n    }\n\n    dataMembers = new Map<string, JsonMemberMetadata>();\n\n    /** Set of known types used for polymorphic deserialization */\n    knownTypes = new Set<Serializable<any>>();\n    /** If present override the global function */\n    typeHintEmitter?: TypeHintEmitter;\n    /** If present override the global function */\n    typeResolver?: TypeResolver;\n\n    /** Gets or sets the constructor function for the jsonObject. */\n    classType: Function;\n\n    /**\n     * Indicates whether this class was explicitly annotated with @jsonObject\n     * or implicitly by @jsonMember\n     */\n    isExplicitlyMarked: boolean = false;\n\n    /**\n     * Indicates whether this type is handled without annotation. This is usually\n     * used for the builtin types (except for Maps, Sets, and normal Arrays).\n     */\n    isHandledWithoutAnnotation: boolean = false;\n\n    /** Name used to encode polymorphic type */\n    name?: string;\n\n    options?: OptionsBase;\n\n    onDeserializedMethodName?: string;\n\n    beforeSerializationMethodName?: string;\n\n    initializerCallback?: (sourceObject: Object, rawSourceObject: Object) => Object;\n}\n\nexport function injectMetadataInformation(prototype: IndexedObject, propKey: string | symbol, metadata: JsonMemberMetadata) {\n    const decoratorName = `@jsonMember on ${nameof(prototype.constructor)}.${String(propKey)}`; // For error messages.\n\n    // When a property decorator is applied to a static member, 'constructor' is a constructor function.\n    // See: https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md#property-decorators\n    // ... and static members are not supported here, so abort.\n    if (typeof prototype === 'function') {\n        logError(`${decoratorName}: cannot use a static property.`);\n        return;\n    }\n\n    // Methods cannot be serialized.\n    // @ts-ignore symbol indexing is not supported by ts\n    if (typeof prototype[propKey] === 'function') {\n        logError(`${decoratorName}: cannot use a method property.`);\n        return;\n    }\n\n    if (!metadata || (!metadata.type && !metadata.deserializer)) {\n        logError(`${decoratorName}: JsonMemberMetadata has unknown type.`);\n        return;\n    }\n\n    // Add jsonObject metadata to 'constructor' if not yet exists ('constructor' is the prototype).\n    // NOTE: this will not fire up custom serialization, as 'constructor' must be explicitly marked with '@jsonObject' as well.\n    const objectMetadata = JsonObjectMetadata.ensurePresentInPrototype(prototype);\n\n    if (!metadata.deserializer) {\n        // @ts-ignore above is a check (!deser && !ctor)\n        metadata.type.getTypes().forEach(ctor => objectMetadata.knownTypes.add(ctor));\n    }\n\n    // clear metadata of undefined properties to save memory\n    (Object.keys(metadata) as [keyof JsonMemberMetadata])\n        .forEach((key) => (metadata[key] === undefined) && delete metadata[key]);\n    objectMetadata.dataMembers.set(metadata.name, metadata);\n}\n","/**\n * This options cascade through the annotations. Options set\n * in the more specific place override the previous option.\n * Ex. @jsonMember overrides TypedJson options.\n */\nexport interface OptionsBase {\n    /**\n     * Whether to preserve null in the JSON output. When false it\n     * will not emit nor store the property if its value is null.\n     * Default: false.\n     */\n    preserveNull?: boolean;\n}\n\nconst kAllOptions: Array<keyof OptionsBase> = [\n    'preserveNull',\n];\n\nexport function extractOptionBase(from: {[key: string]: any} & OptionsBase): OptionsBase | undefined {\n    const options = Object.keys(from)\n        .filter(key => (kAllOptions as Array<string>).indexOf(key) > -1)\n        .reduce((obj, key) => {\n            obj[key] = from[key];\n            return obj;\n        }, {} as any);\n    return Object.keys(options).length > 0 ? options : undefined;\n}\n\nexport function getDefaultOptionOf<K extends keyof OptionsBase>(key: K): Required<OptionsBase>[K] {\n    switch (key) {\n        case 'preserveNull':\n            return false;\n    }\n    // never reached\n    return null as any;\n}\n\nexport function getOptionValue<K extends keyof OptionsBase>(\n    key: K,\n    options?: OptionsBase,\n): Required<OptionsBase>[K] {\n    if (options && options[key] != null) {\nreturn options[key]!;\n}\n    return getDefaultOptionOf(key);\n}\n\nexport function mergeOptions(\n    existing?: OptionsBase,\n    moreSpecific?: OptionsBase,\n): OptionsBase | undefined {\n    return !moreSpecific\n        ? existing\n        : {\n\n            ...existing,\n            ...moreSpecific,\n        };\n}\n","export abstract class TypeDescriptor {\n    protected constructor(readonly ctor: Function) {}\n\n    getTypes(): Array<Function> {\n        return [this.ctor];\n    }\n}\n\nexport type Typelike = TypeDescriptor | Function;\n\nexport class ConcreteTypeDescriptor extends TypeDescriptor {\n    constructor(ctor: Function) {\n        super(ctor);\n    }\n}\n\nexport abstract class GenericTypeDescriptor extends TypeDescriptor {\n    protected constructor(ctor: Function) {\n        super(ctor);\n    }\n}\n\nexport class ArrayTypeDescriptor extends GenericTypeDescriptor {\n    constructor(readonly elementType: TypeDescriptor) {\n        super(Array);\n    }\n\n    getTypes(): Array<Function> {\n        return super.getTypes().concat(this.elementType.getTypes());\n    }\n}\n\nexport function ArrayT(elementType: Typelike): ArrayTypeDescriptor {\n    return new ArrayTypeDescriptor(ensureTypeDescriptor(elementType));\n}\n\nexport class SetTypeDescriptor extends GenericTypeDescriptor {\n    constructor(readonly elementType: TypeDescriptor) {\n        super(Set);\n    }\n\n    getTypes(): Array<Function> {\n        return super.getTypes().concat(this.elementType.getTypes());\n    }\n}\n\nexport function SetT(elementType: Typelike): SetTypeDescriptor {\n    return new SetTypeDescriptor(ensureTypeDescriptor(elementType));\n}\n\nexport const enum MapShape {\n    /**\n     * A map will be serialized as an array of {key: ..., value: ...} objects.\n     */\n    ARRAY,\n\n    /**\n     * A map will be serialized as a JSON object.\n     */\n    OBJECT,\n}\n\nexport interface MapOptions {\n    /**\n     * How the map should be serialized. Default is ARRAY.\n     */\n    shape: MapShape;\n}\n\nexport class MapTypeDescriptor extends GenericTypeDescriptor {\n    constructor(\n        readonly keyType: TypeDescriptor,\n        readonly valueType: TypeDescriptor,\n        readonly options?: Partial<MapOptions>,\n    ) {\n        super(Map);\n    }\n\n    getTypes(): Array<Function> {\n        return super.getTypes().concat(this.keyType.getTypes(), this.valueType.getTypes());\n    }\n\n    getCompleteOptions(): MapOptions {\n        return {\n            shape: this.options?.shape ? this.options.shape : MapShape.ARRAY,\n        };\n    }\n}\n\nexport function MapT(keyType: Typelike, valueType: Typelike, options?: Partial<MapOptions>): MapTypeDescriptor {\n    return new MapTypeDescriptor(ensureTypeDescriptor(keyType), ensureTypeDescriptor(valueType), options);\n}\n\n// TODO support for dictionary types ie. maps that are plain objects\n// export class DictionaryTypeDescriptor extends GenericTypeDescriptor {\n//     constructor(public readonly elementType: TypeDescriptor) {\n//         super(Object);\n//     }\n//\n//     getTypes(): Function[] {\n//         return super.getTypes().concat(this.elementType.getTypes());\n//     }\n// }\n//\n// export function DictT(elementType: Typelike): DictionaryTypeDescriptor {\n//     return new DictionaryTypeDescriptor(ensureTypeDescriptor(elementType));\n// }\n\nexport function isTypelike(type: any): type is Typelike {\n    return type && (typeof type === 'function' || type instanceof TypeDescriptor);\n}\n\nexport function ensureTypeDescriptor(type: Typelike): TypeDescriptor {\n    return type instanceof TypeDescriptor ? type : new ConcreteTypeDescriptor(type);\n}\n","import {isSubtypeOf, isValueDefined, logError, nameof} from './helpers';\nimport {JsonObjectMetadata, TypeResolver} from './metadata';\nimport {getOptionValue, mergeOptions, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ConcreteTypeDescriptor,\n    MapShape,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from './type-descriptor';\nimport {Constructor, IndexedObject, Serializable} from './types';\n\nexport function defaultTypeResolver(sourceObject: IndexedObject, knownTypes: Map<string, Function>): Function | undefined {\n    if (sourceObject.__type) {\nreturn knownTypes.get(sourceObject.__type);\n}\n}\n\nexport type DeserializerFn<T, TD extends TypeDescriptor, Raw> = (\n    sourceObject: Raw,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<T>,\n    memberOptions?: OptionsBase,\n) => T;\n\n/**\n * Utility class, converts a simple/untyped javascript object-tree to a typed object-tree.\n * It is used after parsing a JSON-string.\n */\nexport class Deserializer<T> {\n    options?: OptionsBase;\n\n    private typeResolver: TypeResolver = defaultTypeResolver;\n    private nameResolver?: (ctor: Function) => string;\n    private errorHandler: (error: Error) => void = logError;\n    private deserializationStrategy = new Map<Serializable<any>, DeserializerFn<any, TypeDescriptor, any>>([\n        // primitives\n        [Number, deserializeDirectly],\n        [String, deserializeDirectly],\n        [Boolean, deserializeDirectly],\n\n        [Date, deserializeDate],\n        [ArrayBuffer, stringToArrayBuffer],\n        [DataView, stringToDataView],\n\n        [Array, convertAsArray],\n        [Set, convertAsSet],\n        [Map, convertAsMap],\n\n        // typed arrays\n        [Float32Array, convertAsFloatArray],\n        [Float64Array, convertAsFloatArray],\n        [Uint8Array, convertAsUintArray],\n        [Uint8ClampedArray, convertAsUintArray],\n        [Uint16Array, convertAsUintArray],\n        [Uint32Array, convertAsUintArray],\n    ]);\n\n    setNameResolver(nameResolverCallback: (ctor: Function) => string) {\n        this.nameResolver = nameResolverCallback;\n    }\n\n    setTypeResolver(typeResolverCallback: TypeResolver) {\n        if (typeof typeResolverCallback !== 'function') {\n            throw new TypeError('\\'typeResolverCallback\\' is not a function.');\n        }\n\n        this.typeResolver = typeResolverCallback;\n    }\n\n    getTypeResolver(): TypeResolver {\n        return this.typeResolver;\n    }\n\n    setErrorHandler(errorHandlerCallback: (error: Error) => void) {\n        if (typeof errorHandlerCallback !== 'function') {\n            throw new TypeError('\\'errorHandlerCallback\\' is not a function.');\n        }\n\n        this.errorHandler = errorHandlerCallback;\n    }\n\n    getErrorHandler(): (error: Error) => void {\n        return this.errorHandler;\n    }\n\n    convertSingleValue(\n        sourceObject: any,\n        typeDescriptor: TypeDescriptor,\n        knownTypes: Map<string, Function>,\n        memberName = 'object',\n        memberOptions?: OptionsBase,\n    ): any {\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) {\n            return null;\n        } else if (!isValueDefined(sourceObject)) {\n            return;\n        }\n\n        const deserializer = this.deserializationStrategy.get(typeDescriptor.ctor);\n        if (deserializer) {\n            return deserializer(sourceObject, typeDescriptor, knownTypes, memberName, this, memberOptions);\n        }\n\n        if (typeof sourceObject === 'object') {\n            return convertAsObject(sourceObject, typeDescriptor, knownTypes, memberName, this);\n        }\n        this.errorHandler(new TypeError(\n            `Could not deserialize '${memberName}': don't know how to deserialize this type'.`,\n));\n    }\n\n    instantiateType(ctor: any) {\n        return new ctor();\n    }\n\n    mergeKnownTypes(...knownTypeMaps: Array<Map<string, Function>>) {\n        const result = new Map<string, Function>();\n\n        knownTypeMaps.forEach(knownTypes => {\n            knownTypes.forEach((ctor, name) => {\n                if (this.nameResolver) {\n                    result.set(this.nameResolver(ctor), ctor);\n                } else {\n                    result.set(name, ctor);\n                }\n            });\n        });\n\n        return result;\n    }\n\n    createKnownTypesMap(knowTypes: Set<Function>) {\n        const map = new Map<string, Function>();\n\n        knowTypes.forEach(ctor => {\n            if (this.nameResolver) {\n                map.set(this.nameResolver(ctor), ctor);\n            } else {\n                const knownTypeMeta = JsonObjectMetadata.getFromConstructor(ctor);\n                const name = knownTypeMeta && knownTypeMeta.isExplicitlyMarked && knownTypeMeta.name\n                    ? knownTypeMeta.name\n                    : ctor.name;\n                map.set(name, ctor);\n            }\n        });\n\n        return map;\n    }\n\n    private isExpectedMapShape(source: any, expectedShape: MapShape): boolean {\n        return (expectedShape === MapShape.ARRAY && Array.isArray(source))\n        || (expectedShape === MapShape.OBJECT && typeof source === 'object');\n    }\n\n    retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n}\n\nfunction throwTypeMismatchError(\n    targetType: string,\n    expectedSourceType: string,\n    actualSourceType: string,\n    memberName: string,\n): never {\n    throw new TypeError(\n        `Could not deserialize ${memberName} as ${targetType}:`\n        + ` expected ${expectedSourceType}, got ${actualSourceType}.`,\n    );\n}\n\nfunction makeTypeErrorMessage(expectedType: Function | string, actualType: Function | string, memberName: string) {\n    const expectedTypeName = typeof expectedType === 'function' ? nameof(expectedType) : expectedType;\n    const actualTypeName = typeof actualType === 'function' ? nameof(actualType) : actualType;\n\n    return `Could not deserialize ${memberName}: expected '${expectedTypeName}', got '${actualTypeName}'.`;\n}\n\nfunction srcTypeNameForDebug(sourceObject: any) {\n    return sourceObject ? nameof(sourceObject.constructor) : 'undefined';\n}\n\nfunction deserializeDirectly<T extends string | number | boolean>(\n    sourceObject: T,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    objectName: string,\n): T {\n    if (sourceObject.constructor !== typeDescriptor.ctor) {\n        throw new TypeError(makeTypeErrorMessage(nameof(typeDescriptor.ctor), sourceObject.constructor, objectName));\n    }\n    return sourceObject;\n}\n\nfunction convertAsObject<T>(\n    sourceObject: IndexedObject,\n    typeDescriptor: ConcreteTypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n): IndexedObject | T | undefined {\n    if (typeof sourceObject !== 'object' || sourceObject === null) {\n        deserializer.getErrorHandler()(\n            new TypeError(`Cannot deserialize ${memberName}: 'sourceObject' must be a defined object.`),\n        );\n        return undefined;\n    }\n\n    let expectedSelfType = typeDescriptor.ctor;\n    let sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(expectedSelfType);\n    let knownTypeConstructors = knownTypes;\n    let typeResolver = deserializer.getTypeResolver();\n\n    if (sourceObjectMetadata) {\n        // Merge known types received from \"above\" with known types defined on the current type.\n        knownTypeConstructors = deserializer.mergeKnownTypes(\n            knownTypeConstructors,\n            deserializer.createKnownTypesMap(sourceObjectMetadata.knownTypes),\n        );\n        if (sourceObjectMetadata.typeResolver) {\n            typeResolver = sourceObjectMetadata.typeResolver;\n        }\n    }\n\n    // Check if a type-hint is available from the source object.\n    const typeFromTypeHint = typeResolver(sourceObject, knownTypeConstructors);\n\n    if (typeFromTypeHint) {\n        // Check if type hint is a valid subtype of the expected source type.\n        if (isSubtypeOf(typeFromTypeHint, expectedSelfType)) {\n            // Hell yes.\n            expectedSelfType = typeFromTypeHint;\n            sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(typeFromTypeHint);\n\n            if (sourceObjectMetadata) {\n                // Also merge new known types from subtype.\n                knownTypeConstructors = deserializer.mergeKnownTypes(\n                    knownTypeConstructors,\n                    deserializer.createKnownTypesMap(sourceObjectMetadata.knownTypes),\n                );\n            }\n        }\n    }\n\n    if (sourceObjectMetadata && sourceObjectMetadata.isExplicitlyMarked) {\n        const sourceMetadata = sourceObjectMetadata;\n        // Strong-typed deserialization available, get to it.\n        // First deserialize properties into a temporary object.\n        const sourceObjectWithDeserializedProperties = {} as IndexedObject;\n\n        const classOptions = mergeOptions(deserializer.options, sourceMetadata.options);\n\n        // Deserialize by expected properties.\n        sourceMetadata.dataMembers.forEach((objMemberMetadata, propKey) => {\n            const objMemberValue = sourceObject[propKey];\n            const objMemberDebugName = `${nameof(sourceMetadata.classType)}.${propKey}`;\n            const objMemberOptions = mergeOptions(classOptions, objMemberMetadata.options);\n\n            let revivedValue;\n            if (objMemberMetadata.deserializer) {\n                revivedValue = objMemberMetadata.deserializer(objMemberValue);\n            } else if (objMemberMetadata.type) {\n                revivedValue = deserializer.convertSingleValue(\n                    objMemberValue,\n                    objMemberMetadata.type,\n                    knownTypeConstructors,\n                    objMemberDebugName,\n                    objMemberOptions,\n                );\n            } else {\n                throw new TypeError(\n                    `Cannot deserialize ${objMemberDebugName} there is`\n                    + ` no constructor nor deserialization function to use.`,\n                );\n            }\n\n            if (isValueDefined(revivedValue)\n                || (deserializer.retrievePreserveNull(objMemberOptions) && revivedValue === null)\n            ) {\n                sourceObjectWithDeserializedProperties[objMemberMetadata.key] = revivedValue;\n            } else if (objMemberMetadata.isRequired) {\n                deserializer.getErrorHandler()(new TypeError(`Missing required member '${objMemberDebugName}'.`));\n            }\n        });\n\n        // Next, instantiate target object.\n        let targetObject: IndexedObject;\n\n        if (typeof sourceObjectMetadata.initializerCallback === 'function') {\n            try {\n                targetObject = sourceObjectMetadata.initializerCallback(\n                    sourceObjectWithDeserializedProperties,\n                    sourceObject,\n                );\n\n                // Check the validity of user-defined initializer callback.\n                if (!targetObject) {\n                    throw new TypeError(\n                        `Cannot deserialize ${memberName}:`\n                        + ` 'initializer' function returned undefined/null`\n                        + `, but '${nameof(sourceObjectMetadata.classType)}' was expected.`,\n                    );\n                } else if (!(targetObject instanceof sourceObjectMetadata.classType)) {\n                    throw new TypeError(\n                        `Cannot deserialize ${memberName}:`\n                        + `'initializer' returned '${nameof(targetObject.constructor)}'`\n                        + `, but '${nameof(sourceObjectMetadata.classType)}' was expected`\n                        + `, and '${nameof(targetObject.constructor)}' is not a subtype of`\n                        + ` '${nameof(sourceObjectMetadata.classType)}'`,\n                    );\n                }\n            } catch (e) {\n                deserializer.getErrorHandler()(e);\n                return undefined;\n            }\n        } else {\n            targetObject = deserializer.instantiateType(expectedSelfType);\n        }\n\n        // Finally, assign deserialized properties to target object.\n        Object.assign(targetObject, sourceObjectWithDeserializedProperties);\n\n        // Call onDeserialized method (if any).\n        if (sourceObjectMetadata.onDeserializedMethodName) {\n            // check for member first\n            if (typeof (targetObject as any)[sourceObjectMetadata.onDeserializedMethodName] === 'function') {\n                (targetObject as any)[sourceObjectMetadata.onDeserializedMethodName]();\n            }\n            // check for static\n            else if (typeof (targetObject.constructor as any)[sourceObjectMetadata.onDeserializedMethodName] === 'function') {\n                (targetObject.constructor as any)[sourceObjectMetadata.onDeserializedMethodName]();\n            } else {\n                deserializer.getErrorHandler()(new TypeError(\n                    `onDeserialized callback '${nameof(sourceObjectMetadata.classType)}.${sourceObjectMetadata.onDeserializedMethodName}' is not a method.`,\n                ));\n            }\n        }\n\n        return targetObject;\n    } else {\n        // Untyped deserialization into Object instance.\n        const targetObject = {} as IndexedObject;\n\n        Object.keys(sourceObject).forEach(sourceKey => {\n            targetObject[sourceKey] = deserializer.convertSingleValue(\n                sourceObject[sourceKey],\n                new ConcreteTypeDescriptor(sourceObject[sourceKey].constructor),\n                knownTypes,\n                sourceKey,\n            );\n        });\n\n        return targetObject;\n    }\n}\n\nfunction convertAsArray(\n    sourceObject: any,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n    memberOptions?: OptionsBase,\n): Array<any> {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor)) {\n        throw new TypeError(`Could not deserialize ${memberName} as Array: incorrect TypeDescriptor detected, please use`\n            + ' proper annotation or function for this type');\n    }\n    if (!Array.isArray(sourceObject)) {\n        deserializer.getErrorHandler()(\n            new TypeError(makeTypeErrorMessage(Array, sourceObject.constructor, memberName)),\n        );\n        return [];\n    }\n\n    if (!typeDescriptor.elementType) {\n        deserializer.getErrorHandler()(\n            new TypeError(`Could not deserialize ${memberName} as Array: missing constructor reference of Array elements.`),\n        );\n        return [];\n    }\n\n    return sourceObject.map(element => {\n        // If an array element fails to deserialize, substitute with undefined. This is so that the original ordering is not interrupted by faulty\n        // entries, as an Array is ordered.\n        try {\n            return deserializer.convertSingleValue(\n                element,\n                typeDescriptor.elementType,\n                knownTypes,\n                `${memberName}[]`,\n                memberOptions,\n            );\n        } catch (e) {\n            deserializer.getErrorHandler()(e);\n\n            // Keep filling the array here with undefined to keep original ordering.\n            // Note: this is just aesthetics, not returning anything produces the same result.\n            return undefined;\n        }\n    });\n}\n\nfunction convertAsSet(\n    sourceObject: any,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n    memberOptions?: OptionsBase,\n): Set<any> {\n    if (!(typeDescriptor instanceof SetTypeDescriptor)) {\n        throw new TypeError(`Could not deserialize ${memberName} as Set: incorrect TypeDescriptor detected, please use`\n            + ' proper annotation or function for this type');\n    }\n    if (!Array.isArray(sourceObject)) {\n        deserializer.getErrorHandler()(new TypeError(makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n        return new Set<any>();\n    }\n\n    if (!typeDescriptor.elementType) {\n        deserializer.getErrorHandler()(\n            new TypeError(`Could not deserialize ${memberName} as Set: missing constructor reference of Set elements.`),\n        );\n        return new Set<any>();\n    }\n\n    const resultSet = new Set<any>();\n\n    sourceObject.forEach((element, i) => {\n        try {\n            resultSet.add(deserializer.convertSingleValue(\n                element,\n                typeDescriptor.elementType,\n                knownTypes,\n                `${memberName}[${i}]`,\n                memberOptions,\n            ));\n        } catch (e) {\n            // Faulty entries are skipped, because a Set is not ordered, and skipping an entry\n            // does not affect others.\n            deserializer.getErrorHandler()(e);\n        }\n    });\n\n    return resultSet;\n}\n\nfunction isExpectedMapShape(source: any, expectedShape: MapShape): boolean {\n    return (expectedShape === MapShape.ARRAY && Array.isArray(source))\n        || (expectedShape === MapShape.OBJECT && typeof source === 'object');\n}\n\nfunction convertAsMap(\n    sourceObject: any,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n    memberOptions?: OptionsBase,\n): Map<any, any> {\n    if (!(typeDescriptor instanceof MapTypeDescriptor)) {\n        throw new TypeError(`Could not deserialize ${memberName} as Map: incorrect TypeDescriptor detected, please use`\n            + ' proper annotation or function for this type');\n    }\n    const expectedShape = typeDescriptor.getCompleteOptions().shape;\n    if (!isExpectedMapShape(sourceObject, expectedShape)) {\n        const expectedType = expectedShape === MapShape.ARRAY ? Array : Object;\n        deserializer.getErrorHandler()(\n            new TypeError(makeTypeErrorMessage(expectedType, sourceObject.constructor, memberName)),\n        );\n        return new Map<any, any>();\n    }\n\n    if (!typeDescriptor.keyType) {\n        deserializer.getErrorHandler()(\n            new TypeError(`Could not deserialize ${memberName} as Map: missing key constructor.`),\n        );\n        return new Map<any, any>();\n    }\n\n    if (!typeDescriptor.valueType) {\n        deserializer.getErrorHandler()(\n            new TypeError(`Could not deserialize ${memberName} as Map: missing value constructor.`),\n        );\n        return new Map<any, any>();\n    }\n\n    const resultMap = new Map<any, any>();\n\n    if (expectedShape === MapShape.OBJECT) {\n        Object.keys(sourceObject).forEach(key => {\n            try {\n                const resultKey = deserializer.convertSingleValue(\n                    key,\n                    typeDescriptor.keyType,\n                    knownTypes,\n                    memberName,\n                    memberOptions,\n                );\n                if (isValueDefined(resultKey)) {\n                    resultMap.set(\n                        resultKey,\n                        deserializer.convertSingleValue(\n                            sourceObject[key],\n                            typeDescriptor.valueType,\n                            knownTypes,\n                            `${memberName}[${resultKey}]`,\n                            memberOptions,\n                        ),\n                    );\n                }\n            } catch (e) {\n                // Faulty entries are skipped, because a Map is not ordered,\n                // and skipping an entry does not affect others.\n                deserializer.getErrorHandler()(e);\n            }\n        });\n    } else {\n        sourceObject.forEach((element: any) => {\n            try {\n                const key = deserializer.convertSingleValue(\n                    element.key,\n                    typeDescriptor.keyType,\n                    knownTypes,\n                    memberName,\n                    memberOptions,\n                );\n\n                // Undefined/null keys not supported, skip if so.\n                if (isValueDefined(key)) {\n                    resultMap.set(\n                        key,\n                        deserializer.convertSingleValue(\n                            element.value,\n                            typeDescriptor.valueType,\n                            knownTypes,\n                            `${memberName}[${key}]`,\n                            memberOptions,\n                        ),\n                    );\n                }\n            } catch (e) {\n                // Faulty entries are skipped, because a Map is not ordered,\n                // and skipping an entry does not affect others.\n                deserializer.getErrorHandler()(e);\n            }\n        });\n    }\n\n    return resultMap;\n}\n\nfunction deserializeDate(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n): Date {\n    // Support for Date with ISO 8601 format, or with numeric timestamp (milliseconds elapsed since the Epoch).\n    // ISO 8601 spec.: https://www.w3.org/TR/NOTE-datetime\n\n    if (typeof sourceObject === 'string' || (typeof sourceObject === 'number' && sourceObject > 0)) {\n        return new Date(sourceObject as any);\n    } else if (sourceObject instanceof Date) {\n        return sourceObject;\n    } else {\n        throwTypeMismatchError('Date', 'an ISO-8601 string', srcTypeNameForDebug(sourceObject), memberName);\n    }\n}\n\nfunction stringToArrayBuffer(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n) {\n    if (typeof sourceObject !== 'string') {\n        throwTypeMismatchError('ArrayBuffer', 'a string source', srcTypeNameForDebug(sourceObject), memberName);\n    }\n    return createArrayBufferFromString(sourceObject);\n}\n\nfunction stringToDataView(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n) {\n    if (typeof sourceObject !== 'string') {\n        throwTypeMismatchError('DataView', 'a string source', srcTypeNameForDebug(sourceObject), memberName);\n    }\n    return new DataView(createArrayBufferFromString(sourceObject));\n}\n\nfunction createArrayBufferFromString(input: string): ArrayBuffer {\n    const buf = new ArrayBuffer(input.length * 2); // 2 bytes for each char\n    const bufView = new Uint16Array(buf);\n\n    for (let i = 0, strLen = input.length; i < strLen; i++) {\n        bufView[i] = input.charCodeAt(i);\n    }\n\n    return buf;\n}\n\nfunction convertAsFloatArray<T extends Float32Array | Float64Array>(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n): T {\n    const constructor = typeDescriptor.ctor as Constructor<T>;\n    if (Array.isArray(sourceObject) && sourceObject.every(elem => !isNaN(elem))) {\n        return new constructor(sourceObject);\n    }\n    return throwTypeMismatchError(\n        constructor.name,\n        'a numeric source array',\n        srcTypeNameForDebug(sourceObject),\n        memberName,\n    );\n}\n\nfunction convertAsUintArray<T extends Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array>(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n): T {\n    const constructor = typeDescriptor.ctor as Constructor<T>;\n    if (Array.isArray(sourceObject) && sourceObject.every(elem => !isNaN(elem))) {\n        return new constructor(sourceObject.map(value => ~~value));\n    }\n    return throwTypeMismatchError(\n        typeDescriptor.ctor.name,\n        'a numeric source array',\n        srcTypeNameForDebug(sourceObject),\n        memberName,\n    );\n}\n","import {isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ensureTypeDescriptor,\n    isTypelike,\n    TypeDescriptor,\n} from './type-descriptor';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonArrayMemberOptions extends OptionsBase {\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, an empty array is emitted if the property is undefined/uninitialized. */\n    emitDefaultValue?: boolean;\n\n    /** Sets array dimensions (e.g. 1 for 'number[]' or 2 for 'number[][]'). Defaults to 1. */\n    dimensions?: number;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property, of type array, is part of an object when serializing.\n * @param elementConstructor Constructor of array elements (e.g. 'Number' for 'number[]', or 'Date' for 'Date[]').\n * @param options Additional options.\n */\nexport function jsonArrayMember(elementConstructor: Function | TypeDescriptor, options: IJsonArrayMemberOptions = {}) {\n    return (target: Object, propKey: string | symbol) => {\n        const decoratorName = `@jsonArrayMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (!isTypelike(elementConstructor)) {\n            logError(`${decoratorName}: could not resolve constructor of array elements at runtime.`);\n            return;\n        }\n\n        const dimensions = options.dimensions === undefined ? 1 : options.dimensions;\n        if (!isNaN(dimensions) && dimensions < 1) {\n            logError(`${decoratorName}: 'dimensions' option must be at least 1.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonArrayMember' has been used on an array.\n        if (isReflectMetadataSupported && Reflect.getMetadata('design:type', target, propKey) !== Array) {\n            logError(`${decoratorName}: property is not an Array. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: createArrayType(ensureTypeDescriptor(elementConstructor), dimensions),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n\nexport function createArrayType(elementType: TypeDescriptor, dimensions: number): ArrayTypeDescriptor {\n    let type = new ArrayTypeDescriptor(elementType);\n    for (let i = 1; i < dimensions; ++i) {\n        type = new ArrayTypeDescriptor(type);\n    }\n    return type;\n}\n","import {\n    identity,\n    isInstanceOf,\n    isValueDefined,\n    logError,\n    nameof,\n} from './helpers';\nimport {JsonObjectMetadata, TypeHintEmitter} from './metadata';\nimport {getOptionValue, mergeOptions, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ConcreteTypeDescriptor,\n    MapShape,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from './type-descriptor';\nimport {IndexedObject, Serializable} from './types';\n\nexport function defaultTypeEmitter(\n    targetObject: IndexedObject,\n    sourceObject: IndexedObject,\n    expectedSourceType: Function,\n    sourceTypeMetadata?: JsonObjectMetadata,\n) {\n    // By default, we put a \"__type\" property on the output object if the actual object is not the\n    // same as the expected one, so that deserialization will know what to deserialize into (given\n    // the required known-types are defined, and the object is a valid subtype of the expected type).\n    if (sourceObject.constructor !== expectedSourceType) {\n        targetObject.__type = sourceTypeMetadata && sourceTypeMetadata.name\n            ? sourceTypeMetadata.name\n            : nameof(sourceObject.constructor);\n    }\n}\n\n/**\n * @param sourceObject The original object that should be serialized.\n * @param typeDescriptor Instance of TypeDescriptor containing information about expected serialization.\n * @param memberName Name of the object being serialized, used for debugging purposes.\n * @param serializer Serializer instance, aiding with recursive serialization.\n * @param memberOptions If converted as a member, the member options.\n */\nexport type SerializerFn<T, TD extends TypeDescriptor, Raw> = (\n    sourceObject: T,\n    typeDescriptor: TD,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n) => Raw;\n\n/**\n * Utility class, converts a typed object tree (i.e. a tree of class instances, arrays of class\n * instances, and so on) to an untyped javascript object (also called \"simple javascript object\"),\n * and emits any necessary type hints in the process (for polymorphism).\n *\n * The converted object tree is what will be given to `JSON.stringify` to convert to string as the\n * last step, the serialization is basically like:\n *\n * (1) typed object-tree -> (2) simple JS object-tree -> (3) JSON-string\n */\nexport class Serializer {\n    options?: OptionsBase;\n    private typeHintEmitter: TypeHintEmitter = defaultTypeEmitter;\n    private errorHandler: (error: Error) => void = logError;\n    private serializationStrategy = new Map<Serializable<any>, SerializerFn<any, TypeDescriptor, any>>([\n        // primitives\n        [Date, identity],\n        [Number, identity],\n        [String, identity],\n        [Boolean, identity],\n\n        [ArrayBuffer, convertAsArrayBuffer],\n        [DataView, convertAsDataView],\n\n        [Array, convertAsArray],\n        [Set, convertAsSet],\n        [Map, convertAsMap],\n\n        // typed arrays\n        [Float32Array, convertAsTypedArray],\n        [Float64Array, convertAsTypedArray],\n        [Int8Array, convertAsTypedArray],\n        [Uint8Array, convertAsTypedArray],\n        [Uint8ClampedArray, convertAsTypedArray],\n        [Int16Array, convertAsTypedArray],\n        [Uint16Array, convertAsTypedArray],\n        [Int32Array, convertAsTypedArray],\n        [Uint32Array, convertAsTypedArray],\n    ]);\n\n    setTypeHintEmitter(typeEmitterCallback: TypeHintEmitter) {\n        if (typeof typeEmitterCallback !== 'function') {\n            throw new TypeError('\\'typeEmitterCallback\\' is not a function.');\n        }\n\n        this.typeHintEmitter = typeEmitterCallback;\n    }\n\n    getTypeHintEmitter(): TypeHintEmitter {\n        return this.typeHintEmitter;\n    }\n\n    setErrorHandler(errorHandlerCallback: (error: Error) => void) {\n        if (typeof errorHandlerCallback !== 'function') {\n            throw new TypeError('\\'errorHandlerCallback\\' is not a function.');\n        }\n\n        this.errorHandler = errorHandlerCallback;\n    }\n\n    getErrorHandler(): (error: Error) => void {\n        return this.errorHandler;\n    }\n\n    retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n\n    /**\n     * Convert a value of any supported serializable type.\n     * The value type will be detected, and the correct serialization method will be called.\n     */\n    convertSingleValue(\n        sourceObject: any,\n        typeDescriptor: TypeDescriptor,\n        memberName: string = 'object',\n        memberOptions?: OptionsBase,\n    ): any {\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) {\nreturn null;\n}\n        if (!isValueDefined(sourceObject)) {\nreturn;\n}\n\n        if (!isInstanceOf(sourceObject, typeDescriptor.ctor)) {\n            const expectedName = nameof(typeDescriptor.ctor);\n            const actualName = nameof(sourceObject.constructor);\n\n            this.errorHandler(new TypeError(\n                `Could not serialize '${memberName}': expected '${expectedName}', got '${actualName}'.`,\n));\n            return;\n        }\n\n        const serializer = this.serializationStrategy.get(typeDescriptor.ctor);\n        if (serializer) {\n            return serializer(sourceObject, typeDescriptor, memberName, this, memberOptions);\n        }\n        // if not present in the strategy do property by property serialization\n        if (typeof sourceObject === 'object') {\n            return convertAsObject(sourceObject, typeDescriptor, memberName, this, memberOptions);\n        }\n        this.errorHandler(new TypeError(\n            `Could not serialize '${memberName}': don't know how to serialize this type'.`,\n));\n    }\n}\n\n/**\n * Performs the conversion of a typed object (usually a class instance) to a simple\n * javascript object for serialization.\n */\nfunction convertAsObject(\n    sourceObject: IndexedObject,\n    typeDescriptor: ConcreteTypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n) {\n    let sourceTypeMetadata: JsonObjectMetadata | undefined;\n    let targetObject: IndexedObject;\n    let typeHintEmitter = serializer.getTypeHintEmitter();\n\n    if (sourceObject.constructor !== typeDescriptor.ctor && sourceObject instanceof typeDescriptor.ctor) {\n        // The source object is not of the expected type, but it is a valid subtype.\n        // This is OK, and we'll proceed to gather object metadata from the subtype instead.\n        sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(sourceObject.constructor);\n    } else {\n        sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(typeDescriptor.ctor);\n    }\n\n    if (sourceTypeMetadata) {\n        if (sourceTypeMetadata.beforeSerializationMethodName) {\n            // check for member first\n            if (typeof (sourceObject as any)[sourceTypeMetadata.beforeSerializationMethodName] === 'function') {\n                (sourceObject as any)[sourceTypeMetadata.beforeSerializationMethodName]();\n            }\n            // check for static\n            else if (typeof (sourceObject.constructor as any)[sourceTypeMetadata.beforeSerializationMethodName] === 'function') {\n                (sourceObject.constructor as any)[sourceTypeMetadata.beforeSerializationMethodName]();\n            } else {\n                serializer.getErrorHandler()(new TypeError(\n                    `beforeSerialization callback '${nameof(sourceTypeMetadata.classType)}.${sourceTypeMetadata.beforeSerializationMethodName}' is not a method.`,\n                ));\n            }\n        }\n\n        const sourceMeta = sourceTypeMetadata;\n        // Strong-typed serialization available.\n        // We'll serialize by members that have been marked with @jsonMember (including array/set/map members),\n        // and perform recursive conversion on each of them. The converted objects are put on the 'targetObject',\n        // which is what will be put into 'JSON.stringify' finally.\n        targetObject = {};\n\n        const classOptions = mergeOptions(serializer.options, sourceMeta.options);\n        if (sourceMeta.typeHintEmitter) {\n            typeHintEmitter = sourceMeta.typeHintEmitter;\n        }\n\n        sourceMeta.dataMembers.forEach((objMemberMetadata) => {\n            const objMemberOptions = mergeOptions(classOptions, objMemberMetadata.options);\n            let serialized;\n            if (objMemberMetadata.serializer) {\n                serialized = objMemberMetadata.serializer(sourceObject[objMemberMetadata.key]);\n            } else if (objMemberMetadata.type) {\n                serialized = serializer.convertSingleValue(\n                    sourceObject[objMemberMetadata.key],\n                    objMemberMetadata.type,\n                    `${nameof(sourceMeta.classType)}.${objMemberMetadata.key}`,\n                    objMemberOptions,\n                );\n            } else {\n                throw new TypeError(\n                    `Could not serialize ${objMemberMetadata.name}, there is`\n                    + ` no constructor nor serialization function to use.`,\n                );\n            }\n\n            if (isValueDefined(serialized)\n                || (serializer.retrievePreserveNull(objMemberOptions) && serialized === null)\n            ) {\n                targetObject[objMemberMetadata.name] = serialized;\n            }\n        });\n    } else {\n        // Untyped serialization, \"as-is\", we'll just pass the object on.\n        // We'll clone the source object, because type hints are added to the object itself, and we don't want to modify\n        // to the original object.\n        targetObject = {...sourceObject};\n    }\n\n    // Add type-hint.\n    typeHintEmitter(targetObject, sourceObject, typeDescriptor.ctor, sourceTypeMetadata);\n\n    return targetObject;\n}\n\n/**\n * Performs the conversion of an array of typed objects (or primitive values) to an array of simple javascript objects\n * (or primitive values) for serialization.\n */\nfunction convertAsArray(\n    sourceObject: Array<any>,\n    typeDescriptor: TypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n): Array<any> {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor)) {\n        throw new TypeError(`Could not serialize ${memberName} as Array: incorrect TypeDescriptor detected, please use`\n            + ' proper annotation or function for this type');\n    }\n    if (!typeDescriptor.elementType) {\n        throw new TypeError(`Could not serialize ${memberName} as Array: missing element type definition.`);\n    }\n\n    // Check the type of each element, individually.\n    // If at least one array element type is incorrect, we return undefined, which results in no\n    // value emitted during serialization. This is so that invalid element types don't unexpectedly\n    // alter the ordering of other, valid elements, and that no unexpected undefined values are in\n    // the emitted array.\n    sourceObject.forEach((element, i) => {\n        if (!(serializer.retrievePreserveNull(memberOptions) && element === null)\n            && !isInstanceOf(element, typeDescriptor.elementType.ctor)\n        ) {\n            const expectedTypeName = nameof(typeDescriptor.elementType.ctor);\n            const actualTypeName = element && nameof(element.constructor);\n            throw new TypeError(`Could not serialize ${memberName}[${i}]:`\n                + ` expected '${expectedTypeName}', got '${actualTypeName}'.`);\n        }\n    });\n\n    if (memberName) {\n        // Just for debugging purposes.\n        memberName += '[]';\n    }\n\n    return sourceObject.map(\n        element => serializer.convertSingleValue(element, typeDescriptor.elementType, memberName, memberOptions),\n    );\n}\n\n/**\n * Performs the conversion of a set of typed objects (or primitive values) into an array\n * of simple javascript objects.\n * @returns\n */\nfunction convertAsSet(\n    sourceObject: Set<any>,\n    typeDescriptor: TypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n): Array<any> {\n    if (!(typeDescriptor instanceof SetTypeDescriptor)) {\n        throw new TypeError(`Could not serialize ${memberName} as Set: incorrect TypeDescriptor detected, please use`\n            + ' proper annotation or function for this type');\n    }\n    if (!typeDescriptor.elementType) {\n        throw new TypeError(`Could not serialize ${memberName} as Set: missing element type definition.`);\n    }\n\n    // For debugging and error tracking.\n    if (memberName) {\n        memberName += '[]';\n    }\n\n    const resultArray: Array<any> = [];\n\n    // Convert each element of the set, and put it into an output array.\n    // The output array is the one serialized, as JSON.stringify does not support Set serialization.\n    // (TODO: clarification needed)\n    sourceObject.forEach(element => {\n        const resultElement = serializer.convertSingleValue(element, typeDescriptor.elementType, memberName, memberOptions);\n\n        // Add to output if the source element was undefined, OR the converted element is defined.\n        // This will add intentionally undefined values to output, but not values that became undefined\n        // DURING serializing (usually because of a type-error).\n        if (!isValueDefined(element) || isValueDefined(resultElement)) {\n            resultArray.push(resultElement);\n        }\n    });\n\n    return resultArray;\n}\n\n/**\n * Performs the conversion of a map of typed objects (or primitive values) into an array\n * of simple javascript objects with `key` and `value` properties.\n */\nfunction convertAsMap(\n    sourceObject: Map<any, any>,\n    typeDescriptor: TypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n): IndexedObject | Array<{ key: any; value: any }> {\n    if (!(typeDescriptor instanceof MapTypeDescriptor)) {\n        throw new TypeError(`Could not serialize ${memberName} as Map: incorrect TypeDescriptor detected, please use`\n            + ' proper annotation or function for this type');\n    }\n    if (!typeDescriptor.valueType) {\n        throw new TypeError(`Could not serialize ${memberName} as Map: missing value type definition.`);\n    }\n\n    if (!typeDescriptor.keyType) {\n        throw new TypeError(`Could not serialize ${memberName} as Map: missing key type definition.`);\n    }\n\n    if (memberName) {\n        memberName += '[]';\n    }\n\n    // const resultArray: Array<{ key: any, value: any }> = [];\n    const resultShape = typeDescriptor.getCompleteOptions().shape;\n    const result = resultShape === MapShape.OBJECT ? ({} as IndexedObject) : [];\n    const preserveNull = serializer.retrievePreserveNull(memberOptions);\n\n    // Convert each *entry* in the map to a simple javascript object with key and value properties.\n    sourceObject.forEach((value, key) => {\n        const resultKeyValuePairObj = {\n            key: serializer.convertSingleValue(key, typeDescriptor.keyType, memberName, memberOptions),\n            value: serializer.convertSingleValue(value, typeDescriptor.valueType, memberName, memberOptions),\n        };\n\n        // We are not going to emit entries with undefined keys OR undefined values.\n        const keyDefined = isValueDefined(resultKeyValuePairObj.key);\n        const valueDefined = isValueDefined(resultKeyValuePairObj.value)\n            || (resultKeyValuePairObj.value === null && preserveNull);\n        if (keyDefined && valueDefined) {\n            if (resultShape === MapShape.OBJECT) {\n                result[resultKeyValuePairObj.key] = resultKeyValuePairObj.value;\n            } else {\n                result.push(resultKeyValuePairObj);\n            }\n        }\n    });\n\n    return result;\n}\n\n/**\n * Performs the conversion of a typed javascript array to a simple untyped javascript array.\n * This is needed because typed arrays are otherwise serialized as objects, so we'll end up\n * with something like \"{ 0: 0, 1: 1, ... }\".\n */\nfunction convertAsTypedArray(sourceObject: ArrayBufferView) {\n    return Array.from(sourceObject as any);\n}\n\n/**\n * Performs the conversion of a raw ArrayBuffer to a string.\n */\nfunction convertAsArrayBuffer(buffer: ArrayBuffer) {\n    // ArrayBuffer -> 16-bit character codes -> character array -> joined string.\n    return Array.from(new Uint16Array(buffer)).map(charCode => String.fromCharCode(charCode)).join('');\n}\n\n/**\n * Performs the conversion of DataView, converting its internal ArrayBuffer to a string and\n * returning that string.\n */\nfunction convertAsDataView(dataView: DataView) {\n    return convertAsArrayBuffer(dataView.buffer);\n}\n","import {defaultTypeResolver, Deserializer} from './typedjson/deserializer';\nimport {logError, logWarning, nameof, parseToJSObject} from './typedjson/helpers';\nimport {createArrayType} from './typedjson/json-array-member';\nimport {JsonObjectMetadata, TypeHintEmitter, TypeResolver} from './typedjson/metadata';\nimport {extractOptionBase, OptionsBase} from './typedjson/options-base';\nimport {defaultTypeEmitter, Serializer} from './typedjson/serializer';\nimport {ensureTypeDescriptor, MapT, SetT} from './typedjson/type-descriptor';\nimport {Constructor, IndexedObject, Serializable} from './typedjson/types';\n\nexport type JsonTypes = Object | boolean | string | number | null | undefined;\nexport {defaultTypeResolver, defaultTypeEmitter};\n\nexport interface ITypedJSONSettings extends OptionsBase {\n    /**\n     * Sets the handler callback to invoke on errors during serializing and deserializing.\n     * Re-throwing errors in this function will halt serialization/deserialization.\n     * The default behavior is to log errors to the console.\n     */\n    errorHandler?: (e: Error) => void;\n\n    /**\n     * Sets a callback that determines the constructor of the correct sub-type of polymorphic\n     * objects while deserializing.\n     * The default behavior is to read the type-name from the '__type' property of 'sourceObject',\n     * and look it up in 'knownTypes'.\n     * The constructor of the sub-type should be returned.\n     */\n    typeResolver?: TypeResolver;\n\n    nameResolver?: (ctor: Function) => string;\n\n    /**\n     * Sets a callback that writes type-hints to serialized objects.\n     * The default behavior is to write the type-name to the '__type' property, if a derived type\n     * is present in place of a base type.\n     */\n    typeHintEmitter?: TypeHintEmitter;\n\n    /**\n     * Sets the amount of indentation to use in produced JSON strings.\n     * Default value is 0, or no indentation.\n     */\n    indent?: number;\n\n    replacer?: (key: string, value: any) => any;\n\n    knownTypes?: Array<Constructor<any>>;\n}\n\nexport class TypedJSON<T> {\n    // #region Static\n    static parse<T>(object: any, rootType: Serializable<T>, settings?: ITypedJSONSettings): T | undefined {\n        return new TypedJSON(rootType, settings).parse(object);\n    }\n\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: 1\n    ): Array<T>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 2\n    ): Array<Array<T>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 3\n    ): Array<Array<Array<T>>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 4\n    ): Array<Array<Array<Array<T>>>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 5\n    ): Array<Array<Array<Array<Array<T>>>>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: number,\n    ): Array<any> {\n        return new TypedJSON(elementType, settings).parseAsArray(object, dimensions as any);\n    }\n\n    static parseAsSet<T>(object: any, elementType: Serializable<T>, settings?: ITypedJSONSettings): Set<T> {\n        return new TypedJSON(elementType, settings).parseAsSet(object);\n    }\n\n    static parseAsMap<K, V>(\n        object: any,\n        keyType: Serializable<K>,\n        valueType: Serializable<V>,\n        settings?: ITypedJSONSettings,\n    ): Map<K, V> {\n        return new TypedJSON(valueType, settings).parseAsMap(object, keyType);\n    }\n\n    static toPlainJson<T>(object: T, rootType: Serializable<T>, settings?: ITypedJSONSettings): JsonTypes {\n        return new TypedJSON(rootType, settings).toPlainJson(object);\n    }\n\n    static toPlainArray<T>(\n        object: Array<T>, elementType: Serializable<T>, dimensions?: 1, settings?: ITypedJSONSettings,\n    ): Array<Object>;\n    static toPlainArray<T>(\n        object: Array<Array<T>>, elementType: Serializable<T>, dimensions: 2, settings?: ITypedJSONSettings,\n    ): Array<Array<Object>>;\n    static toPlainArray<T>(\n        object: Array<Array<Array<T>>>, elementType: Serializable<T>, dimensions: 3, settings?: ITypedJSONSettings,\n    ): Array<Array<Array<Object>>>;\n    static toPlainArray<T>(\n        object: Array<Array<Array<Array<T>>>>, elementType: Serializable<T>, dimensions: 4, settings?: ITypedJSONSettings,\n    ): Array<Array<Array<Array<Object>>>>;\n    static toPlainArray<T>(\n        object: Array<Array<Array<Array<Array<T>>>>>, elementType: Serializable<T>, dimensions: 5, settings?: ITypedJSONSettings,\n    ): Array<Array<Array<Array<Array<Object>>>>>;\n    static toPlainArray<T>(\n        object: Array<any>, elementType: Serializable<T>, dimensions: number, settings?: ITypedJSONSettings,\n    ): Array<any>;\n    static toPlainArray<T>(object: Array<any>, elementType: Serializable<T>, dimensions?: any, settings?: ITypedJSONSettings): Array<any> {\n        return new TypedJSON(elementType, settings).toPlainArray(object, dimensions);\n    }\n\n    static toPlainSet<T>(object: Set<T>, elementType: Serializable<T>, settings?: ITypedJSONSettings): Array<Object> | undefined {\n        return new TypedJSON(elementType, settings).toPlainSet(object);\n    }\n\n    static toPlainMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Serializable<K>,\n        valueCtor: Serializable<V>,\n        settings?: ITypedJSONSettings,\n    ): IndexedObject | Array<{ key: any; value: any }> | undefined {\n        return new TypedJSON(valueCtor, settings).toPlainMap(object, keyCtor);\n    }\n\n    static stringify<T>(object: T, rootType: Serializable<T>, settings?: ITypedJSONSettings): string {\n        return new TypedJSON(rootType, settings).stringify(object);\n    }\n\n    static stringifyAsArray<T>(\n        object: Array<T>, elementType: Serializable<T>, dimensions?: 1, settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<T>>, elementType: Serializable<T>, dimensions: 2, settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<Array<T>>>, elementType: Serializable<T>, dimensions: 3, settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<Array<Array<T>>>>, elementType: Serializable<T>, dimensions: 4, settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<Array<Array<Array<T>>>>>, elementType: Serializable<T>, dimensions: 5, settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<any>, elementType: Serializable<T>, dimensions: number, settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(object: Array<any>, elementType: Serializable<T>, dimensions?: any, settings?: ITypedJSONSettings): string {\n        return new TypedJSON(elementType, settings).stringifyAsArray(object, dimensions);\n    }\n\n    static stringifyAsSet<T>(object: Set<T>, elementType: Serializable<T>, settings?: ITypedJSONSettings): string {\n        return new TypedJSON(elementType, settings).stringifyAsSet(object);\n    }\n\n    static stringifyAsMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Serializable<K>,\n        valueCtor: Serializable<V>,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(valueCtor, settings).stringifyAsMap(object, keyCtor);\n    }\n\n    private static _globalConfig: ITypedJSONSettings;\n\n    static setGlobalConfig(config: ITypedJSONSettings) {\n        if (this._globalConfig) {\n            Object.assign(this._globalConfig, config);\n        } else {\n            this._globalConfig = config;\n        }\n    }\n\n    // #endregion\n\n    private serializer: Serializer = new Serializer();\n    private deserializer: Deserializer<T> = new Deserializer<T>();\n    private globalKnownTypes: Array<Constructor<any>> = [];\n    private indent: number = 0;\n    private rootConstructor: Serializable<T>;\n    private errorHandler: (e: Error) => void;\n    private nameResolver: (ctor: Function) => string;\n    private replacer?: (key: string, value: any) => any;\n\n    /**\n     * Creates a new TypedJSON instance to serialize (stringify) and deserialize (parse) object\n     *     instances of the specified root class type.\n     * @param rootConstructor The constructor of the root class type.\n     * @param settings Additional configuration settings.\n     */\n    constructor(rootConstructor: Serializable<T>, settings?: ITypedJSONSettings) {\n        const rootMetadata = JsonObjectMetadata.getFromConstructor(rootConstructor);\n\n        if (!rootMetadata || (!rootMetadata.isExplicitlyMarked && !rootMetadata.isHandledWithoutAnnotation)) {\n            throw new TypeError('The TypedJSON root data type must have the @jsonObject decorator used.');\n        }\n\n        this.nameResolver = (ctor) => nameof(ctor);\n        this.rootConstructor = rootConstructor;\n        this.errorHandler = (error) => logError(error);\n\n        if (settings) {\n            this.config(settings);\n        } else if (TypedJSON._globalConfig) {\n            this.config({});\n        }\n    }\n\n    /**\n     * Configures TypedJSON through a settings object.\n     * @param settings The configuration settings object.\n     */\n    config(settings: ITypedJSONSettings) {\n        if (TypedJSON._globalConfig) {\n            settings = {\n                ...TypedJSON._globalConfig,\n                ...settings,\n            };\n\n            if (settings.knownTypes && TypedJSON._globalConfig.knownTypes) {\n                // Merge known-types (also de-duplicate them, so Array -> Set -> Array).\n                settings.knownTypes = Array.from(new Set(\n                    settings.knownTypes.concat(TypedJSON._globalConfig.knownTypes),\n                ));\n            }\n        }\n\n        const options = extractOptionBase(settings);\n        this.serializer.options = options;\n        this.deserializer.options = options;\n\n        if (settings.errorHandler) {\n            this.errorHandler = settings.errorHandler;\n            this.deserializer.setErrorHandler(settings.errorHandler);\n            this.serializer.setErrorHandler(settings.errorHandler);\n        }\n\n        if (settings.replacer) {\nthis.replacer = settings.replacer;\n}\n        if (settings.typeResolver) {\nthis.deserializer.setTypeResolver(settings.typeResolver);\n}\n        if (settings.typeHintEmitter) {\nthis.serializer.setTypeHintEmitter(settings.typeHintEmitter);\n}\n        if (settings.indent) {\nthis.indent = settings.indent;\n}\n\n        if (settings.nameResolver) {\n            this.nameResolver = settings.nameResolver;\n            this.deserializer.setNameResolver(settings.nameResolver);\n            // this.serializer.set\n        }\n\n        if (settings.knownTypes) {\n            // Type-check knownTypes elements to recognize errors in advance.\n            settings.knownTypes.forEach((knownType, i) => {\n                // tslint:disable-next-line:no-null-keyword\n                if (typeof knownType === 'undefined' || knownType === null) {\n                    logWarning(\n                        `TypedJSON.config: 'knownTypes' contains an undefined/null value (element ${i}).`,\n);\n                }\n            });\n\n            this.globalKnownTypes = settings.knownTypes;\n        }\n    }\n\n    /**\n     * Converts a JSON string to the root class type.\n     * @param object The JSON to parse and convert.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns Deserialized T or undefined if there were errors.\n     */\n    parse(object: any): T | undefined {\n        const json = parseToJSObject(object, this.rootConstructor);\n\n        const rootMetadata = JsonObjectMetadata.getFromConstructor(this.rootConstructor);\n        let result: T | undefined;\n        const knownTypes = new Map<string, Function>();\n\n        this.globalKnownTypes.filter(ktc => ktc).forEach(knownTypeCtor => {\n            knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n        });\n\n        if (rootMetadata) {\n            rootMetadata.knownTypes.forEach(knownTypeCtor => {\n                knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n            });\n        }\n\n        try {\n            result = this.deserializer.convertSingleValue(\n                json,\n                ensureTypeDescriptor(this.rootConstructor),\n                knownTypes,\n            ) as T;\n        } catch (e) {\n            this.errorHandler(e);\n        }\n\n        return result;\n    }\n\n    parseAsArray(object: any, dimensions?: 1): Array<T>;\n    parseAsArray(object: any, dimensions: 2): Array<Array<T>>;\n    parseAsArray(object: any, dimensions: 3): Array<Array<Array<T>>>;\n    parseAsArray(object: any, dimensions: 4): Array<Array<Array<Array<T>>>>;\n    parseAsArray(object: any, dimensions: 5): Array<Array<Array<Array<Array<T>>>>>;\n    parseAsArray(object: any, dimensions: number): Array<any>;\n    parseAsArray(object: any, dimensions: number = 1): Array<any> {\n        const json = parseToJSObject(object, Array);\n        return this.deserializer.convertSingleValue(\njson,\n            createArrayType(ensureTypeDescriptor(this.rootConstructor), dimensions),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    parseAsSet(object: any): Set<T> {\n        const json = parseToJSObject(object, Set);\n        return this.deserializer.convertSingleValue(\njson,\n            SetT(this.rootConstructor),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    parseAsMap<K>(object: any, keyConstructor: Serializable<K>): Map<K, T> {\n        const json = parseToJSObject(object, Map);\n        return this.deserializer.convertSingleValue(\n            json,\n            MapT(keyConstructor, this.rootConstructor),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    /**\n     * Converts an instance of the specified class type to a plain JSON object.\n     * @param object The instance to convert to a JSON string.\n     * @returns Serialized object or undefined if an error has occured.\n     */\n    toPlainJson(object: T): JsonTypes {\n        try {\n            return this.serializer.convertSingleValue(\n                object,\n                ensureTypeDescriptor(this.rootConstructor),\n            );\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    toPlainArray(object: Array<T>, dimensions?: 1): Array<Object>;\n    toPlainArray(object: Array<Array<T>>, dimensions: 2): Array<Array<Object>>;\n    toPlainArray(object: Array<Array<Array<T>>>, dimensions: 3): Array<Array<Array<Object>>>;\n    toPlainArray(object: Array<Array<Array<Array<T>>>>, dimensions: 4): Array<Array<Array<Array<Object>>>>;\n    toPlainArray(object: Array<Array<Array<Array<Array<T>>>>>, dimensions: 5): Array<Array<Array<Array<Array<Object>>>>>;\n    toPlainArray(object: Array<any>, dimensions: 1 | 2 | 3 | 4 | 5 = 1): Array<Object> | undefined {\n        try {\n            return this.serializer.convertSingleValue(object, createArrayType(ensureTypeDescriptor(this.rootConstructor), dimensions));\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    toPlainSet(object: Set<T>): Array<Object> | undefined {\n        try {\n            return this.serializer.convertSingleValue(object, SetT(this.rootConstructor));\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    toPlainMap<K>(object: Map<K, T>, keyConstructor: Serializable<K>): IndexedObject | Array<{ key: any; value: any }> | undefined {\n        try {\n            return this.serializer.convertSingleValue(object, MapT(keyConstructor, this.rootConstructor));\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Converts an instance of the specified class type to a JSON string.\n     * @param object The instance to convert to a JSON string.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns String with the serialized object or an empty string if an error has occured, but\n     *     the errorHandler did not throw.\n     */\n    stringify(object: T): string {\n        const result = this.toPlainJson(object);\n        if (result === undefined) {\n            return '';\n        }\n        return JSON.stringify(result, this.replacer, this.indent);\n    }\n\n    stringifyAsArray(object: Array<T>, dimensions?: 1): string;\n    stringifyAsArray(object: Array<Array<T>>, dimensions: 2): string;\n    stringifyAsArray(object: Array<Array<Array<T>>>, dimensions: 3): string;\n    stringifyAsArray(object: Array<Array<Array<Array<T>>>>, dimensions: 4): string;\n    stringifyAsArray(object: Array<Array<Array<Array<Array<T>>>>>, dimensions: 5): string;\n    stringifyAsArray(object: Array<any>, dimensions: any): string {\n        return JSON.stringify(this.toPlainArray(object, dimensions), this.replacer, this.indent);\n    }\n\n    stringifyAsSet(object: Set<T>): string {\n        return JSON.stringify(this.toPlainSet(object), this.replacer, this.indent);\n    }\n\n    stringifyAsMap<K>(object: Map<K, T>, keyConstructor: Serializable<K>): string {\n        return JSON.stringify(this.toPlainMap(object, keyConstructor), this.replacer, this.indent);\n    }\n\n    private _mapKnownTypes(constructors: Array<Constructor<any>>) {\n        const map = new Map<string, Constructor<any>>();\n\n        constructors.filter(ctor => ctor).forEach(ctor => map.set(this.nameResolver(ctor), ctor));\n\n        return map;\n    }\n}\n","import {JsonObjectMetadata, TypeHintEmitter, TypeResolver} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {Serializable} from './types';\n\nexport type InitializerCallback<T> = (sourceObject: T, rawSourceObject: T) => T;\n\nexport interface IJsonObjectOptionsBase extends OptionsBase {\n    /**\n     * An array of known types to recognize when encountering type-hints.\n     */\n    knownTypes?: Array<Function>;\n\n    /**\n     * A function that will emit a type hint on the resulting JSON. It will override the global typeEmitter.\n     */\n    typeHintEmitter?: TypeHintEmitter;\n\n    /**\n     * A function that given a source object will resolve the type that should be instantiated.\n     * It will override the global type resolver.\n     */\n    typeResolver?: TypeResolver;\n\n    /**\n     * The name of a static or instance method to call when deserialization\n     * of the object is completed.\n     */\n    onDeserialized?: string;\n\n    /**\n     * The name of a static or instance method to call before the serialization\n     * of the typed object is started.\n     */\n    beforeSerialization?: string;\n\n    /**\n     * The name used to differentiate between different polymorphic types.\n     */\n    name?: string;\n}\n\nexport interface IJsonObjectOptionsWithInitializer<T> extends IJsonObjectOptionsBase {\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer: InitializerCallback<T>;\n}\n\nexport interface IJsonObjectOptions<T> extends IJsonObjectOptionsBase {\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer?: InitializerCallback<T>;\n}\n\n/**\n * Marks that a class with a parameterized constructor is serializable using TypedJSON, with additional\n * settings. The 'initializer' setting must be specified.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(options?: IJsonObjectOptionsWithInitializer<T>): (target: Serializable<T>) => void;\n\n/**\n * Marks that a class is serializable using TypedJSON, with additional settings.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(options?: IJsonObjectOptions<T>): (target: Serializable<T>) => void;\n\n/**\n * Marks that a class with a parameterless constructor is serializable using TypedJSON.\n */\nexport function jsonObject<T>(target: Serializable<T>): void;\n\nexport function jsonObject<T extends Object>(optionsOrTarget?: IJsonObjectOptions<T> | Serializable<T>): ((target: Serializable<T>) => void) | void {\n    let options: IJsonObjectOptions<T>;\n\n    if (typeof optionsOrTarget === 'function') {\n        // jsonObject is being used as a decorator, directly.\n        options = {};\n    } else {\n        // jsonObject is being used as a decorator factory.\n        options = optionsOrTarget || {};\n    }\n\n    function decorator(\n        target: Serializable<T>,\n    ): void {\n        // Create or obtain JsonObjectMetadata object.\n        const objectMetadata = JsonObjectMetadata.ensurePresentInPrototype(target.prototype);\n\n        // Fill JsonObjectMetadata.\n        objectMetadata.isExplicitlyMarked = true;\n        objectMetadata.onDeserializedMethodName = options.onDeserialized;\n        objectMetadata.beforeSerializationMethodName = options.beforeSerialization;\n\n        if (options.typeResolver) {\n            objectMetadata.typeResolver = options.typeResolver;\n        }\n        if (options.typeHintEmitter) {\n            objectMetadata.typeHintEmitter = options.typeHintEmitter;\n        }\n\n        // T extend Object so it is fine\n        objectMetadata.initializerCallback = options.initializer as any;\n        if (options.name) {\n            objectMetadata.name = options.name;\n        }\n        const optionsBase = extractOptionBase(options);\n        if (optionsBase) {\n            objectMetadata.options = optionsBase;\n        }\n\n        if (options.knownTypes) {\n            options.knownTypes\n                .filter(knownType => Boolean(knownType))\n                .forEach(knownType => objectMetadata.knownTypes.add(knownType));\n        }\n    }\n\n    if (typeof optionsOrTarget === 'function') {\n        // jsonObject is being used as a decorator, directly.\n        decorator(optionsOrTarget);\n    } else {\n        // jsonObject is being used as a decorator factory.\n        return decorator;\n    }\n}\n\nfunction isSubClass<T>(target: Serializable<T>) {\n    return;\n}\n","import {\n    isReflectMetadataSupported, isSubtypeOf, isValueDefined, logError, logWarning, MISSING_REFLECT_CONF_MSG, nameof,\n} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ensureTypeDescriptor,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from './type-descriptor';\nimport {IndexedObject} from './types';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMemberOptions extends OptionsBase {\n    /**\n     * Sets the constructor of the property.\n     * Optional with ReflectDecorators.\n     */\n    constructor?: Function | TypeDescriptor;\n\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted if the property is uninitialized/undefined. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name. */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property is part of the object when serializing, with additional options.\n * Omitting the 'constructor' option requires ReflectDecorators and that the property type is always explicitly\n * declared.\n * @param options Additional options.\n */\nexport function jsonMember(options: IJsonMemberOptions): PropertyDecorator;\n\n/**\n * Specifies that a property is part of the object when serializing.\n * This call signature requires ReflectDecorators and that the property type is always explicitly declared.\n */\nexport function jsonMember<T extends Function>(prototype: IndexedObject, propertyKey: string | symbol): void;\n\nexport function jsonMember<T extends Function>(\n    optionsOrPrototype?: IJsonMemberOptions | IndexedObject,\n    propKey?: string | symbol,\n): PropertyDecorator | void {\n    if (propKey && (typeof propKey === 'string' || typeof propKey === 'symbol')) {\n        const prototype = optionsOrPrototype as IndexedObject;\n        // For error messages.\n        const decoratorName = `@jsonMember on ${nameof(prototype.constructor)}.${String(propKey)}`;\n\n        // jsonMember used directly, no additional information directly available besides target and propKey.\n        // Obtain property constructor through ReflectDecorators.\n        if (isReflectMetadataSupported) {\n            const reflectPropCtor = Reflect.getMetadata('design:type', prototype, propKey) as Function;\n\n            if (!reflectPropCtor) {\n                logError(`${decoratorName}: could not resolve detected property constructor at runtime. ${MISSING_REFLECT_CONF_MSG}`);\n                return;\n            }\n\n            const typeDescriptor = ensureTypeDescriptor(reflectPropCtor);\n            if (isSpecialPropertyType(decoratorName, typeDescriptor)) {\n                return;\n            }\n\n            injectMetadataInformation(prototype, propKey, {\n                type: typeDescriptor,\n                key: propKey.toString(),\n                name: propKey.toString(),\n            });\n        } else {\n            logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is specified.`);\n            return;\n        }\n    } else {\n        // jsonMember used as a decorator factory.\n        return (target: Object, _propKey: string | symbol) => {\n            const options: IJsonMemberOptions = optionsOrPrototype as IJsonMemberOptions || {};\n            let typeDescriptor: TypeDescriptor | undefined;\n            const decoratorName = `@jsonMember on ${nameof(target.constructor)}.${String(_propKey)}`; // For error messages.\n\n            if (options.hasOwnProperty('constructor')) {\n                if (!isValueDefined(options.constructor)) {\n                    logError(`${decoratorName}: cannot resolve specified property constructor at runtime.`);\n                    return;\n                }\n\n                // Property constructor has been specified. Use ReflectDecorators (if available) to check whether that constructor is correct. Warn if not.\n                typeDescriptor = ensureTypeDescriptor(options.constructor);\n                if (isReflectMetadataSupported && !isSubtypeOf(typeDescriptor.ctor, Reflect.getMetadata('design:type', target, _propKey))) {\n                    logWarning(`${decoratorName}: detected property type does not match 'constructor' option.`);\n                }\n            } else {\n                // Use ReflectDecorators to obtain property constructor.\n                if (isReflectMetadataSupported) {\n                    const reflectCtor = Reflect.getMetadata('design:type', target, _propKey) as Function;\n\n                    if (!reflectCtor) {\n                        logError(`${decoratorName}: cannot resolve detected property constructor at runtime.`);\n                        return;\n                    }\n                    typeDescriptor = ensureTypeDescriptor(reflectCtor);\n                } else if (!options.deserializer) {\n                    logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is specified.`);\n                    return;\n                }\n            }\n\n            if (typeDescriptor && isSpecialPropertyType(decoratorName, typeDescriptor)) {\n                return;\n            }\n            injectMetadataInformation(target, _propKey, {\n                type: typeDescriptor,\n                emitDefaultValue: options.emitDefaultValue,\n                isRequired: options.isRequired,\n                options: extractOptionBase(options),\n                key: _propKey.toString(),\n                name: options.name || _propKey.toString(),\n                deserializer: options.deserializer,\n                serializer: options.serializer,\n            });\n        };\n    }\n}\n\nfunction isSpecialPropertyType(decoratorName: string, typeDescriptor: TypeDescriptor) {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor) && typeDescriptor.ctor === Array) {\n        logError(`${decoratorName}: property is an Array. Use the jsonArrayMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (!(typeDescriptor instanceof SetTypeDescriptor) && typeDescriptor.ctor === Set) {\n        logError(`${decoratorName}: property is a Set. Use the jsonSetMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (!(typeDescriptor instanceof MapTypeDescriptor) && typeDescriptor.ctor === Map) {\n        logError(`${decoratorName}: property is a Map. Use the jsonMapMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    return false;\n}\n","import {isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {isTypelike, SetT} from './type-descriptor';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonSetMemberOptions extends OptionsBase {\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Set<T>.\n * @param elementConstructor Constructor of set elements (e.g. 'Number' for Set<number> or 'Date' for Set<Date>).\n * @param options Additional options.\n */\nexport function jsonSetMember(elementConstructor: Function, options: IJsonSetMemberOptions = {}) {\n    return (target: Object, propKey: string | symbol) => {\n        const decoratorName = `@jsonSetMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (!isTypelike(elementConstructor)) {\n            logError(`${decoratorName}: could not resolve constructor of set elements at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonSetMember' has been used on a set. Warn if not.\n        if (isReflectMetadataSupported && Reflect.getMetadata('design:type', target, propKey) !== Set) {\n            logError(`${decoratorName}: property is not a Set. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: SetT(elementConstructor),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import {isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {isTypelike, MapOptions, MapT, TypeDescriptor} from './type-descriptor';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMapMemberOptions extends OptionsBase, Partial<MapOptions> {\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Map<K, V>.\n * @param keyConstructor Constructor of map keys (e.g. 'Number' for 'Map<number, Date>').\n * @param valueConstructor Constructor of map values (e.g. 'Date' for 'Map<number, Date>').\n * @param options Additional options.\n */\nexport function jsonMapMember(\n    keyConstructor: Function | TypeDescriptor,\n    valueConstructor: Function | TypeDescriptor,\n    options: IJsonMapMemberOptions = {},\n) {\n    return (target: Object, propKey: string | symbol) => {\n        const decoratorName = `@jsonMapMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (!isTypelike(keyConstructor)) {\n            logError(`${decoratorName}: could not resolve constructor of map keys at runtime.`);\n            return;\n        }\n\n        if (!isTypelike(valueConstructor)) {\n            logError(`${decoratorName}: could not resolve constructor of map values at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonMapMember' has been used on a map. Warn if not.\n        if (isReflectMetadataSupported && Reflect.getMetadata('design:type', target, propKey) !== Map) {\n            logError(`${decoratorName}: property is not a Map. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: MapT(keyConstructor, valueConstructor, {shape: options.shape}),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import {TypedJSON} from '../parser';\n\n/**\n * Options for the @toJson decorator.\n */\nexport interface IToJsonOptions {\n    /**\n     * When set to true it will overwrite any toJSON already existing on the prototype.\n     */\n    overwrite?: boolean;\n}\n\n/**\n * Decorator that will generate toJSON function on the class prototype that allows\n * JSON.stringify to be used instead of TypedJSON.stringify. Under the hood it will\n * simply delegate to TypedJSON.\n * By default it will throw if the prototype already has a toJSON function defined.\n * @param target the class which prototype should be modified.\n */\nexport function toJson<T extends Object>(target: Function): void;\n/**\n * Decorator factory that accepts the options interface.\n * @param options for configuring the toJSON creation.\n */\nexport function toJson<T extends Object>(options: IToJsonOptions): ((target: Function) => void);\nexport function toJson<T extends Object>(optionsOrTarget: IToJsonOptions | Function): ((target: Function) => void) | void {\n    if (typeof optionsOrTarget === 'function') {\n        // used directly\n        toJsonDecorator(optionsOrTarget, {});\n        return;\n    }\n    // used as a factory\n    return (target: Function) => {\n        toJsonDecorator(target, optionsOrTarget);\n    };\n}\n\nfunction toJsonDecorator<T extends Object>(target: Function, options: IToJsonOptions): void {\n    if (!options.overwrite && target.prototype.toJSON) {\n        throw new Error(`${target.name} already has toJSON defined!`);\n    }\n    target.prototype.toJSON = function () {\n        return TypedJSON.toPlainJson(this, Object.getPrototypeOf(this).constructor);\n    };\n}\n","export {TypedJSON, ITypedJSONSettings, JsonTypes, defaultTypeResolver, defaultTypeEmitter} from './parser';\nexport {TypeResolver, TypeHintEmitter, JsonObjectMetadata} from './typedjson/metadata';\nexport {jsonObject} from './typedjson/json-object';\nexport {jsonMember} from './typedjson/json-member';\nexport {jsonArrayMember} from './typedjson/json-array-member';\nexport {jsonSetMember} from './typedjson/json-set-member';\nexport {jsonMapMember} from './typedjson/json-map-member';\nexport {toJson} from './typedjson/to-json';\nexport {ArrayT, SetT, MapT} from './typedjson/type-descriptor';\n"],"sourceRoot":""}
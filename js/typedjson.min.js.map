{"version":3,"sources":["webpack://typedjson/webpack/universalModuleDefinition","webpack://typedjson/webpack/bootstrap","webpack://typedjson/./src/typedjson/helpers.ts","webpack://typedjson/./src/typedjson/metadata.ts","webpack://typedjson/./src/typedjson/options-base.ts","webpack://typedjson/./src/typedjson/type-descriptor.ts","webpack://typedjson/./src/typedjson/serializer.ts","webpack://typedjson/./src/typedjson/deserializer.ts","webpack://typedjson/./src/typedjson/json-array-member.ts","webpack://typedjson/./src/parser.ts","webpack://typedjson/./src/typedjson/json-object.ts","webpack://typedjson/./src/typedjson/json-member.ts","webpack://typedjson/./src/typedjson/json-set-member.ts","webpack://typedjson/./src/typedjson/json-map-member.ts","webpack://typedjson/./src/typedjson/to-json.ts","webpack://typedjson/./src/typedjson.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","m","METADATA_FIELD_KEY","MISSING_REFLECT_CONF_MSG","isDirectlySerializableNativeType","type","Date","Number","String","Boolean","indexOf","isTypeTypedArray","Float32Array","Float64Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","parseToJSObject","json","expectedType","jsonStr","expectsTypesSerializedAsStrings","ArrayBuffer","DataView","hasQuotes","length","isInteger","test","trim","JSON","parse","isSubtypeOf","A","B","prototype","logError","message","console","error","optionalParams","log","logWarning","warn","isValueDefined","value","isInstanceOf","constructor","isReflectMetadataSupported","Reflect","getMetadata","nameof","fn","name","getJsonObjectName","ctor","metadata","JsonObjectMetadata","getFromConstructor","classType","hasOwnProperty","isExplicitlyMarked","doesHandleWithoutAnnotation","primitiveMeta","getKnownTypeNameFromType","dataMembers","Map","knownTypes","Set","isHandledWithoutAnnotation","injectMetadataInformation","propKey","objectMetadata","decoratorName","deserializer","parentMetadata","forEach","_metadata","_propKey","set","Object","defineProperty","enumerable","configurable","writable","getTypes","add","keys","key","undefined","kAllOptions","extractOptionBase","from","options","filter","reduce","obj","getOptionValue","getDefaultOptionOf","mergeOptions","existing","moreSpecific","assign","TypeDescriptor","GenericTypeDescriptor","concat","elementType","Array","ArrayT","ArrayTypeDescriptor","ensureTypeDescriptor","SetT","SetTypeDescriptor","keyType","valueType","getCompleteOptions","shape","MapT","MapTypeDescriptor","isTypelike","ConcreteTypeDescriptor","defaultTypeEmitter","targetObject","sourceObject","expectedSourceType","sourceTypeMetadata","__type","setTypeHintEmitter","typeEmitterCallback","TypeError","_typeHintEmitter","setErrorHandler","errorHandlerCallback","_errorHandler","convertSingleValue","typeDescriptor","memberName","memberOptions","retrievePreserveNull","convertAsArrayBuffer","convertAsDataView","convertAsArray","convertAsSet","convertAsMap","convertAsTypedArray","convertAsObject","expectedName","actualName","beforeSerializationMethodName","objMemberMetadata","serialized","objMemberOptions","serializer","element","i","expectedTypeName","actualTypeName","map","resultArray","resultElement","push","resultShape","result","preserveNull","resultKeyValuePairObj","keyDefined","valueDefined","buffer","charCode","fromCharCode","join","dataView","defaultTypeResolver","get","setNameResolver","nameResolverCallback","_nameResolver","setTypeResolver","typeResolverCallback","_typeResolver","objectName","expectedSelfType","sourceObjectMetadata","knownTypeConstructors","_mergeKnownTypes","_createKnownTypesMap","typeFromTypeHint","revivedValue","objMemberValue","objMemberDebugName","isRequired","initializerCallback","e","_instantiateType","onDeserializedMethodName","sourceKey","expectedTypeIsConcrete","srcTypeNameForDebug","_makeTypeErrorMessage","_throwTypeMismatchError","_convertAsFloatArray","_convertAsUintArray","_stringToArrayBuffer","_stringToDataView","isArray","isExpectedMapShape","resultSet","expectedShape","resultMap","resultKey","arrayType","every","elem","isNaN","targetType","actualSourceType","actualType","knownTypeMaps","knowTypes","knownTypeMeta","str","buf","bufView","strLen","charCodeAt","source","jsonArrayMember","elementConstructor","target","dimensions","createArrayType","emitDefaultValue","toString","object","rootType","settings","TypedJSON","parseAsArray","parseAsSet","parseAsMap","toPlainJson","toPlainArray","toPlainSet","toPlainMap","keyCtor","valueCtor","stringify","stringifyAsArray","stringifyAsSet","stringifyAsMap","setGlobalConfig","config","_globalConfig","errorHandler","replacer","typeResolver","typeHintEmitter","indent","nameResolver","knownType","globalKnownTypes","rootConstructor","rootMetadata","ktc","knownTypeCtor","_mapKnownTypes","keyConstructor","constructors","jsonObject","optionsOrTarget","decorator","memberMetadata","onDeserialized","beforeSerialization","initializer","optionsBase","knownTypeMethodName","jsonMember","reflectCtor","isSpecialPropertyType","reflectPropCtor","jsonSetMember","jsonMapMember","valueConstructor","toJson","toJsonDecorator","overwrite","toJSON","Error","getPrototypeOf","c","d","getter","o","r","Symbol","toStringTag","t","mode","__esModule","ns","create","bind","n","property","call","p","s","moduleId","l","modules"],"mappings":"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","file":"typedjson.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"typedjson\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"typedjson\"] = factory();\n\telse\n\t\troot[\"typedjson\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","declare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport const METADATA_FIELD_KEY = \"__typedJsonJsonObjectMetadataInformation__\";\n\nexport const MISSING_REFLECT_CONF_MSG = 'Are you sure, that you have both \"experimentalDecorators\"' +\n    ' and \"emitDecoratorMetadata\" in your tsconfig.json?';\n\nexport function getDefaultValue<T>(type: { new (): T }): T|undefined\n{\n    switch (type as any)\n    {\n        case Number:\n            return 0 as any;\n\n        case String:\n            return \"\" as any;\n\n        case Boolean:\n            return false as any;\n\n        case Array:\n            return [] as any;\n\n        default:\n            return undefined;\n    }\n}\n\n/**\n * Determines whether the specified type is a type that can be passed on \"as-is\" into `JSON.stringify`.\n * Values of these types don't need special conversion.\n * @param type The constructor of the type (wrapper constructor for primitive types, e.g. `Number` for `number`).\n */\nexport function isDirectlySerializableNativeType(type: Function): boolean\n{\n    return !!(~[Date, Number, String, Boolean].indexOf(type as any));\n}\n\nexport function isDirectlyDeserializableNativeType(type: Function): boolean\n{\n    return !!(~[Number, String, Boolean].indexOf(type as any));\n}\n\nexport function isTypeTypedArray(type: Function): boolean\n{\n    return !!(~[Float32Array, Float64Array, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array]\n        .indexOf(type as any));\n}\n\nexport function isPrimitiveValue(obj: any): boolean\n{\n    switch (typeof obj)\n    {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n            return true;\n        default:\n            return (obj instanceof String || obj instanceof Number || obj instanceof Boolean);\n    }\n}\n\nexport function isObject(value: any): value is Object\n{\n    return typeof value === \"object\";\n}\n\nfunction shouldOmitParseString(jsonStr: string, expectedType: Function): boolean {\n    const expectsTypesSerializedAsStrings = expectedType === String\n        || expectedType === ArrayBuffer\n        || expectedType === DataView;\n\n    const hasQuotes = jsonStr.length >= 2 && jsonStr[0] === '\"' && jsonStr[jsonStr.length-1] === '\"';\n    const isInteger = /^\\d+$/.test(jsonStr.trim());\n\n    return (expectsTypesSerializedAsStrings && !hasQuotes) || ((!hasQuotes && !isInteger) && expectedType === Date);\n}\n\nexport function parseToJSObject(json: any, expectedType: Function): Object {\n    if (typeof json !== 'string' ||Â shouldOmitParseString(json, expectedType))\n    {\n      return json;\n    }\n    return JSON.parse(json);\n}\n\n/**\n * Determines if 'A' is a sub-type of 'B' (or if 'A' equals 'B').\n * @param A The supposed derived type.\n * @param B The supposed base type.\n */\nexport function isSubtypeOf(A: Function, B: Function)\n{\n    return A === B || A.prototype instanceof B;\n}\n\nexport function logError(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.error === \"function\")\n    {\n        console.error(message, ...optionalParams);\n    }\n    else if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log(`ERROR: ${message}`, ...optionalParams);\n    }\n}\n\nexport function logMessage(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log(message, ...optionalParams);\n    }\n}\n\nexport function logWarning(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.warn === \"function\")\n    {\n        console.warn(message, ...optionalParams);\n    }\n    else if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log(`WARNING: ${message}`, ...optionalParams);\n    }\n}\n\n/**\n * Checks if the value is considered defined (not undefined and not null).\n * @param value\n */\nexport function isValueDefined<T>(value: T): value is Exclude<T, undefined | null>\n{\n    return !(typeof value === \"undefined\" || value === null);\n}\n\nexport function isInstanceOf<T>(value: any, constructor: Function): boolean\n{\n    if (typeof value === \"number\")\n    {\n        return (constructor === Number);\n    }\n    else if (typeof value === \"string\")\n    {\n        return (constructor === String);\n    }\n    else if (typeof value === \"boolean\")\n    {\n        return (constructor === Boolean);\n    }\n    else if (isObject(value))\n    {\n        return (value instanceof constructor);\n    }\n\n    return false;\n}\n\nexport const isReflectMetadataSupported =\n    (typeof Reflect === \"object\" && typeof Reflect.getMetadata === \"function\");\n\n/**\n * Gets the name of a function.\n * @param fn The function whose name to get.\n */\nexport function nameof(fn: Function & { name?: string })\n{\n    if (typeof fn.name === \"string\")\n    {\n        return fn.name;\n    }\n    return \"undefined\";\n}\n","import { nameof, logError, METADATA_FIELD_KEY, isDirectlySerializableNativeType, isTypeTypedArray } from \"./helpers\";\nimport { IndexedObject } from \"./types\";\nimport { OptionsBase } from \"./options-base\";\nimport { TypeDescriptor } from \"./type-descriptor\";\n\nexport interface JsonMemberMetadata\n{\n    /** If set, a default value will be emitted for uninitialized members. */\n    emitDefaultValue?: boolean;\n\n    /** Member name as it appears in the serialized JSON. */\n    name: string;\n\n    /** Property or field key of the json member. */\n    key: string;\n\n    /** Constuctor (type) reference of the member. */\n    type?: TypeDescriptor;\n\n    /** If set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    options?: OptionsBase;\n\n    /** Custom deserializer to use. */\n    deserializer?: (json: any) => any;\n\n    /** Custom serializer to use. */\n    serializer?: (value: any) => any;\n}\n\nexport class JsonObjectMetadata\n{\n    //#region Static\n    /**\n     * Gets the name of a class as it appears in a serialized JSON string.\n     * @param ctor The constructor of a class (with or without jsonObject).\n     */\n    public static getJsonObjectName(ctor: Function): string\n    {\n        const metadata = JsonObjectMetadata.getFromConstructor(ctor);\n        return metadata ? nameof(metadata.classType) : nameof(ctor);\n    }\n\n    /**\n     * Gets jsonObject metadata information from a class.\n     * @param ctor The constructor class.\n     */\n    public static getFromConstructor(ctor: Function): JsonObjectMetadata|undefined\n    {\n        const prototype = ctor.prototype;\n        if (!prototype)\n        {\n            return;\n        }\n\n        let metadata: JsonObjectMetadata|undefined;\n        if (prototype.hasOwnProperty(METADATA_FIELD_KEY))\n        {\n            // The class prototype contains own jsonObject metadata\n            metadata = prototype[METADATA_FIELD_KEY];\n        }\n\n        // Ignore implicitly added jsonObject (through jsonMember)\n        if (metadata && metadata.isExplicitlyMarked)\n        {\n            return metadata;\n        }\n\n        // In the end maybe it is something which we can handle directly\n        if (JsonObjectMetadata.doesHandleWithoutAnnotation(ctor))\n        {\n            const primitiveMeta = new JsonObjectMetadata(ctor);\n            primitiveMeta.isExplicitlyMarked = true;\n            // we do not store the metadata here to not modify builtin prototype\n            return primitiveMeta;\n        }\n    }\n\n    /**\n     * Gets the known type name of a jsonObject class for type hint.\n     * @param constructor The constructor class.\n     */\n    public static getKnownTypeNameFromType(constructor: Function): string\n    {\n        const metadata = JsonObjectMetadata.getFromConstructor(constructor);\n        return metadata ? nameof(metadata.classType) : nameof(constructor);\n    }\n\n    private static doesHandleWithoutAnnotation(ctor: Function): boolean\n    {\n        return isDirectlySerializableNativeType(ctor) || isTypeTypedArray(ctor)\n            || ctor === DataView || ctor === ArrayBuffer;\n    }\n    //#endregion\n\n    constructor(\n        classType: Function,\n    ) {\n        this.classType = classType;\n    }\n\n    public dataMembers: Map<string, JsonMemberMetadata> = new Map<string, JsonMemberMetadata>();\n\n    public knownTypes: Set<Function> = new Set<Function>();\n\n    public knownTypeMethodName?: string;\n\n    /** Gets or sets the constructor function for the jsonObject. */\n    public classType: Function;\n\n    /**\n     * Indicates whether this class was explicitly annotated with @jsonObject\n     * or implicitly by @jsonMember\n     */\n    public isExplicitlyMarked: boolean = false;\n\n    /**\n     * Indicates whether this type is handled without annotation. This is usually\n     * used for the builtin types (except for Maps, Sets, and normal Arrays).\n     */\n    public isHandledWithoutAnnotation: boolean = false;\n\n    /** Name used to encode polymorphic type */\n    public name?: string;\n\n    public options?: OptionsBase;\n\n    public onDeserializedMethodName?: string;\n\n    public beforeSerializationMethodName?: string;\n\n    public initializerCallback?: (sourceObject: Object, rawSourceObject: Object) => Object;\n}\n\nexport function injectMetadataInformation(constructor: IndexedObject, propKey: string | symbol, metadata: JsonMemberMetadata)\n{\n    const decoratorName = `@jsonMember on ${nameof(constructor.constructor)}.${String(propKey)}`; // For error messages.\n    let objectMetadata: JsonObjectMetadata;\n\n    // When a property decorator is applied to a static member, 'constructor' is a constructor function.\n    // See: https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md#property-decorators\n    // ... and static members are not supported here, so abort.\n    if (typeof constructor === \"function\")\n    {\n        logError(`${decoratorName}: cannot use a static property.`);\n        return;\n    }\n\n    // Methods cannot be serialized.\n    // @ts-ignore symbol indexing is not supported by ts\n    if (typeof constructor[propKey] === \"function\")\n    {\n        logError(`${decoratorName}: cannot use a method property.`);\n        return;\n    }\n\n    if (!metadata || (!metadata.type && !metadata.deserializer))\n    {\n        logError(`${decoratorName}: JsonMemberMetadata has unknown type.`);\n        return;\n    }\n\n    // Add jsonObject metadata to 'constructor' if not yet exists ('constructor' is the prototype).\n    // NOTE: this will not fire up custom serialization, as 'constructor' must be explicitly marked with '@jsonObject' as well.\n    if (!constructor.hasOwnProperty(METADATA_FIELD_KEY))\n    {\n        // No *own* metadata, create new.\n        objectMetadata = new JsonObjectMetadata(constructor.constructor);\n\n        // Inherit @JsonMembers from parent @jsonObject (if any).\n        const parentMetadata: JsonObjectMetadata = constructor[METADATA_FIELD_KEY];\n        if (parentMetadata) // && !constructor.hasOwnProperty(Helpers.METADATA_FIELD_KEY)\n        {\n            parentMetadata.dataMembers.forEach((_metadata, _propKey) => objectMetadata.dataMembers.set(_propKey, _metadata));\n        }\n\n        // ('constructor' is the prototype of the involved class, metadata information is added to this class prototype).\n        Object.defineProperty(constructor, METADATA_FIELD_KEY, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: objectMetadata\n        });\n    }\n    else\n    {\n        // JsonObjectMetadata already exists on 'constructor'.\n        objectMetadata = constructor[METADATA_FIELD_KEY];\n    }\n\n    if (!metadata.deserializer)\n    {\n        // @ts-ignore above is a check (!deser && !ctor)\n        metadata.type.getTypes().forEach(ctor => objectMetadata.knownTypes.add(ctor));\n    }\n\n    // clear metadata of undefined properties to save memory\n    (Object.keys(metadata) as [keyof JsonMemberMetadata])\n        .forEach((key) => (metadata[key] === undefined) && delete metadata[key]);\n    objectMetadata.dataMembers.set(metadata.name, metadata);\n}\n","/**\n * This options cascade through the annotations. Options set\n * in the more specific place override the previous option.\n * Ex. @jsonMember overrides TypedJson options.\n */\nexport interface OptionsBase {\n    /**\n     * Whether to preserve null in the JSON output. When false it\n     * will not emit nor store the property if its value is null.\n     * Default: false.\n     */\n    preserveNull?: boolean;\n}\n\nconst kAllOptions: (keyof OptionsBase)[] = [\n    'preserveNull',\n];\n\nexport function extractOptionBase(from: {[key: string]: any} & OptionsBase): OptionsBase|undefined {\n    const options = Object.keys(from)\n        .filter(key => (kAllOptions as string[]).indexOf(key) > -1)\n        .reduce((obj, key) => {\n            obj[key] = from[key];\n            return obj;\n        }, {} as any);\n    return Object.keys(options).length > 0 ? options : undefined;\n}\n\nexport function getDefaultOptionOf<K extends keyof OptionsBase>(key: K): Required<OptionsBase>[K] {\n    switch (key) {\n        case \"preserveNull\":\n            return false;\n    }\n    // never reached\n    return null as any;\n}\n\nexport function getOptionValue<K extends keyof OptionsBase>(\n    key: K,\n    options?: OptionsBase,\n): Required<OptionsBase>[K] {\n    if (options && options[key] != null) return options[key]!;\n    return getDefaultOptionOf(key);\n}\n\nexport function mergeOptions(\n    existing?: OptionsBase,\n    moreSpecific?: OptionsBase,\n): OptionsBase|undefined {\n    return !moreSpecific\n        ? existing\n        : Object.assign(\n            {},\n            existing,\n            moreSpecific,\n        );\n}\n","export abstract class TypeDescriptor {\n    protected constructor(public readonly ctor: Function) {}\n\n    getTypes(): Function[] {\n        return [this.ctor];\n    }\n}\n\nexport type Typelike = TypeDescriptor|Function;\n\nexport class ConcreteTypeDescriptor extends TypeDescriptor {\n    constructor(ctor: Function) {\n        super(ctor);\n    }\n}\n\nexport abstract class GenericTypeDescriptor extends TypeDescriptor {\n    protected constructor(ctor: Function) {\n        super(ctor);\n    }\n}\n\nexport class ArrayTypeDescriptor extends GenericTypeDescriptor {\n    constructor(public readonly elementType: TypeDescriptor) {\n        super(Array);\n    }\n\n    getTypes(): Function[] {\n        return super.getTypes().concat(this.elementType.getTypes());\n    }\n}\n\nexport function ArrayT(elementType: Typelike): ArrayTypeDescriptor {\n    return new ArrayTypeDescriptor(ensureTypeDescriptor(elementType));\n}\n\nexport class SetTypeDescriptor extends GenericTypeDescriptor {\n    constructor(public readonly elementType: TypeDescriptor) {\n        super(Set);\n    }\n\n    getTypes(): Function[] {\n        return super.getTypes().concat(this.elementType.getTypes());\n    }\n}\n\nexport function SetT(elementType: Typelike): SetTypeDescriptor {\n    return new SetTypeDescriptor(ensureTypeDescriptor(elementType));\n}\n\nexport const enum MapShape {\n    /**\n     * A map will be serialized as an array of {key: ..., value: ...} objects.\n     */\n    ARRAY,\n\n    /**\n     * A map will be serialized as a JSON object.\n     */\n    OBJECT,\n}\n\nexport interface MapOptions {\n    /**\n     * How the map should be serialized. Default is ARRAY.\n     */\n    shape: MapShape;\n}\n\nexport class MapTypeDescriptor extends GenericTypeDescriptor {\n    constructor(\n        public readonly keyType: TypeDescriptor,\n        public readonly valueType: TypeDescriptor,\n        public readonly options?: Partial<MapOptions>,\n    ) {\n        super(Map);\n    }\n\n    getTypes(): Function[] {\n        return super.getTypes().concat(this.keyType.getTypes(), this.valueType.getTypes());\n    }\n\n    getCompleteOptions(): MapOptions {\n        return {\n            shape: this.options?.shape ? this.options.shape : MapShape.ARRAY,\n        };\n    }\n}\n\nexport function MapT(keyType: Typelike, valueType: Typelike, options?: Partial<MapOptions>): MapTypeDescriptor {\n    return new MapTypeDescriptor(ensureTypeDescriptor(keyType), ensureTypeDescriptor(valueType), options);\n}\n\n// TODO support for dictionary types ie. maps that are plain objects\n// export class DictionaryTypeDescriptor extends GenericTypeDescriptor {\n//     constructor(public readonly elementType: TypeDescriptor) {\n//         super(Object);\n//     }\n//\n//     getTypes(): Function[] {\n//         return super.getTypes().concat(this.elementType.getTypes());\n//     }\n// }\n//\n// export function DictT(elementType: Typelike): DictionaryTypeDescriptor {\n//     return new DictionaryTypeDescriptor(ensureTypeDescriptor(elementType));\n// }\n\nexport function isTypelike(type: any): type is Typelike {\n    return type && (typeof type === \"function\" || type instanceof TypeDescriptor);\n}\n\nexport function ensureTypeDescriptor(type: Typelike): TypeDescriptor {\n    return type instanceof TypeDescriptor ? type : new ConcreteTypeDescriptor(type);\n}\n","import {\n    isDirectlySerializableNativeType,\n    isInstanceOf,\n    isTypeTypedArray,\n    isValueDefined,\n    logError,\n    nameof,\n} from \"./helpers\";\nimport { IndexedObject } from \"./types\";\nimport { JsonObjectMetadata } from \"./metadata\";\nimport { getOptionValue, mergeOptions, OptionsBase } from \"./options-base\";\nimport {\n    ArrayTypeDescriptor,\n    ConcreteTypeDescriptor,\n    MapShape,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from \"./type-descriptor\";\n\nexport type TypeHintEmitter\n    = (\n        targetObject: IndexedObject,\n        sourceObject: IndexedObject,\n        expectedSourceType: Function,\n        sourceTypeMetadata?: JsonObjectMetadata,\n    ) => void;\n\nfunction defaultTypeEmitter(\n    targetObject: IndexedObject,\n    sourceObject: IndexedObject,\n    expectedSourceType: Function,\n    sourceTypeMetadata?: JsonObjectMetadata,\n) {\n    // By default, we put a \"__type\" property on the output object if the actual object is not the\n    // same as the expected one, so that deserialization will know what to deserialize into (given\n    // the required known-types are defined, and the object is a valid subtype of the expected type).\n    if (sourceObject.constructor !== expectedSourceType)\n    {\n        targetObject.__type = sourceTypeMetadata && sourceTypeMetadata.name\n            ? sourceTypeMetadata.name\n            : nameof(sourceObject.constructor);\n    }\n}\n\n/**\n * Utility class, converts a typed object tree (i.e. a tree of class instances, arrays of class\n * instances, and so on) to an untyped javascript object (also called \"simple javascript object\"),\n * and emits any necessary type hints in the process (for polymorphism).\n *\n * The converted object tree is what will be given to `JSON.stringify` to convert to string as the\n * last step, the serialization is basically like:\n *\n * (1) typed object-tree -> (2) simple JS object-tree -> (3) JSON-string\n */\nexport class Serializer\n{\n    public options?: OptionsBase;\n    private _typeHintEmitter: TypeHintEmitter = defaultTypeEmitter;\n    private _errorHandler: (error: Error) => void = logError;\n\n    public setTypeHintEmitter(typeEmitterCallback: TypeHintEmitter)\n    {\n        if (typeof typeEmitterCallback !== \"function\")\n        {\n            throw new TypeError(\"'typeEmitterCallback' is not a function.\");\n        }\n\n        this._typeHintEmitter = typeEmitterCallback;\n    }\n\n    public setErrorHandler(errorHandlerCallback: (error: Error) => void)\n    {\n        if (typeof errorHandlerCallback !== \"function\")\n        {\n            throw new TypeError(\"'errorHandlerCallback' is not a function.\");\n        }\n\n        this._errorHandler = errorHandlerCallback;\n    }\n\n    /**\n     * Convert a value of any supported serializable type.\n     * The value type will be detected, and the correct serialization method will be called.\n     */\n    public convertSingleValue(\n        sourceObject: any,\n        typeDescriptor: TypeDescriptor,\n        memberName: string = \"object\",\n        memberOptions?: OptionsBase,\n    ): any {\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) return null;\n        if (!isValueDefined(sourceObject)) return;\n\n        if (!isInstanceOf(sourceObject, typeDescriptor.ctor))\n        {\n            let expectedName = nameof(typeDescriptor.ctor);\n            let actualName = nameof(sourceObject.constructor);\n\n            this._errorHandler(new TypeError(\n                `Could not serialize '${memberName}': expected '${expectedName}', got '${actualName}'.`),\n            );\n            return;\n        }\n\n        if (isDirectlySerializableNativeType(typeDescriptor.ctor))\n        {\n            return sourceObject;\n        }\n        else if (typeDescriptor.ctor === ArrayBuffer)\n        {\n            return this.convertAsArrayBuffer(sourceObject);\n        }\n        else if (typeDescriptor.ctor === DataView)\n        {\n            return this.convertAsDataView(sourceObject);\n        }\n        else if (typeDescriptor instanceof ArrayTypeDescriptor)\n        {\n            return this.convertAsArray(sourceObject, typeDescriptor, memberName, memberOptions);\n        }\n        else if (typeDescriptor instanceof SetTypeDescriptor)\n        {\n            return this.convertAsSet(sourceObject, typeDescriptor, memberName, memberOptions);\n        }\n        else if (typeDescriptor instanceof MapTypeDescriptor)\n        {\n            return this.convertAsMap(sourceObject, typeDescriptor, memberName, memberOptions);\n        }\n        else if (isTypeTypedArray(typeDescriptor.ctor))\n        {\n            return this.convertAsTypedArray(sourceObject);\n        }\n        else if (typeof sourceObject === \"object\")\n        {\n            return this.convertAsObject(sourceObject, typeDescriptor, memberName, memberOptions);\n        }\n    }\n\n    /**\n     * Performs the conversion of a typed object (usually a class instance) to a simple\n     * javascript object for serialization.\n     */\n    public convertAsObject(\n        sourceObject: IndexedObject,\n        typeDescriptor: ConcreteTypeDescriptor,\n        memberName?: string,\n        memberOptions?: OptionsBase,\n    ) {\n        let sourceTypeMetadata: JsonObjectMetadata|undefined;\n        let targetObject: IndexedObject;\n\n        if (sourceObject.constructor !== typeDescriptor.ctor && sourceObject instanceof typeDescriptor.ctor)\n        {\n            // The source object is not of the expected type, but it is a valid subtype.\n            // This is OK, and we'll proceed to gather object metadata from the subtype instead.\n            sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(sourceObject.constructor);\n        }\n        else\n        {\n            sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(typeDescriptor.ctor);\n        }\n\n        if (sourceTypeMetadata)\n        {\n\n            if (sourceTypeMetadata.beforeSerializationMethodName) {\n                // check for member first\n                if (typeof (sourceObject as any)[sourceTypeMetadata.beforeSerializationMethodName] === \"function\")\n                {\n                    (sourceObject as any)[sourceTypeMetadata.beforeSerializationMethodName]();\n                }\n                // check for static\n                else if (typeof (sourceObject.constructor as any)[sourceTypeMetadata.beforeSerializationMethodName] === \"function\")\n                {\n                    (sourceObject.constructor as any)[sourceTypeMetadata.beforeSerializationMethodName]();\n                }\n                else \n                {\n                    this._errorHandler(new TypeError(\n                        `beforeSerialization callback '${nameof(sourceTypeMetadata.classType)}.${sourceTypeMetadata.beforeSerializationMethodName}' is not a method.`\n                    ));\n                }\n            }\n\n            const sourceMeta = sourceTypeMetadata;\n            // Strong-typed serialization available.\n            // We'll serialize by members that have been marked with @jsonMember (including array/set/map members),\n            // and perform recursive conversion on each of them. The converted objects are put on the 'targetObject',\n            // which is what will be put into 'JSON.stringify' finally.\n            targetObject = {};\n\n            const classOptions = mergeOptions(this.options, sourceMeta.options);\n\n            sourceMeta.dataMembers.forEach((objMemberMetadata) =>\n            {\n                const objMemberOptions = mergeOptions(classOptions, objMemberMetadata.options);\n                let serialized;\n                if (objMemberMetadata.serializer) {\n                    serialized = objMemberMetadata.serializer(sourceObject[objMemberMetadata.key]);\n                } else if (objMemberMetadata.type) {\n                    serialized = this.convertSingleValue(\n                        sourceObject[objMemberMetadata.key],\n                        objMemberMetadata.type,\n                        `${nameof(sourceMeta.classType)}.${objMemberMetadata.key}`,\n                        objMemberOptions,\n                    );\n                } else {\n                    throw new TypeError(\n                        `Could not serialize ${objMemberMetadata.name}, there is`\n                        + ` no constructor nor serialization function to use.`,\n                    );\n                }\n\n                if (isValueDefined(serialized)\n                    || (this.retrievePreserveNull(objMemberOptions) && serialized === null)\n                ) {\n                    targetObject[objMemberMetadata.name] = serialized;\n                }\n            });\n        }\n        else\n        {\n            // Untyped serialization, \"as-is\", we'll just pass the object on.\n            // We'll clone the source object, because type hints are added to the object itself, and we don't want to modify to the original object.\n            targetObject = { ...sourceObject };\n        }\n\n        // Add type-hint.\n        this._typeHintEmitter(targetObject, sourceObject, typeDescriptor.ctor, sourceTypeMetadata);\n\n        return targetObject;\n    }\n\n    /**\n     * Performs the conversion of an array of typed objects (or primitive values) to an array of simple javascript objects (or primitive values) for\n     * serialization.\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     */\n    public convertAsArray(\n        sourceObject: any[],\n        typeDescriptor: ArrayTypeDescriptor,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): any[] {\n        if (!typeDescriptor.elementType)\n        {\n            throw new TypeError(`Could not serialize ${memberName} as Array: missing element type definition.`);\n        }\n\n        // Check the type of each element, individually.\n        // If at least one array element type is incorrect, we return undefined, which results in no\n        // value emitted during serialization. This is so that invalid element types don't unexpectedly\n        // alter the ordering of other, valid elements, and that no unexpected undefined values are in\n        // the emitted array.\n        sourceObject.forEach((element, i) =>\n        {\n            if (!(this.retrievePreserveNull(memberOptions) && element === null)\n                && !isInstanceOf(element, typeDescriptor.elementType.ctor)\n            ) {\n                const expectedTypeName = nameof(typeDescriptor.elementType.ctor);\n                const actualTypeName = element && nameof(element.constructor);\n                throw new TypeError(`Could not serialize ${memberName}[${i}]:` +\n                    ` expected '${expectedTypeName}', got '${actualTypeName}'.`);\n            }\n        });\n\n        if (memberName)\n        {\n            // Just for debugging purposes.\n            memberName += \"[]\";\n        }\n\n        return sourceObject.map(\n            element => this.convertSingleValue(\n                element, typeDescriptor.elementType, memberName, memberOptions\n            ),\n        );\n    }\n\n    /**\n     * Performs the conversion of a set of typed objects (or primitive values) into an array\n     * of simple javascript objects.\n     *\n     * @param sourceObject\n     * @param expectedElementType The constructor of the expected Set elements\n     *        (e.g. `Number` for `Set<number>`, or `MyClass` for `Set<MyClass>`).\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     * @returns\n     */\n    public convertAsSet(\n        sourceObject: Set<any>,\n        typeDescriptor: SetTypeDescriptor,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): any[] {\n        if (!typeDescriptor.elementType)\n        {\n            throw new TypeError(`Could not serialize ${memberName} as Set: missing element type definition.`);\n        }\n\n        // For debugging and error tracking.\n        if (memberName)\n        {\n            memberName += \"[]\";\n        }\n\n        let resultArray: any[] = [];\n\n        // Convert each element of the set, and put it into an output array.\n        // The output array is the one serialized, as JSON.stringify does not support Set serialization.\n        // (TODO: clarification needed)\n        sourceObject.forEach(element =>\n        {\n            const resultElement = this.convertSingleValue(element, typeDescriptor.elementType, memberName, memberOptions);\n\n            // Add to output if the source element was undefined, OR the converted element is defined.\n            // This will add intentionally undefined values to output, but not values that became undefined\n            // DURING serializing (usually because of a type-error).\n            if (!isValueDefined(element) || isValueDefined(resultElement))\n            {\n                resultArray.push(resultElement);\n            }\n        });\n\n        return resultArray;\n    }\n\n    /**\n     * Performs the conversion of a map of typed objects (or primitive values) into an array\n     * of simple javascript objects with `key` and `value` properties.\n     *\n     * @param sourceObject\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     */\n    public convertAsMap(\n        sourceObject: Map<any, any>,\n        typeDescriptor: MapTypeDescriptor,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): IndexedObject|Array<{ key: any, value: any }> {\n        if (!typeDescriptor.valueType)\n        {\n            throw new TypeError(`Could not serialize ${memberName} as Map: missing value type definition.`);\n        }\n\n        if (!typeDescriptor.keyType)\n        {\n            throw new TypeError(`Could not serialize ${memberName} as Map: missing key type definition.`);\n        }\n\n        if (memberName)\n        {\n            memberName += \"[]\";\n        }\n\n        // const resultArray: Array<{ key: any, value: any }> = [];\n        const resultShape = typeDescriptor.getCompleteOptions().shape;\n        const result = resultShape === MapShape.OBJECT ? ({} as IndexedObject) : [];\n        const preserveNull = this.retrievePreserveNull(memberOptions);\n\n        // Convert each *entry* in the map to a simple javascript object with key and value properties.\n        sourceObject.forEach((value, key) =>\n        {\n            let resultKeyValuePairObj = {\n                key: this.convertSingleValue(key, typeDescriptor.keyType, memberName, memberOptions),\n                value: this.convertSingleValue(value, typeDescriptor.valueType, memberName, memberOptions),\n            };\n\n            // We are not going to emit entries with undefined keys OR undefined values.\n            const keyDefined = isValueDefined(resultKeyValuePairObj.key);\n            const valueDefined = isValueDefined(resultKeyValuePairObj.value)\n                || (resultKeyValuePairObj.value === null && preserveNull);\n            if (keyDefined && valueDefined)\n            {\n                if (resultShape === MapShape.OBJECT) {\n                    result[resultKeyValuePairObj.key] = resultKeyValuePairObj.value;\n                } else {\n                    result.push(resultKeyValuePairObj);\n                }\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Performs the conversion of a typed javascript array to a simple untyped javascript array.\n     * This is needed because typed arrays are otherwise serialized as objects, so we'll end up\n     * with something like \"{ 0: 0, 1: 1, ... }\".\n     *\n     * @param sourceObject\n     * @returns\n     */\n    public convertAsTypedArray(sourceObject: ArrayBufferView)\n    {\n        return Array.from(sourceObject as any);\n    }\n\n    /**\n     * Performs the conversion of a raw ArrayBuffer to a string.\n     */\n    public convertAsArrayBuffer(buffer: ArrayBuffer)\n    {\n        // ArrayBuffer -> 16-bit character codes -> character array -> joined string.\n        return Array.from(new Uint16Array(buffer)).map(charCode => String.fromCharCode(charCode)).join(\"\");\n    }\n\n    /**\n     * Performs the conversion of DataView, converting its internal ArrayBuffer to a string and\n     * returning that string.\n     */\n    public convertAsDataView(dataView: DataView)\n    {\n        return this.convertAsArrayBuffer(dataView.buffer);\n    }\n\n    private retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n}\n","import { isDirectlyDeserializableNativeType, isSubtypeOf, isValueDefined, logError, nameof } from \"./helpers\";\nimport { Constructor, IndexedObject } from \"./types\";\nimport { JsonObjectMetadata } from \"./metadata\";\nimport { getOptionValue, mergeOptions, OptionsBase } from \"./options-base\";\nimport {\n    ArrayTypeDescriptor,\n    ConcreteTypeDescriptor,\n    MapShape,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from \"./type-descriptor\";\n\nexport type TypeResolver = (sourceObject: Object, knownTypes: Map<string, Function>) => Function|undefined|null;\n\nfunction defaultTypeResolver(sourceObject: any, knownTypes: Map<string, Function>): Function|undefined {\n    if (sourceObject.__type) return knownTypes.get(sourceObject.__type);\n}\n\n/**\n * Utility class, converts a simple/untyped javascript object-tree to a typed object-tree.\n * It is used after parsing a JSON-string.\n */\nexport class Deserializer<T>\n{\n    public options?: OptionsBase;\n\n    private _typeResolver: TypeResolver = defaultTypeResolver;\n    private _nameResolver?: (ctor: Function) => string;\n    private _errorHandler: (error: Error) => void = logError;\n\n    public setNameResolver(nameResolverCallback: (ctor: Function) => string)\n    {\n        this._nameResolver = nameResolverCallback;\n    }\n\n    public setTypeResolver(typeResolverCallback: TypeResolver)\n    {\n        if (typeof typeResolverCallback !== \"function\")\n        {\n            throw new TypeError(\"'typeResolverCallback' is not a function.\");\n        }\n\n        this._typeResolver = typeResolverCallback;\n    }\n\n    public setErrorHandler(errorHandlerCallback: (error: Error) => void)\n    {\n        if (typeof errorHandlerCallback !== \"function\")\n        {\n            throw new TypeError(\"'errorHandlerCallback' is not a function.\");\n        }\n\n        this._errorHandler = errorHandlerCallback;\n    }\n\n    public convertAsObject(\n        sourceObject: IndexedObject,\n        typeDescriptor: ConcreteTypeDescriptor,\n        knownTypes: Map<string, Function>,\n        objectName = \"object\",\n        memberOptions?: OptionsBase,\n    ) {\n        if (typeof sourceObject !== \"object\" || sourceObject === null)\n        {\n            this._errorHandler(new TypeError(`Cannot deserialize ${objectName}: 'sourceObject' must be a defined object.`));\n            return undefined;\n        }\n\n        let expectedSelfType = typeDescriptor.ctor;\n        let sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(expectedSelfType);\n        let knownTypeConstructors = knownTypes;\n\n        if (sourceObjectMetadata)\n        {\n            // Merge known types received from \"above\" with known types defined on the current type.\n            knownTypeConstructors = this._mergeKnownTypes(\n                knownTypeConstructors,\n                this._createKnownTypesMap(sourceObjectMetadata.knownTypes),\n            );\n        }\n\n        // Check if a type-hint is available from the source object.\n        const typeFromTypeHint = this._typeResolver(sourceObject, knownTypeConstructors);\n\n        if (typeFromTypeHint)\n        {\n            // Check if type hint is a valid subtype of the expected source type.\n            if (isSubtypeOf(typeFromTypeHint, expectedSelfType))\n            {\n                // Hell yes.\n                expectedSelfType = typeFromTypeHint;\n                sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(typeFromTypeHint);\n\n                if (sourceObjectMetadata)\n                {\n                    // Also merge new known types from subtype.\n                    knownTypeConstructors = this._mergeKnownTypes(\n                        knownTypeConstructors,\n                        this._createKnownTypesMap(sourceObjectMetadata.knownTypes),\n                    );\n                }\n            }\n        }\n\n        if (sourceObjectMetadata && sourceObjectMetadata.isExplicitlyMarked)\n        {\n            const sourceMetadata = sourceObjectMetadata;\n            // Strong-typed deserialization available, get to it.\n            // First deserialize properties into a temporary object.\n            const sourceObjectWithDeserializedProperties = {} as IndexedObject;\n\n            const classOptions = mergeOptions(this.options, sourceMetadata.options);\n\n            // Deserialize by expected properties.\n            sourceMetadata.dataMembers.forEach((objMemberMetadata, propKey) =>\n            {\n                const objMemberValue = sourceObject[propKey];\n                const objMemberDebugName = `${nameof(sourceMetadata.classType)}.${propKey}`;\n                const objMemberOptions = mergeOptions(classOptions, objMemberMetadata.options);\n\n                let revivedValue;\n                if (objMemberMetadata.deserializer)\n                {\n                    revivedValue = objMemberMetadata.deserializer(objMemberValue);\n                }\n                else if (objMemberMetadata.type)\n                {\n                    revivedValue = this.convertSingleValue(\n                        objMemberValue,\n                        objMemberMetadata.type,\n                        knownTypeConstructors,\n                        objMemberDebugName,\n                        objMemberOptions,\n                    );\n                }\n                else\n                {\n                    throw new TypeError(\n                        `Cannot deserialize ${objMemberDebugName} there is`\n                        + ` no constructor nor deserialization function to use.`,\n                    );\n                }\n\n                if (isValueDefined(revivedValue)\n                    || (this.retrievePreserveNull(objMemberOptions) && revivedValue === null)\n                ) {\n                    sourceObjectWithDeserializedProperties[objMemberMetadata.key] = revivedValue;\n                }\n                else if (objMemberMetadata.isRequired)\n                {\n                    this._errorHandler(new TypeError(`Missing required member '${objMemberDebugName}'.`));\n                }\n            });\n\n            // Next, instantiate target object.\n            let targetObject: IndexedObject;\n\n            if (typeof sourceObjectMetadata.initializerCallback === \"function\")\n            {\n                try\n                {\n                    targetObject = sourceObjectMetadata.initializerCallback(\n                        sourceObjectWithDeserializedProperties,\n                        sourceObject,\n                    );\n\n                    // Check the validity of user-defined initializer callback.\n                    if (!targetObject)\n                    {\n                        throw new TypeError(\n                            `Cannot deserialize ${objectName}:`\n                            + ` 'initializer' function returned undefined/null`\n                            + `, but '${nameof(sourceObjectMetadata.classType)}' was expected.`,\n                        );\n                    }\n                    else if (!(targetObject instanceof sourceObjectMetadata.classType))\n                    {\n                        throw new TypeError(\n                            `Cannot deserialize ${objectName}:`\n                            + `'initializer' returned '${nameof(targetObject.constructor)}'`\n                            + `, but '${nameof(sourceObjectMetadata.classType)}' was expected`\n                            + `, and '${nameof(targetObject.constructor)}' is not a subtype of`\n                            + ` '${nameof(sourceObjectMetadata.classType)}'`,\n                        );\n                    }\n                }\n                catch (e)\n                {\n                    this._errorHandler(e);\n                    return undefined;\n                }\n            }\n            else\n            {\n                targetObject = this._instantiateType(expectedSelfType);\n            }\n\n            // Finally, assign deserialized properties to target object.\n            Object.assign(targetObject, sourceObjectWithDeserializedProperties);\n\n            // Call onDeserialized method (if any).\n            if (sourceObjectMetadata.onDeserializedMethodName)\n            {\n                // check for member first\n                if (typeof (targetObject as any)[sourceObjectMetadata.onDeserializedMethodName] === \"function\")\n                {\n                    (targetObject as any)[sourceObjectMetadata.onDeserializedMethodName]();\n                }\n                // check for static\n                else if (typeof (targetObject.constructor as any)[sourceObjectMetadata.onDeserializedMethodName] === \"function\")\n                {\n                    (targetObject.constructor as any)[sourceObjectMetadata.onDeserializedMethodName]();\n                }\n                else\n                {\n                    this._errorHandler(new TypeError(\n                        `onDeserialized callback '${nameof(sourceObjectMetadata.classType)}.${sourceObjectMetadata.onDeserializedMethodName}' is not a method.`\n                    ));\n                }\n            }\n\n            return targetObject;\n        }\n        else\n        {\n            // Untyped deserialization into Object instance.\n            const targetObject = {} as IndexedObject;\n\n            Object.keys(sourceObject).forEach(sourceKey =>\n            {\n                targetObject[sourceKey] = this.convertSingleValue(\n                    sourceObject[sourceKey],\n                    new ConcreteTypeDescriptor(sourceObject[sourceKey].constructor),\n                    knownTypes,\n                    sourceKey\n                );\n            });\n\n            return targetObject;\n        }\n    }\n\n    public convertSingleValue(\n        sourceObject: any,\n        typeDescriptor: TypeDescriptor,\n        knownTypes: Map<string, Function>,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ) {\n        const expectedTypeIsConcrete = typeDescriptor instanceof ConcreteTypeDescriptor;\n        let srcTypeNameForDebug = sourceObject ? nameof(sourceObject.constructor) : \"undefined\";\n\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null)\n        {\n            return null;\n        }\n        else if (!isValueDefined(sourceObject))\n        {\n            return;\n        }\n        else if (expectedTypeIsConcrete && isDirectlyDeserializableNativeType(typeDescriptor.ctor))\n        {\n            if (sourceObject.constructor === typeDescriptor.ctor)\n            {\n                return sourceObject;\n            }\n            else\n            {\n                throw new TypeError(this._makeTypeErrorMessage(nameof(typeDescriptor.ctor), sourceObject.constructor, memberName));\n            }\n        }\n        else if (expectedTypeIsConcrete && typeDescriptor.ctor === Date)\n        {\n            // Support for Date with ISO 8601 format, or with numeric timestamp (milliseconds elapsed since the Epoch).\n            // ISO 8601 spec.: https://www.w3.org/TR/NOTE-datetime\n\n            if (typeof sourceObject === \"string\" || (typeof sourceObject === \"number\" && sourceObject > 0))\n                return new Date(sourceObject as any);\n            else if (sourceObject instanceof Date)\n                return sourceObject\n            else\n                this._throwTypeMismatchError(\"Date\", \"an ISO-8601 string\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedTypeIsConcrete && (typeDescriptor.ctor === Float32Array || typeDescriptor.ctor === Float64Array))\n        {\n            // Deserialize Float Array from number[].\n            return this._convertAsFloatArray(\n                sourceObject,\n                typeDescriptor as any,\n                srcTypeNameForDebug,\n                memberName,\n            );\n        }\n        else if (\n            expectedTypeIsConcrete && (\n                typeDescriptor.ctor === Uint8Array\n                || typeDescriptor.ctor === Uint8ClampedArray\n                || typeDescriptor.ctor === Uint16Array\n                || typeDescriptor.ctor === Uint32Array\n            )\n        ) {\n            // Deserialize Uint array from number[].\n            return this._convertAsUintArray(\n                sourceObject,\n                typeDescriptor.ctor as any,\n                srcTypeNameForDebug,\n                memberName,\n            );\n        }\n        else if (expectedTypeIsConcrete && typeDescriptor.ctor === ArrayBuffer)\n        {\n            if (typeof sourceObject === \"string\")\n                return this._stringToArrayBuffer(sourceObject);\n            else\n                this._throwTypeMismatchError(\"ArrayBuffer\", \"a string source\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedTypeIsConcrete && typeDescriptor.ctor === DataView)\n        {\n            if (typeof sourceObject === \"string\")\n                return this._stringToDataView(sourceObject);\n            else\n                this._throwTypeMismatchError(\"DataView\", \"a string source\", srcTypeNameForDebug, memberName);\n        }\n        else if (typeDescriptor instanceof ArrayTypeDescriptor)\n        {\n            if (Array.isArray(sourceObject))\n                return this.convertAsArray(sourceObject, typeDescriptor, knownTypes, memberName, memberOptions);\n            else\n                throw new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName));\n        }\n        else if (typeDescriptor instanceof SetTypeDescriptor)\n        {\n            if (Array.isArray(sourceObject))\n                return this.convertAsSet(sourceObject, typeDescriptor, knownTypes, memberName, memberOptions);\n            else\n                this._throwTypeMismatchError(\"Set\", \"Array\", srcTypeNameForDebug, memberName);\n        }\n        else if (typeDescriptor instanceof MapTypeDescriptor)\n        {\n            if (this.isExpectedMapShape(sourceObject, typeDescriptor.getCompleteOptions().shape))\n            {\n                return this.convertAsMap(sourceObject, typeDescriptor, knownTypes, memberName, memberOptions);\n            }\n            else\n            {\n                this._throwTypeMismatchError(\"Map\", \"a source array of key-value-pair objects\", srcTypeNameForDebug, memberName);\n            }\n        }\n        else if (sourceObject && typeof sourceObject === \"object\")\n        {\n            return this.convertAsObject(sourceObject, typeDescriptor, knownTypes, memberName, memberOptions);\n        }\n    }\n\n    public convertAsArray(\n        sourceObject: any,\n        typeDescriptor: ArrayTypeDescriptor,\n        knownTypes: Map<string, Function>,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): any[] {\n        if (!(Array.isArray(sourceObject)))\n        {\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n            return [];\n        }\n\n        if (!typeDescriptor.elementType)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Array: missing constructor reference of Array elements.`));\n            return [];\n        }\n\n        return sourceObject.map(element => {\n            // If an array element fails to deserialize, substitute with undefined. This is so that the original ordering is not interrupted by faulty\n            // entries, as an Array is ordered.\n            try\n            {\n                return this.convertSingleValue(\n                    element,\n                    typeDescriptor.elementType,\n                    knownTypes,\n                    `${memberName}[]`,\n                    memberOptions,\n                );\n            }\n            catch (e)\n            {\n                this._errorHandler(e);\n\n                // Keep filling the array here with undefined to keep original ordering.\n                // Note: this is just aesthetics, not returning anything produces the same result.\n                return undefined;\n            }\n        });\n    }\n\n    public convertAsSet(\n        sourceObject: any,\n        typeDescriptor: SetTypeDescriptor,\n        knownTypes: Map<string, Function>,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): Set<any> {\n        if (!(Array.isArray(sourceObject)))\n        {\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n            return new Set<any>();\n        }\n\n        if (!typeDescriptor.elementType)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Set: missing constructor reference of Set elements.`));\n            return new Set<any>();\n        }\n\n        const resultSet = new Set<any>();\n\n        sourceObject.forEach((element, i) => {\n            try\n            {\n                resultSet.add(this.convertSingleValue(\n                    element,\n                    typeDescriptor.elementType,\n                    knownTypes,\n                    `${memberName}[${i}]`,\n                    memberOptions,\n                ));\n            }\n            catch (e)\n            {\n                // Faulty entries are skipped, because a Set is not ordered, and skipping an entry\n                // does not affect others.\n                this._errorHandler(e);\n            }\n        });\n\n        return resultSet;\n    }\n\n    public convertAsMap(\n        sourceObject: any,\n        typeDescriptor: MapTypeDescriptor,\n        knownTypes: Map<string, Function>,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): Map<any, any> {\n        const expectedShape = typeDescriptor.getCompleteOptions().shape;\n        if (!this.isExpectedMapShape(sourceObject, expectedShape))\n        {\n            const expectedType = expectedShape === MapShape.ARRAY ? Array : Object;\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(expectedType, sourceObject.constructor, memberName)));\n            return new Map<any, any>();\n        }\n\n        if (!typeDescriptor.keyType)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Map: missing key constructor.`));\n            return new Map<any, any>();\n        }\n\n        if (!typeDescriptor.valueType)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Map: missing value constructor.`));\n            return new Map<any, any>();\n        }\n\n        const resultMap = new Map<any, any>();\n\n        if (expectedShape === MapShape.OBJECT)\n        {\n            Object.keys(sourceObject).forEach(key => {\n                try\n                {\n                    const resultKey = this.convertSingleValue(\n                        key,\n                        typeDescriptor.keyType,\n                        knownTypes,\n                        memberName,\n                        memberOptions,\n                    );\n                    if (isValueDefined(resultKey))\n                    {\n                        resultMap.set(\n                            resultKey,\n                            this.convertSingleValue(\n                                sourceObject[key],\n                                typeDescriptor.valueType,\n                                knownTypes,\n                                `${memberName}[${resultKey}]`,\n                                memberOptions,\n                            ),\n                        );\n                    }\n                }\n                catch (e)\n                {\n                    // Faulty entries are skipped, because a Map is not ordered,\n                    // and skipping an entry does not affect others.\n                    this._errorHandler(e);\n                }\n            })\n        }\n        else\n        {\n            sourceObject.forEach((element: any) => {\n                try\n                {\n                    const key = this.convertSingleValue(\n                        element.key,\n                        typeDescriptor.keyType,\n                        knownTypes,\n                        memberName,\n                        memberOptions,\n                    );\n\n                    // Undefined/null keys not supported, skip if so.\n                    if (isValueDefined(key))\n                    {\n                        resultMap.set(\n                            key,\n                            this.convertSingleValue(\n                                element.value,\n                                typeDescriptor.valueType,\n                                knownTypes,\n                                `${memberName}[${key}]`,\n                                memberOptions,\n                            ),\n                        );\n                    }\n                }\n                catch (e)\n                {\n                    // Faulty entries are skipped, because a Map is not ordered,\n                    // and skipping an entry does not affect others.\n                    this._errorHandler(e);\n                }\n            });\n        }\n\n        return resultMap;\n    }\n\n    private _convertAsFloatArray<T extends Float32Array | Float64Array>(\n        sourceObject: any,\n        arrayType: Constructor<T>,\n        srcTypeNameForDebug: string,\n        memberName: string,\n    ): T {\n        if (Array.isArray(sourceObject) && sourceObject.every(elem => !isNaN(elem)))\n            return new arrayType(sourceObject);\n        return this._throwTypeMismatchError(\n            arrayType.name,\n            \"a numeric source array\",\n            srcTypeNameForDebug,\n            memberName,\n        );\n    }\n\n    private _convertAsUintArray<T extends Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array>(\n        sourceObject: any,\n        arrayType: Constructor<T>,\n        srcTypeNameForDebug: string,\n        memberName: string,\n    ): T {\n        if (Array.isArray(sourceObject) && sourceObject.every(elem => !isNaN(elem)))\n            return new arrayType(sourceObject.map(value => ~~value));\n        return this._throwTypeMismatchError(\n            arrayType.name,\n            \"a numeric source array\",\n            srcTypeNameForDebug,\n            memberName,\n        );\n    }\n\n    private _throwTypeMismatchError(\n        targetType: string,\n        expectedSourceType: string,\n        actualSourceType: string,\n        memberName: string,\n    ): never {\n        throw new TypeError(\n            `Could not deserialize ${memberName} as ${targetType}:`\n            + ` expected ${expectedSourceType}, got ${actualSourceType}.`,\n        );\n    }\n\n    private _makeTypeErrorMessage(expectedType: Function | string, actualType: Function | string, memberName: string)\n    {\n        const expectedTypeName = (typeof expectedType === \"function\") ? nameof(expectedType) : expectedType;\n        const actualTypeName = (typeof actualType === \"function\") ? nameof(actualType) : actualType;\n\n        return `Could not deserialize ${memberName}: expected '${expectedTypeName}', got '${actualTypeName}'.`;\n    }\n\n    private _instantiateType(ctor: any)\n    {\n        return new ctor();\n    }\n\n    private _mergeKnownTypes(...knownTypeMaps: Array<Map<string, Function>>)\n    {\n        let result = new Map<string, Function>();\n\n        knownTypeMaps.forEach(knownTypes =>\n        {\n            knownTypes.forEach((ctor, name) =>\n            {\n                if (this._nameResolver)\n                {\n                    result.set(this._nameResolver(ctor), ctor);\n                }\n                else\n                {\n                    result.set(name, ctor);\n                }\n            });\n        });\n\n        return result;\n    }\n\n    private _createKnownTypesMap(knowTypes: Set<Function>)\n    {\n        const map = new Map<string, Function>();\n\n        knowTypes.forEach(ctor =>\n        {\n            if (this._nameResolver)\n            {\n                map.set(this._nameResolver(ctor), ctor);\n            }\n            else\n            {\n                const knownTypeMeta = JsonObjectMetadata.getFromConstructor(ctor);\n                const name = knownTypeMeta && knownTypeMeta.isExplicitlyMarked && knownTypeMeta.name\n                    ? knownTypeMeta.name\n                    : ctor.name;\n                map.set(name, ctor);\n            }\n        });\n\n        return map;\n    }\n\n    private _stringToArrayBuffer(str: string)\n    {\n        let buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n        let bufView = new Uint16Array(buf);\n\n        for (let i = 0, strLen = str.length; i < strLen; i++)\n        {\n            bufView[i] = str.charCodeAt(i);\n        }\n\n        return buf;\n    }\n\n    private _stringToDataView(str: string)\n    {\n        return new DataView(this._stringToArrayBuffer(str));\n    }\n\n    private isExpectedMapShape(source: any, expectedShape: MapShape): boolean {\n        return (expectedShape === MapShape.ARRAY && Array.isArray(source))\n        || (expectedShape === MapShape.OBJECT && typeof source === \"object\");\n    }\n\n    private retrievePreserveNull(memberOptions?: OptionsBase): boolean\n    {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n}\n","import { nameof, logError, isReflectMetadataSupported, MISSING_REFLECT_CONF_MSG } from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\nimport {\n    ArrayTypeDescriptor,\n    ensureTypeDescriptor,\n    isTypelike,\n    TypeDescriptor,\n} from \"./type-descriptor\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonArrayMemberOptions extends OptionsBase\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, an empty array is emitted if the property is undefined/uninitialized. */\n    emitDefaultValue?: boolean;\n\n    /** Sets array dimensions (e.g. 1 for 'number[]' or 2 for 'number[][]'). Defaults to 1. */\n    dimensions?: number;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property, of type array, is part of an object when serializing.\n * @param elementConstructor Constructor of array elements (e.g. 'Number' for 'number[]', or 'Date' for 'Date[]').\n * @param options Additional options.\n */\nexport function jsonArrayMember(elementConstructor: Function|TypeDescriptor, options: IJsonArrayMemberOptions = {})\n{\n    return (target: Object, propKey: string | symbol) =>\n    {\n        const decoratorName = `@jsonArrayMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (!isTypelike(elementConstructor))\n        {\n            logError(`${decoratorName}: could not resolve constructor of array elements at runtime.`);\n            return;\n        }\n\n        const dimensions = options.dimensions === undefined ? 1 : options.dimensions;\n        if (!isNaN(dimensions) && dimensions < 1)\n        {\n            logError(`${decoratorName}: 'dimensions' option must be at least 1.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonArrayMember' has been used on an array.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Array)\n        {\n            logError(`${decoratorName}: property is not an Array. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: createArrayType(ensureTypeDescriptor(elementConstructor), dimensions),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n\nexport function createArrayType(elementType: TypeDescriptor, dimensions: number): ArrayTypeDescriptor {\n    let type = new ArrayTypeDescriptor(elementType);\n    for (let i = 1; i < dimensions; ++i) {\n        type = new ArrayTypeDescriptor(type);\n    }\n    return type;\n}\n","import { Constructor, IndexedObject } from \"./typedjson/types\";\nimport { Serializer, TypeHintEmitter } from \"./typedjson/serializer\";\nimport { Deserializer, TypeResolver } from \"./typedjson/deserializer\";\nimport { JsonObjectMetadata } from \"./typedjson/metadata\";\nimport { logError, logWarning, nameof, parseToJSObject } from \"./typedjson/helpers\";\nimport { extractOptionBase, OptionsBase } from \"./typedjson/options-base\";\nimport { createArrayType } from \"./typedjson/json-array-member\";\nimport { ensureTypeDescriptor, MapT, SetT } from './typedjson/type-descriptor';\n\nexport type JsonTypes = Object|boolean|string|number|null|undefined;\nexport { TypeResolver, TypeHintEmitter };\n\nexport interface ITypedJSONSettings extends OptionsBase\n{\n    /**\n     * Sets the handler callback to invoke on errors during serializing and deserializing.\n     * Re-throwing errors in this function will halt serialization/deserialization.\n     * The default behavior is to log errors to the console.\n     */\n    errorHandler?: (e: Error) => void;\n\n    /**\n     * Sets a callback that determines the constructor of the correct sub-type of polymorphic\n     * objects while deserializing.\n     * The default behavior is to read the type-name from the '__type' property of 'sourceObject',\n     * and look it up in 'knownTypes'.\n     * The constructor of the sub-type should be returned.\n     */\n    typeResolver?: TypeResolver;\n\n    nameResolver?: (ctor: Function) => string;\n\n    /**\n     * Sets a callback that writes type-hints to serialized objects.\n     * The default behavior is to write the type-name to the '__type' property, if a derived type\n     * is present in place of a base type.\n     */\n    typeHintEmitter?: TypeHintEmitter;\n\n    /**\n     * Sets the amount of indentation to use in produced JSON strings.\n     * Default value is 0, or no indentation.\n     */\n    indent?: number;\n\n    replacer?: (key: string, value: any) => any;\n\n    knownTypes?: Array<Constructor<any>>;\n}\n\nexport class TypedJSON<T>\n{\n    //#region Static\n    public static parse<T>(\n        object: any, rootType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): T|undefined {\n        return new TypedJSON(rootType, settings).parse(object);\n    }\n\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: 1\n    ): T[];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 2\n    ): T[][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 3\n    ): T[][][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 4\n    ): T[][][][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 5\n    ): T[][][][][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: number\n    ): any[] {\n        return new TypedJSON(elementType, settings).parseAsArray(object, dimensions as any);\n    }\n\n    public static parseAsSet<T>(\n        object: any, elementType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): Set<T> {\n        return new TypedJSON(elementType, settings).parseAsSet(object);\n    }\n\n    public static parseAsMap<K, V>(\n        object: any,\n        keyType: Constructor<K>,\n        valueType: Constructor<V>,\n        settings?: ITypedJSONSettings,\n    ): Map<K, V> {\n        return new TypedJSON(valueType, settings).parseAsMap(object, keyType);\n    }\n\n    public static toPlainJson<T>(\n        object: T, rootType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): JsonTypes {\n        return new TypedJSON(rootType, settings).toPlainJson(object);\n    }\n\n    public static toPlainArray<T>(\n        object: T[], elementType: Constructor<T>, dimensions?: 1, settings?: ITypedJSONSettings,\n    ): Object[];\n    public static toPlainArray<T>(\n        object: T[][], elementType: Constructor<T>, dimensions: 2, settings?: ITypedJSONSettings,\n    ): Object[][];\n    public static toPlainArray<T>(\n        object: T[][][], elementType: Constructor<T>, dimensions: 3, settings?: ITypedJSONSettings,\n    ): Object[][][];\n    public static toPlainArray<T>(\n        object: T[][][][], elementType: Constructor<T>, dimensions: 4, settings?: ITypedJSONSettings,\n    ): Object[][][][];\n    public static toPlainArray<T>(\n        object: T[][][][][], elementType: Constructor<T>, dimensions: 5, settings?: ITypedJSONSettings,\n    ): Object[][][][][];\n    public static toPlainArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions: number, settings?: ITypedJSONSettings,\n    ): any[];\n    public static toPlainArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions?: any, settings?: ITypedJSONSettings,\n    ): any[] {\n        return new TypedJSON(elementType, settings).toPlainArray(object, dimensions);\n    }\n\n    public static toPlainSet<T>(\n        object: Set<T>, elementType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): Object[]|undefined {\n        return new TypedJSON(elementType, settings).toPlainSet(object);\n    }\n\n    public static toPlainMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Constructor<K>,\n        valueCtor: Constructor<V>,\n        settings?: ITypedJSONSettings,\n    ): IndexedObject|{ key: any, value: any }[]|undefined {\n        return new TypedJSON(valueCtor, settings).toPlainMap(object, keyCtor);\n    }\n\n    public static stringify<T>(\n        object: T, rootType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(rootType, settings).stringify(object);\n    }\n\n    public static stringifyAsArray<T>(\n        object: T[], elementType: Constructor<T>, dimensions?: 1, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][], elementType: Constructor<T>, dimensions: 2, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][][], elementType: Constructor<T>, dimensions: 3, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][][][], elementType: Constructor<T>, dimensions: 4, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][][][][], elementType: Constructor<T>, dimensions: 5, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions: number, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions?: any, settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(elementType, settings).stringifyAsArray(object, dimensions);\n    }\n\n    public static stringifyAsSet<T>(\n        object: Set<T>, elementType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(elementType, settings).stringifyAsSet(object);\n    }\n\n    public static stringifyAsMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Constructor<K>,\n        valueCtor: Constructor<V>,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(valueCtor, settings).stringifyAsMap(object, keyCtor);\n    }\n\n    private static _globalConfig: ITypedJSONSettings;\n\n    public static setGlobalConfig(config: ITypedJSONSettings)\n    {\n        if (this._globalConfig)\n        {\n            Object.assign(this._globalConfig, config);\n        }\n        else\n        {\n            this._globalConfig = config;\n        }\n    }\n\n    //#endregion\n\n    private serializer: Serializer = new Serializer();\n    private deserializer: Deserializer<T> = new Deserializer<T>();\n    private globalKnownTypes: Array<Constructor<any>> = [];\n    private indent: number = 0;\n    private rootConstructor: Constructor<T>;\n    private errorHandler: (e: Error) => void;\n    private nameResolver: (ctor: Function) => string;\n    private replacer?: (key: string, value: any) => any;\n\n    /**\n     * Creates a new TypedJSON instance to serialize (stringify) and deserialize (parse) object\n     *     instances of the specified root class type.\n     * @param rootConstructor The constructor of the root class type.\n     * @param settings Additional configuration settings.\n     */\n    constructor(rootConstructor: Constructor<T>, settings?: ITypedJSONSettings)\n    {\n        let rootMetadata = JsonObjectMetadata.getFromConstructor(rootConstructor);\n\n        if (!rootMetadata || (!rootMetadata.isExplicitlyMarked && !rootMetadata.isHandledWithoutAnnotation))\n        {\n            throw new TypeError(\"The TypedJSON root data type must have the @jsonObject decorator used.\");\n        }\n\n        this.nameResolver = (ctor) => nameof(ctor);\n        this.rootConstructor = rootConstructor;\n        this.errorHandler = (error) => logError(error);\n\n        if (settings)\n        {\n            this.config(settings);\n        }\n        else if (TypedJSON._globalConfig)\n        {\n            this.config({});\n        }\n    }\n\n    /**\n     * Configures TypedJSON through a settings object.\n     * @param settings The configuration settings object.\n     */\n    public config(settings: ITypedJSONSettings)\n    {\n        if (TypedJSON._globalConfig)\n        {\n            settings = {\n                ...TypedJSON._globalConfig,\n                ...settings\n            };\n\n            if (settings.knownTypes && TypedJSON._globalConfig.knownTypes)\n            {\n                // Merge known-types (also de-duplicate them, so Array -> Set -> Array).\n                settings.knownTypes = Array.from(new Set(\n                    settings.knownTypes.concat(TypedJSON._globalConfig.knownTypes),\n                ));\n            }\n        }\n\n        const options = extractOptionBase(settings);\n        this.serializer.options = options;\n        this.deserializer.options = options;\n\n        if (settings.errorHandler)\n        {\n            this.errorHandler = settings.errorHandler;\n            this.deserializer.setErrorHandler(settings.errorHandler);\n            this.serializer.setErrorHandler(settings.errorHandler);\n        }\n\n        if (settings.replacer) this.replacer = settings.replacer;\n        if (settings.typeResolver) this.deserializer.setTypeResolver(settings.typeResolver);\n        if (settings.typeHintEmitter) this.serializer.setTypeHintEmitter(settings.typeHintEmitter);\n        if (settings.indent) this.indent = settings.indent;\n\n        if (settings.nameResolver)\n        {\n            this.nameResolver = settings.nameResolver;\n            this.deserializer.setNameResolver(settings.nameResolver);\n            // this.serializer.set\n        }\n\n        if (settings.knownTypes)\n        {\n            // Type-check knownTypes elements to recognize errors in advance.\n            settings.knownTypes.forEach((knownType, i) =>\n            {\n                // tslint:disable-next-line:no-null-keyword\n                if (typeof knownType === \"undefined\" || knownType === null)\n                {\n                    logWarning(\n                        `TypedJSON.config: 'knownTypes' contains an undefined/null value (element ${i}).`);\n                }\n            });\n\n            this.globalKnownTypes = settings.knownTypes;\n        }\n    }\n\n    /**\n     * Converts a JSON string to the root class type.\n     * @param object The JSON to parse and convert.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns Deserialized T or undefined if there were errors.\n     */\n    public parse(object: any): T|undefined\n    {\n        const json = parseToJSObject(object, this.rootConstructor);\n\n        let rootMetadata = JsonObjectMetadata.getFromConstructor(this.rootConstructor);\n        let result: T|undefined;\n        let knownTypes = new Map<string, Function>();\n\n        this.globalKnownTypes.filter(ktc => ktc).forEach(knownTypeCtor =>\n        {\n            knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n        });\n\n        if (rootMetadata)\n        {\n            rootMetadata.knownTypes.forEach(knownTypeCtor =>\n            {\n                knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n            });\n        }\n\n        try\n        {\n            result = this.deserializer.convertSingleValue(\n                json,\n                ensureTypeDescriptor(this.rootConstructor),\n                knownTypes,\n            ) as T;\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n\n        return result;\n    }\n\n    public parseAsArray(object: any, dimensions?: 1): T[];\n    public parseAsArray(object: any, dimensions: 2): T[][];\n    public parseAsArray(object: any, dimensions: 3): T[][][];\n    public parseAsArray(object: any, dimensions: 4): T[][][][];\n    public parseAsArray(object: any, dimensions: 5): T[][][][][];\n    public parseAsArray(object: any, dimensions: number): any[];\n    public parseAsArray(object: any, dimensions: number = 1): any[]\n    {\n        const json = parseToJSObject(object, Array);\n        return this.deserializer.convertAsArray(json,\n            createArrayType(ensureTypeDescriptor(this.rootConstructor), dimensions),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    public parseAsSet(object: any): Set<T>\n    {\n        const json = parseToJSObject(object, Set);\n        return this.deserializer.convertAsSet(json,\n            SetT(this.rootConstructor),\n            this._mapKnownTypes(this.globalKnownTypes)\n        );\n    }\n\n    public parseAsMap<K>(object: any, keyConstructor: Constructor<K>): Map<K, T>\n    {\n        const json = parseToJSObject(object, Map);\n        return this.deserializer.convertAsMap(\n            json,\n            MapT(keyConstructor, this.rootConstructor),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    /**\n     * Converts an instance of the specified class type to a plain JSON object.\n     * @param object The instance to convert to a JSON string.\n     * @returns Serialized object or undefined if an error has occured.\n     */\n    public toPlainJson(object: T): JsonTypes\n    {\n        try\n        {\n            return this.serializer.convertSingleValue(\n                object,\n                ensureTypeDescriptor(this.rootConstructor),\n            );\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    public toPlainArray(object: T[], dimensions?: 1): Object[];\n    public toPlainArray(object: T[][], dimensions: 2): Object[][];\n    public toPlainArray(object: T[][][], dimensions: 3): Object[][][];\n    public toPlainArray(object: T[][][][], dimensions: 4): Object[][][][];\n    public toPlainArray(object: T[][][][][], dimensions: 5): Object[][][][][];\n    public toPlainArray(object: any[], dimensions: 1|2|3|4|5 = 1): Object[]|undefined\n    {\n        try\n        {\n            return this.serializer.convertAsArray(\n                object, createArrayType(ensureTypeDescriptor(this.rootConstructor), dimensions));\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    public toPlainSet(object: Set<T>): Object[]|undefined\n    {\n        try\n        {\n            return this.serializer.convertAsSet(object, SetT(this.rootConstructor));\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    public toPlainMap<K>(object: Map<K, T>, keyConstructor: Constructor<K>): IndexedObject|{ key: any, value: any }[]|undefined\n    {\n        try\n        {\n            return this.serializer.convertAsMap(object, MapT(keyConstructor, this.rootConstructor));\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Converts an instance of the specified class type to a JSON string.\n     * @param object The instance to convert to a JSON string.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns String with the serialized object or an empty string if an error has occured, but\n     *     the errorHandler did not throw.\n     */\n    public stringify(object: T): string\n    {\n        const result = this.toPlainJson(object);\n        if (result === undefined) {\n            return '';\n        }\n        return JSON.stringify(result, this.replacer, this.indent);\n    }\n\n    public stringifyAsArray(object: T[], dimensions?: 1): string;\n    public stringifyAsArray(object: T[][], dimensions: 2): string;\n    public stringifyAsArray(object: T[][][], dimensions: 3): string;\n    public stringifyAsArray(object: T[][][][], dimensions: 4): string;\n    public stringifyAsArray(object: T[][][][][], dimensions: 5): string;\n    public stringifyAsArray(object: any[], dimensions: any): string\n    {\n        return JSON.stringify(this.toPlainArray(object, dimensions), this.replacer, this.indent);\n    }\n\n    public stringifyAsSet(object: Set<T>): string\n    {\n        return JSON.stringify(this.toPlainSet(object), this.replacer, this.indent);\n    }\n\n    public stringifyAsMap<K>(object: Map<K, T>, keyConstructor: Constructor<K>): string\n    {\n        return JSON.stringify(this.toPlainMap(object, keyConstructor), this.replacer, this.indent);\n    }\n\n    private _mapKnownTypes(constructors: Array<Constructor<any>>)\n    {\n        let map = new Map<string, Constructor<any>>();\n\n        constructors.filter(ctor => ctor).forEach(ctor => map.set(this.nameResolver(ctor), ctor));\n\n        return map;\n    }\n}\n","import { Constructor, ParameterlessConstructor } from \"./types\";\nimport { METADATA_FIELD_KEY } from \"./helpers\";\nimport { JsonObjectMetadata } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\n\nexport type InitializerCallback<T> = (sourceObject: T, rawSourceObject: T) => T;\n\nexport interface IJsonObjectOptionsBase extends OptionsBase\n{\n    /**\n     * An array of known types to recognize when encountering type-hints,\n     * or the name of a static method used for determining known types.\n     */\n    knownTypes?: Function[] | string;\n\n    /**\n     * The name of a static or instance method to call when deserialization\n     * of the object is completed.\n     */\n    onDeserialized?: string;\n\n    /**\n     * The name of a static or instance method to call before the serialization\n     * of the typed object is started.\n     */\n    beforeSerialization?: string;\n\n    /**\n     * The name used to differentiate between different polymorphic types.\n     */\n    name?: string;\n}\n\nexport interface IJsonObjectOptionsWithInitializer<T> extends IJsonObjectOptionsBase\n{\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer: InitializerCallback<T>;\n}\n\nexport interface IJsonObjectOptions<T> extends IJsonObjectOptionsBase\n{\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer?: InitializerCallback<T>;\n}\n\n/**\n * Marks that a class with a parameterized constructor is serializable using TypedJSON, with additional\n * settings. The 'initializer' setting must be specified.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(options?: IJsonObjectOptionsWithInitializer<T>): (target: Constructor<T>) => void;\n\n/**\n * Marks that a class is serializable using TypedJSON, with additional settings.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(options?: IJsonObjectOptions<T>): (target: ParameterlessConstructor<T>) => void;\n\n/**\n * Marks that a class with a parameterless constructor is serializable using TypedJSON.\n */\nexport function jsonObject<T>(target: ParameterlessConstructor<T>): void;\n\nexport function jsonObject<T extends Object>(optionsOrTarget?: IJsonObjectOptions<T> | Constructor<T>\n): ((target: Constructor<T>) => void) | void {\n    let options: IJsonObjectOptions<T>;\n\n    if (typeof optionsOrTarget === \"function\")\n    {\n        // jsonObject is being used as a decorator, directly.\n        options = {};\n    }\n    else\n    {\n        // jsonObject is being used as a decorator factory.\n        options = optionsOrTarget || {};\n    }\n\n    function decorator(\n        target: Function\n    ): void {\n        let objectMetadata: JsonObjectMetadata;\n\n        // Create or obtain JsonObjectMetadata object.\n        if (!target.prototype.hasOwnProperty(METADATA_FIELD_KEY))\n        {\n            // Target has no JsonObjectMetadata associated with it yet, create it now.\n            objectMetadata = new JsonObjectMetadata(target);\n\n            // Inherit json members and known types from parent @jsonObject (if any).\n            const parentMetadata: JsonObjectMetadata = target.prototype[METADATA_FIELD_KEY];\n            if (parentMetadata)\n            {\n                parentMetadata.dataMembers\n                    .forEach((memberMetadata, propKey) =>\n                        objectMetadata.dataMembers.set(propKey, memberMetadata));\n                parentMetadata.knownTypes\n                    .forEach((knownType) => objectMetadata.knownTypes.add(knownType));\n            }\n\n            Object.defineProperty(target.prototype, METADATA_FIELD_KEY, {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: objectMetadata\n            });\n        }\n        else\n        {\n            // Target already has JsonObjectMetadata associated with it.\n            objectMetadata = target.prototype[METADATA_FIELD_KEY];\n            objectMetadata.classType = target;\n        }\n\n        // Fill JsonObjectMetadata.\n        objectMetadata.isExplicitlyMarked = true;\n        objectMetadata.onDeserializedMethodName = options.onDeserialized;\n        objectMetadata.beforeSerializationMethodName = options.beforeSerialization;\n        \n        // T extend Object so it is fine\n        objectMetadata.initializerCallback = options.initializer as any;\n        if (options.name)\n        {\n            objectMetadata.name = options.name;\n        }\n        const optionsBase = extractOptionBase(options);\n        if (optionsBase)\n        {\n            objectMetadata.options = optionsBase;\n        }\n\n        // Obtain known-types.\n        if (typeof options.knownTypes === \"string\")\n        {\n            objectMetadata.knownTypeMethodName = options.knownTypes;\n        }\n        else if (options.knownTypes instanceof Array)\n        {\n            options.knownTypes\n                .filter(knownType => !!knownType)\n                .forEach(knownType => objectMetadata.knownTypes.add(knownType));\n        }\n    }\n\n    if (typeof optionsOrTarget === \"function\")\n    {\n        // jsonObject is being used as a decorator, directly.\n        decorator(optionsOrTarget);\n    }\n    else\n    {\n        // jsonObject is being used as a decorator factory.\n        return decorator;\n    }\n}\n","import {\n    nameof, logError, isReflectMetadataSupported, isValueDefined, logWarning, isSubtypeOf, MISSING_REFLECT_CONF_MSG,\n} from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\nimport {\n    ArrayTypeDescriptor,\n    ConcreteTypeDescriptor,\n    ensureTypeDescriptor, MapTypeDescriptor, SetTypeDescriptor,\n    TypeDescriptor,\n} from \"./type-descriptor\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMemberOptions extends OptionsBase\n{\n    /**\n     * Sets the constructor of the property.\n     * Optional with ReflectDecorators.\n     */\n    constructor?: Function|TypeDescriptor;\n\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted if the property is uninitialized/undefined. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name. */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property is part of the object when serializing, with additional options.\n * Omitting the 'constructor' option requires ReflectDecorators and that the property type is always explicitly declared.\n * @param options Additional options.\n */\nexport function jsonMember<TFunction extends Function>(options: IJsonMemberOptions): PropertyDecorator;\n\n/**\n * Specifies that a property is part of the object when serializing.\n * This call signature requires ReflectDecorators and that the property type is always explicitly declared.\n */\nexport function jsonMember(target: Object, propertyKey: string | symbol): void;\n\nexport function jsonMember<TFunction extends Function>(optionsOrTarget?: IJsonMemberOptions | Object, propKey?: string | symbol): PropertyDecorator | void\n{\n    if (optionsOrTarget instanceof Object && (typeof propKey === \"string\" || typeof propKey === \"symbol\"))\n    {\n        const target = optionsOrTarget as Object;\n        // For error messages.\n        const decoratorName = `@jsonMember on ${nameof(target.constructor)}.${String(propKey)}`;\n\n        // jsonMember used directly, no additional information directly available besides target and propKey.\n        // Obtain property constructor through ReflectDecorators.\n        if (isReflectMetadataSupported)\n        {\n            const reflectPropCtor = Reflect.getMetadata(\"design:type\", target, propKey) as Function;\n\n            if (!reflectPropCtor)\n            {\n                logError(`${decoratorName}: could not resolve detected property constructor at runtime. ${MISSING_REFLECT_CONF_MSG}`);\n                return;\n            }\n\n            const typeDescriptor = ensureTypeDescriptor(reflectPropCtor);\n            if (isSpecialPropertyType(decoratorName, typeDescriptor))\n            {\n                return;\n            }\n\n            injectMetadataInformation(target, propKey, {\n                type: typeDescriptor,\n                key: propKey.toString(),\n                name: propKey.toString(),\n            });\n        }\n        else\n        {\n            logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is specified.`);\n            return;\n        }\n    }\n    else\n    {\n        // jsonMember used as a decorator factory.\n        return (target: Object, _propKey: string | symbol) =>\n        {\n            let options: IJsonMemberOptions = optionsOrTarget || {};\n            let typeDescriptor: TypeDescriptor|undefined;\n            let decoratorName = `@jsonMember on ${nameof(target.constructor)}.${String(_propKey)}`; // For error messages.\n\n            if (options.hasOwnProperty(\"constructor\"))\n            {\n                if (!isValueDefined(options.constructor))\n                {\n                    logError(`${decoratorName}: cannot resolve specified property constructor at runtime.`);\n                    return;\n                }\n\n                // Property constructor has been specified. Use ReflectDecorators (if available) to check whether that constructor is correct. Warn if not.\n                typeDescriptor = ensureTypeDescriptor(options.constructor);\n                if (isReflectMetadataSupported && !isSubtypeOf(typeDescriptor.ctor, Reflect.getMetadata(\"design:type\", target, _propKey)))\n                {\n                    logWarning(`${decoratorName}: detected property type does not match 'constructor' option.`);\n                }\n            }\n            else\n            {\n                // Use ReflectDecorators to obtain property constructor.\n                if (isReflectMetadataSupported)\n                {\n                    const reflectCtor = Reflect.getMetadata(\"design:type\", target, _propKey) as Function;\n\n                    if (!reflectCtor)\n                    {\n                        logError(`${decoratorName}: cannot resolve detected property constructor at runtime.`);\n                        return;\n                    }\n                    typeDescriptor = ensureTypeDescriptor(reflectCtor);\n                }\n                else if (!options.deserializer)\n                {\n                    logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is specified.`);\n                    return;\n                }\n            }\n\n\n            if (typeDescriptor && isSpecialPropertyType(decoratorName, typeDescriptor))\n            {\n                return;\n            }\n            injectMetadataInformation(target, _propKey, {\n                type: typeDescriptor,\n                emitDefaultValue: options.emitDefaultValue,\n                isRequired: options.isRequired,\n                options: extractOptionBase(options),\n                key: _propKey.toString(),\n                name: options.name || _propKey.toString(),\n                deserializer: options.deserializer,\n                serializer: options.serializer,\n            });\n        };\n    }\n}\n\nfunction isSpecialPropertyType(decoratorName: string, typeDescriptor: TypeDescriptor)\n{\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor) && typeDescriptor.ctor === Array)\n    {\n        logError(`${decoratorName}: property is an Array. Use the jsonArrayMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (!(typeDescriptor instanceof SetTypeDescriptor) && typeDescriptor.ctor === Set)\n    {\n        logError(`${decoratorName}: property is a Set. Use the jsonSetMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (!(typeDescriptor instanceof MapTypeDescriptor) && typeDescriptor.ctor === Map)\n    {\n        logError(`${decoratorName}: property is a Map. Use the jsonMapMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    return false;\n}\n","import { isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof } from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\nimport { isTypelike, SetT } from \"./type-descriptor\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonSetMemberOptions extends OptionsBase\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Set<T>.\n * @param elementConstructor Constructor of set elements (e.g. 'Number' for Set<number> or 'Date' for Set<Date>).\n * @param options Additional options.\n */\nexport function jsonSetMember(elementConstructor: Function, options: IJsonSetMemberOptions = {})\n{\n    return (target: Object, propKey: string | symbol) =>\n    {\n        const decoratorName = `@jsonSetMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (!isTypelike(elementConstructor))\n        {\n            logError(`${decoratorName}: could not resolve constructor of set elements at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonSetMember' has been used on a set. Warn if not.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Set)\n        {\n            logError(`${decoratorName}: property is not a Set. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: SetT(elementConstructor),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import { nameof, logError, isReflectMetadataSupported, MISSING_REFLECT_CONF_MSG } from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\nimport { isTypelike, MapOptions, MapT, TypeDescriptor } from \"./type-descriptor\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMapMemberOptions extends OptionsBase, Partial<MapOptions>\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Map<K, V>.\n * @param keyConstructor Constructor of map keys (e.g. 'Number' for 'Map<number, Date>').\n * @param valueConstructor Constructor of map values (e.g. 'Date' for 'Map<number, Date>').\n * @param options Additional options.\n */\nexport function jsonMapMember(\n    keyConstructor: Function|TypeDescriptor,\n    valueConstructor: Function|TypeDescriptor,\n    options: IJsonMapMemberOptions = {},\n) {\n    return (target: Object, propKey: string | symbol) =>\n    {\n        const decoratorName = `@jsonMapMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (!isTypelike(keyConstructor))\n        {\n            logError(`${decoratorName}: could not resolve constructor of map keys at runtime.`);\n            return;\n        }\n\n        if (!isTypelike(valueConstructor))\n        {\n            logError(`${decoratorName}: could not resolve constructor of map values at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonMapMember' has been used on a map. Warn if not.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Map)\n        {\n            logError(`${decoratorName}: property is not a Map. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: MapT(keyConstructor, valueConstructor, {shape: options.shape}),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import { TypedJSON } from \"../parser\";\n\n/**\n * Options for the @toJson decorator.\n */\nexport interface IToJsonOptions {\n    /**\n     * When set to true it will overwrite any toJSON already existing on the prototype.\n     */\n    overwrite?: boolean;\n}\n\n/**\n * Decorator that will generate toJSON function on the class prototype that allows\n * JSON.stringify to be used instead of TypedJSON.stringify. Under the hood it will\n * simply delegate to TypedJSON.\n * By default it will throw if the prototype already has a toJSON function defined.\n * @param target the class which prototype should be modified.\n */\nexport function toJson<T extends Object>(target: Function): void;\n/**\n * Decorator factory that accepts the options interface.\n * @param options for configuring the toJSON creation.\n */\nexport function toJson<T extends Object>(options: IToJsonOptions): ((target: Function) => void);\nexport function toJson<T extends Object>(optionsOrTarget: IToJsonOptions | Function\n): ((target: Function) => void) | void {\n    if (typeof optionsOrTarget === 'function') {\n        // used directly\n        toJsonDecorator(optionsOrTarget, {});\n        return;\n    }\n    // used as a factory\n    return (target: Function) => {\n        toJsonDecorator(target, optionsOrTarget);\n    }\n}\n\nfunction toJsonDecorator<T extends Object>(target: Function, options: IToJsonOptions): void {\n    if (!options.overwrite && target.prototype.toJSON) {\n        throw new Error(`${target.name} already has toJSON defined!`);\n    }\n    target.prototype.toJSON = function () {\n        return TypedJSON.toPlainJson(this, Object.getPrototypeOf(this).constructor);\n    }\n}\n","export { TypedJSON, ITypedJSONSettings, JsonTypes, TypeResolver, TypeHintEmitter } from \"./parser\";\nexport { jsonObject } from \"./typedjson/json-object\";\nexport { jsonMember } from \"./typedjson/json-member\";\nexport { jsonArrayMember } from \"./typedjson/json-array-member\";\nexport { jsonSetMember } from \"./typedjson/json-set-member\";\nexport { jsonMapMember } from \"./typedjson/json-map-member\";\nexport { toJson } from \"./typedjson/to-json\";\nexport { ArrayT, SetT, MapT } from \"./typedjson/type-descriptor\";\n"],"sourceRoot":""}
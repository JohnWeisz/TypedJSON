{"version":3,"sources":["webpack://typedjson/webpack/universalModuleDefinition","webpack://typedjson/webpack/bootstrap","webpack://typedjson/./src/typedjson/helpers.ts","webpack://typedjson/./src/typedjson/metadata.ts","webpack://typedjson/./src/typedjson/options-base.ts","webpack://typedjson/./src/typedjson/serializer.ts","webpack://typedjson/./src/typedjson/deserializer.ts","webpack://typedjson/./src/parser.ts","webpack://typedjson/./src/typedjson/json-object.ts","webpack://typedjson/./src/typedjson/json-member.ts","webpack://typedjson/./src/typedjson/json-array-member.ts","webpack://typedjson/./src/typedjson/json-set-member.ts","webpack://typedjson/./src/typedjson/json-map-member.ts","webpack://typedjson/./src/typedjson/to-json.ts","webpack://typedjson/./src/typedjson.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","METADATA_FIELD_KEY","isDirectlySerializableNativeType","type","Date","Number","String","Boolean","indexOf","isTypeTypedArray","Float32Array","Float64Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","parseToJSObject","json","expectedType","jsonStr","expectsTypesSerializedAsStrings","ArrayBuffer","DataView","hasQuotes","length","isInteger","test","trim","JSON","parse","isSubtypeOf","A","B","logError","message","optionalParams","_i","arguments","console","error","apply","concat","log","logWarning","warn","isValueDefined","isInstanceOf","constructor","isReflectMetadataSupported","Reflect","getMetadata","nameof","fn","metadata_JsonObjectMetadata","JsonObjectMetadata","classType","dataMembers","Map","knownTypes","Set","isExplicitlyMarked","isHandledWithoutAnnotation","getJsonObjectName","ctor","metadata","getFromConstructor","doesHandleWithoutAnnotation","primitiveMeta","getKnownTypeNameFromType","injectMetadataInformation","propKey","objectMetadata","decoratorName","deserializer","parentMetadata","forEach","_metadata","_propKey","set","configurable","writable","add","keyType","elementType","elemCtor","keys","undefined","kAllOptions","extractOptionBase","from","options","filter","includes","reduce","obj","getOptionValue","getDefaultOptionOf","mergeOptions","existing","moreSpecific","assign","serializer_Serializer","Serializer","_typeHintEmitter","targetObject","sourceObject","expectedSourceType","sourceTypeMetadata","name_1","_errorHandler","setTypeHintEmitter","typeEmitterCallback","TypeError","setErrorHandler","errorHandlerCallback","convertSingleValue","typeInfo","memberName","memberOptions","retrievePreserveNull","selfType","convertAsArrayBuffer","convertAsDataView","Array","convertAsArray","elementTypes","convertAsSet","convertAsMap","convertAsTypedArray","convertAsObject","expectedName","actualName","_this","beforeSerializationMethodName","sourceMeta_1","classOptions_1","memberMetadata","serialized","serializer","__assign","expectedElementType","element","expectedTypeName","actualTypeName","typeInfoForElements","slice","map","elementTypeInfo","resultArray","resultElement","push","expectedKeyType","keyTypeInfo","preserveNull","resultKeyValuePairObj","keyDefined","valueDefined","buffer","charCode","fromCharCode","join","dataView","deserializer_Deserializer","Deserializer","_typeResolver","__type","setNameResolver","nameResolverCallback","_nameResolver","setTypeResolver","typeResolverCallback","sourceObjectTypeInfo","objectName","expectedSelfType","selfConstructor","sourceObjectMetadata","knownTypeConstructors","_mergeKnownTypes","_createKnownTypesMap","typeFromTypeHint","sourceMetadata_1","sourceObjectWithDeserializedProperties_1","revivedValue","memberValue","memberNameForDebug","elementConstructor","keyConstructor","isRequired","initializerCallback","e","_instantiateType","onDeserializedMethodName","targetObject_1","sourceKey","srcTypeNameForDebug","_isDirectlyDeserializableNativeType","_makeTypeErrorMessage","_throwTypeMismatchError","every","elem","isNaN","_stringToArrayBuffer","_stringToDataView","resultSet","valueTypeInfo","resultMap","targetType","actualSourceType","actualType","knownTypeMaps","result","knowTypes","knownTypeMeta","convertNativeObject","str","buf","bufView","strLen","charCodeAt","parser_TypedJSON","TypedJSON","rootConstructor","settings","globalKnownTypes","indent","rootMetadata","nameResolver","errorHandler","config","_globalConfig","rootType","parseAsArray","dimensions","parseAsSet","parseAsMap","valueType","toPlainJson","toPlainArray","toPlainSet","toPlainMap","keyCtor","valueCtor","stringify","stringifyAsArray","stringifyAsSet","stringifyAsMap","setGlobalConfig","parser_assign","replacer","typeResolver","typeHintEmitter","knownType","ktc","knownTypeCtor","fill","_mapKnownTypes","elementConstructorArray","constructors","jsonObject","optionsOrTarget","decorator","target","onDeserialized","beforeSerialization","initializer","optionsBase","knownTypeMethodName","jsonMember","propCtor","isSpecialPropertyType","emitDefaultValue","toString","reflectPropCtor","jsonArrayMember","elementCtor","jsonSetMember","jsonMapMember","valueConstructor","toJson","toJsonDecorator","overwrite","toJSON","Error","getPrototypeOf","__webpack_exports__"],"mappings":"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","file":"typedjson.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"typedjson\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"typedjson\"] = factory();\n\telse\n\t\troot[\"typedjson\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","declare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport const METADATA_FIELD_KEY = \"__typedJsonJsonObjectMetadataInformation__\";\n\nexport function getDefaultValue<T>(type: { new (): T }): T|undefined\n{\n    switch (type as any)\n    {\n        case Number:\n            return 0 as any;\n\n        case String:\n            return \"\" as any;\n\n        case Boolean:\n            return false as any;\n\n        case Array:\n            return [] as any;\n\n        default:\n            return undefined;\n    }\n}\n\n/**\n * Determines whether the specified type is a type that can be passed on \"as-is\" into `JSON.stringify`.\n * Values of these types don't need special conversion.\n * @param type The constructor of the type (wrapper constructor for primitive types, e.g. `Number` for `number`).\n */\nexport function isDirectlySerializableNativeType(type: Function): boolean\n{\n    return !!(~[Date, Number, String, Boolean].indexOf(type as any));\n}\n\nexport function isTypeTypedArray(type: Function): boolean\n{\n    return !!(~[Float32Array, Float64Array, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array]\n        .indexOf(type as any));\n}\n\nexport function isPrimitiveValue(obj: any): boolean\n{\n    switch (typeof obj)\n    {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n            return true;\n        default:\n            return (obj instanceof String || obj instanceof Number || obj instanceof Boolean);\n    }\n}\n\nexport function isObject(value: any): value is Object\n{\n    return typeof value === \"object\";\n}\n\nfunction shouldOmitParseString(jsonStr: string, expectedType: Function): boolean {\n    const expectsTypesSerializedAsStrings = expectedType === String\n        || expectedType === ArrayBuffer\n        || expectedType === DataView;\n\n    const hasQuotes = jsonStr.length >= 2 && jsonStr[0] === '\"' && jsonStr[jsonStr.length-1] === '\"';\n    const isInteger = /^\\d+$/.test(jsonStr.trim());\n\n    return (expectsTypesSerializedAsStrings && !hasQuotes) || ((!hasQuotes && !isInteger) && expectedType === Date);\n}\n\nexport function parseToJSObject(json: any, expectedType: Function): Object {\n    if (typeof json !== 'string' ||Â shouldOmitParseString(json, expectedType))\n    {\n      return json;\n    }\n    return JSON.parse(json);\n}\n\n/**\n * Determines if 'A' is a sub-type of 'B' (or if 'A' equals 'B').\n * @param A The supposed derived type.\n * @param B The supposed base type.\n */\nexport function isSubtypeOf(A: Function, B: Function)\n{\n    return A === B || A.prototype instanceof B;\n}\n\nexport function logError(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.error === \"function\")\n    {\n        console.error(message, ...optionalParams);\n    }\n    else if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log(`ERROR: ${message}`, ...optionalParams);\n    }\n}\n\nexport function logMessage(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log(message, ...optionalParams);\n    }\n}\n\nexport function logWarning(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.warn === \"function\")\n    {\n        console.warn(message, ...optionalParams);\n    } else if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log(`WARNING: ${message}`, ...optionalParams);\n    }\n}\n\n/**\n * Checks if the value is considered defined (not undefined and not null).\n * @param value\n */\nexport function isValueDefined<T>(value: T): value is Exclude<T, undefined | null>\n{\n    return !(typeof value === \"undefined\" || value === null);\n}\n\nexport function isInstanceOf<T>(value: any, constructor: Function): boolean\n{\n    if (typeof value === \"number\")\n    {\n        return (constructor === Number);\n    }\n    else if (typeof value === \"string\")\n    {\n        return (constructor === String);\n    }\n    else if (typeof value === \"boolean\")\n    {\n        return (constructor === Boolean);\n    }\n    else if (isObject(value))\n    {\n        return (value instanceof constructor);\n    }\n\n    return false;\n}\n\nexport const isReflectMetadataSupported =\n    (typeof Reflect === \"object\" && typeof Reflect.getMetadata === \"function\");\n\n/**\n * Gets the name of a function.\n * @param fn The function whose name to get.\n */\nexport function nameof(fn: Function & { name?: string })\n{\n    if (typeof fn.name === \"string\")\n    {\n        return fn.name;\n    }\n    else\n    {\n        return \"undefined\";\n    }\n}\n","import { nameof, logError, METADATA_FIELD_KEY, isDirectlySerializableNativeType, isTypeTypedArray } from \"./helpers\";\nimport { IndexedObject } from \"./types\";\nimport { OptionsBase } from \"./options-base\";\n\nexport interface JsonMemberMetadata\n{\n    /** If set, a default value will be emitted for uninitialized members. */\n    emitDefaultValue?: boolean;\n\n    /** Member name as it appears in the serialized JSON. */\n    name: string;\n\n    /** Property or field key of the json member. */\n    key: string;\n\n    /** Constuctor (type) reference of the member. */\n    ctor?: Function;\n\n    /** If set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    options?: OptionsBase;\n\n    /** If the json member is an array, map or set, sets member options of elements/values. Subsequent values define the types of nested arrays. */\n    elementType?: Function[];\n\n    /** If the json member is a map, sets member options of array keys. */\n    keyType?: Function;\n\n    /** Custom deserializer to use. */\n    deserializer?: (json: any) => any;\n\n    /** Custom serializer to use. */\n    serializer?: (value: any) => any;\n}\n\nexport class JsonObjectMetadata\n{\n    //#region Static\n    /**\n     * Gets the name of a class as it appears in a serialized JSON string.\n     * @param ctor The constructor of a class (with or without jsonObject).\n     */\n    public static getJsonObjectName(ctor: Function): string\n    {\n        const metadata = JsonObjectMetadata.getFromConstructor(ctor);\n        return metadata ? nameof(metadata.classType) : nameof(ctor);\n    }\n\n    /**\n     * Gets jsonObject metadata information from a class.\n     * @param ctor The constructor class.\n     */\n    public static getFromConstructor(ctor: Function): JsonObjectMetadata|undefined\n    {\n        const prototype = ctor.prototype;\n        if (!prototype)\n        {\n            return;\n        }\n\n        let metadata: JsonObjectMetadata|undefined;\n        if (prototype.hasOwnProperty(METADATA_FIELD_KEY))\n        {\n            // The class prototype contains own jsonObject metadata\n            metadata = prototype[METADATA_FIELD_KEY];\n        }\n\n        // Ignore implicitly added jsonObject (through jsonMember)\n        if (metadata && metadata.isExplicitlyMarked)\n        {\n            return metadata;\n        }\n\n        // In the end maybe it is something which we can handle directly\n        if (JsonObjectMetadata.doesHandleWithoutAnnotation(ctor))\n        {\n            const primitiveMeta = new JsonObjectMetadata(ctor);\n            primitiveMeta.isExplicitlyMarked = true;\n            // we do not store the metadata here to not modify builtin prototype\n            return primitiveMeta;\n        }\n    }\n\n    /**\n     * Gets the known type name of a jsonObject class for type hint.\n     * @param constructor The constructor class.\n     */\n    public static getKnownTypeNameFromType(constructor: Function): string\n    {\n        const metadata = JsonObjectMetadata.getFromConstructor(constructor);\n        return metadata ? nameof(metadata.classType) : nameof(constructor);\n    }\n\n    private static doesHandleWithoutAnnotation(ctor: Function): boolean\n    {\n        return isDirectlySerializableNativeType(ctor) || isTypeTypedArray(ctor)\n            || ctor === DataView || ctor === ArrayBuffer;\n    }\n    //#endregion\n\n    constructor(\n        classType: Function,\n    ) {\n        this.classType = classType;\n    }\n\n    public dataMembers: Map<string, JsonMemberMetadata> = new Map<string, JsonMemberMetadata>();\n\n    public knownTypes: Set<Function> = new Set<Function>();\n\n    public knownTypeMethodName?: string;\n\n    /** Gets or sets the constructor function for the jsonObject. */\n    public classType: Function;\n\n    /**\n     * Indicates whether this class was explicitly annotated with @jsonObject\n     * or implicitly by @jsonMember\n     */\n    public isExplicitlyMarked: boolean = false;\n\n    /**\n     * Indicates whether this type is handled without annotation. This is usually\n     * used for the builtin types (except for Maps, Sets, and normal Arrays).\n     */\n    public isHandledWithoutAnnotation: boolean = false;\n\n    /** Name used to encode polymorphic type */\n    public name?: string;\n\n    public options?: OptionsBase;\n\n    public onDeserializedMethodName?: string;\n\n    public beforeSerializationMethodName?: string;\n\n    public initializerCallback?: (sourceObject: Object, rawSourceObject: Object) => Object;\n}\n\nexport function injectMetadataInformation(constructor: IndexedObject, propKey: string | symbol, metadata: JsonMemberMetadata)\n{\n    const decoratorName = `@jsonMember on ${nameof(constructor.constructor)}.${String(propKey)}`; // For error messages.\n    let objectMetadata: JsonObjectMetadata;\n\n    // When a property decorator is applied to a static member, 'constructor' is a constructor function.\n    // See: https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md#property-decorators\n    // ... and static members are not supported here, so abort.\n    if (typeof constructor === \"function\")\n    {\n        logError(`${decoratorName}: cannot use a static property.`);\n        return;\n    }\n\n    // Methods cannot be serialized.\n    // @ts-ignore symbol indexing is not supported by ts\n    if (typeof constructor[propKey] === \"function\")\n    {\n        logError(`${decoratorName}: cannot use a method property.`);\n        return;\n    }\n\n    if (!metadata || (!metadata.ctor && !metadata.deserializer))\n    {\n        logError(`${decoratorName}: JsonMemberMetadata has unknown ctor.`);\n        return;\n    }\n\n    // Add jsonObject metadata to 'constructor' if not yet exists ('constructor' is the prototype).\n    // NOTE: this will not fire up custom serialization, as 'constructor' must be explicitly marked with '@jsonObject' as well.\n    if (!constructor.hasOwnProperty(METADATA_FIELD_KEY))\n    {\n        // No *own* metadata, create new.\n        objectMetadata = new JsonObjectMetadata(constructor.constructor);\n\n        // Inherit @JsonMembers from parent @jsonObject (if any).\n        const parentMetadata: JsonObjectMetadata = constructor[METADATA_FIELD_KEY];\n        if (parentMetadata) // && !constructor.hasOwnProperty(Helpers.METADATA_FIELD_KEY)\n        {\n            parentMetadata.dataMembers.forEach((_metadata, _propKey) => objectMetadata.dataMembers.set(_propKey, _metadata));\n        }\n\n        // ('constructor' is the prototype of the involved class, metadata information is added to this class prototype).\n        Object.defineProperty(constructor, METADATA_FIELD_KEY, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: objectMetadata\n        });\n    }\n    else\n    {\n        // JsonObjectMetadata already exists on 'constructor'.\n        objectMetadata = constructor[METADATA_FIELD_KEY];\n    }\n\n    if (!metadata.deserializer)\n    {\n        // @ts-ignore above is a check (!deser && !ctor)\n        objectMetadata.knownTypes.add(metadata.ctor);\n    }\n\n    if (metadata.keyType)\n        objectMetadata.knownTypes.add(metadata.keyType);\n\n    if (metadata.elementType)\n        metadata.elementType.forEach(elemCtor => objectMetadata.knownTypes.add(elemCtor));\n\n    // clear metadata of undefined properties to save memory\n    (Object.keys(metadata) as [keyof JsonMemberMetadata])\n        .forEach((key) => (metadata[key] === undefined) && delete metadata[key]);\n    objectMetadata.dataMembers.set(metadata.name, metadata);\n}\n","/**\n * This options cascade through the annotations. Options set\n * in the more specific place override the previous option.\n * Ex. @jsonMember overrides TypedJson options.\n */\n\nexport interface OptionsBase {\n    /**\n     * Whether to preserve null in the JSON output. When false it\n     * will not emit nor store the property if its value is null.\n     * Default: false.\n     */\n    preserveNull?: boolean;\n}\n\nconst kAllOptions: (keyof OptionsBase)[] = [\n    'preserveNull',\n];\n\nexport function extractOptionBase(from: any): OptionsBase|undefined {\n    const options = Object.keys(from)\n        .filter(key => (kAllOptions as string[]).includes(key))\n        .reduce((obj, key) => {\n            obj[key] = from[key];\n            return obj;\n        }, {} as any);\n    return Object.keys(options).length > 0 ? options : undefined;\n}\n\nexport function getDefaultOptionOf<K extends keyof OptionsBase>(key: K): Required<OptionsBase>[K] {\n    switch (key) {\n        case \"preserveNull\":\n            return false;\n    }\n    // never reached\n    return null as any;\n}\n\nexport function getOptionValue<K extends keyof OptionsBase>(\n    key: K,\n    options?: OptionsBase,\n): Required<OptionsBase>[K] {\n    if (options && options[key] != null) return options[key]!;\n    return getDefaultOptionOf(key);\n}\n\nexport function mergeOptions(\n    existing?: OptionsBase,\n    moreSpecific?: OptionsBase,\n): OptionsBase|undefined {\n    return !moreSpecific\n        ? existing\n        : Object.assign(\n            {},\n            existing,\n            moreSpecific,\n        );\n}\n","import { nameof, logError, isValueDefined, isInstanceOf, isTypeTypedArray, isDirectlySerializableNativeType } from \"./helpers\";\nimport { IndexedObject } from \"./types\";\nimport { JsonObjectMetadata } from \"./metadata\";\nimport { getOptionValue, mergeOptions, OptionsBase } from \"./options-base\";\n\nexport interface IScopeTypeInfo\n{\n    selfType: Function;\n    elementTypes?: Function[];\n    keyType?: Function;\n}\n\nexport interface IScopeArrayTypeInfo extends IScopeTypeInfo\n{\n    selfType: new () => Array<any>;\n    elementTypes: Function[];\n}\n\nfunction isArrayTypeInfo(typeInfo: IScopeTypeInfo): typeInfo is IScopeArrayTypeInfo {\n    return typeInfo.selfType === Array;\n}\n\nexport interface IScopeSetTypeInfo extends IScopeTypeInfo\n{\n    selfType: new () => Set<any>;\n    elementTypes: [Function];\n}\n\nfunction isSetTypeInfo(typeInfo: IScopeTypeInfo): typeInfo is IScopeSetTypeInfo {\n    return typeInfo.selfType === Set;\n}\n\nexport interface IScopeMapTypeInfo extends IScopeTypeInfo\n{\n    selfType: new () => Map<any, any>;\n    elementTypes: [Function];\n    keyType: Function;\n}\n\nfunction isMapTypeInfo(typeInfo: IScopeTypeInfo): typeInfo is IScopeMapTypeInfo {\n    return typeInfo.selfType === Map;\n}\n\n/**\n * Utility class, converts a typed object tree (i.e. a tree of class instances, arrays of class instances, and so on) to an untyped javascript object (also\n * called \"simple javascript object\"), and emits any necessary type hints in the process (for polymorphism).\n *\n * The converted object tree is what will be given to `JSON.stringify` to convert to string as the last step, the serialization is basically like:\n *\n * (1) typed object-tree -> (2) simple JS object-tree -> (3) JSON-string\n */\nexport class Serializer\n{\n    public options?: OptionsBase;\n    private _typeHintEmitter: (targetObject: IndexedObject, sourceObject: IndexedObject, expectedSourceType: Function, sourceTypeMetadata?: JsonObjectMetadata) => void;\n    private _errorHandler: (error: Error) => void;\n\n    constructor()\n    {\n        this._typeHintEmitter = (targetObject, sourceObject, expectedSourceType, sourceTypeMetadata?: JsonObjectMetadata) =>\n        {\n            // By default, we put a \"__type\" property on the output object if the actual object is not the same as the expected one, so that deserialization\n            // will know what to deserialize into (given the required known-types are defined, and the object is a valid subtype of the expected type).\n            if (sourceObject.constructor !== expectedSourceType)\n            {\n                const name = sourceTypeMetadata && sourceTypeMetadata.name\n                    ? sourceTypeMetadata.name\n                    : nameof(sourceObject.constructor);\n                // TODO: Perhaps this can work correctly without string-literal access?\n                // tslint:disable-next-line:no-string-literal\n                targetObject[\"__type\"] = name;\n            }\n        };\n\n        this._errorHandler = (error) => logError(error);\n    }\n\n    public setTypeHintEmitter(typeEmitterCallback: (targetObject: Object, sourceObject: Object, expectedSourceType: Function) => void)\n    {\n        if (typeof typeEmitterCallback !== \"function\")\n        {\n            throw new TypeError(\"'typeEmitterCallback' is not a function.\");\n        }\n\n        this._typeHintEmitter = typeEmitterCallback;\n    }\n\n    public setErrorHandler(errorHandlerCallback: (error: Error) => void)\n    {\n        if (typeof errorHandlerCallback !== \"function\")\n        {\n            throw new TypeError(\"'errorHandlerCallback' is not a function.\");\n        }\n\n        this._errorHandler = errorHandlerCallback;\n    }\n\n    /**\n     * Convert a value of any supported serializable type.\n     * The value type will be detected, and the correct serialization method will be called.\n     */\n    public convertSingleValue(\n        sourceObject: any,\n        typeInfo: IScopeTypeInfo,\n        memberName: string = \"object\",\n        memberOptions?: OptionsBase,\n    ): any {\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) return null;\n        if (!isValueDefined(sourceObject)) return;\n\n        if (!isInstanceOf(sourceObject, typeInfo.selfType))\n        {\n            let expectedName = nameof(typeInfo.selfType);\n            let actualName = nameof(sourceObject.constructor);\n\n            this._errorHandler(new TypeError(\n                `Could not serialize '${memberName}': expected '${expectedName}', got '${actualName}'.`),\n            );\n            return;\n        }\n\n        if (isDirectlySerializableNativeType(typeInfo.selfType))\n        {\n            return sourceObject;\n        }\n        else if (typeInfo.selfType === ArrayBuffer)\n        {\n            return this.convertAsArrayBuffer(sourceObject);\n        }\n        else if (typeInfo.selfType === DataView)\n        {\n            return this.convertAsDataView(sourceObject);\n        }\n        else if (isArrayTypeInfo(typeInfo))\n        {\n            return this.convertAsArray(sourceObject, typeInfo.elementTypes, memberName, memberOptions);\n        }\n        else if (isSetTypeInfo(typeInfo))\n        {\n            return this.convertAsSet(sourceObject, typeInfo.elementTypes[0], memberName, memberOptions);\n        }\n        else if (isMapTypeInfo(typeInfo))\n        {\n            return this.convertAsMap(sourceObject, typeInfo.keyType, typeInfo.elementTypes[0], memberName, memberOptions);\n        }\n        else if (isTypeTypedArray(typeInfo.selfType))\n        {\n            return this.convertAsTypedArray(sourceObject);\n        }\n        else if (typeof sourceObject === \"object\")\n        {\n            return this.convertAsObject(sourceObject, typeInfo, memberName, memberOptions);\n        }\n    }\n\n    /**\n     * Performs the conversion of a typed object (usually a class instance) to a simple\n     * javascript object for serialization.\n     */\n    public convertAsObject(\n        sourceObject: IndexedObject,\n        typeInfo: IScopeTypeInfo,\n        memberName?: string,\n        memberOptions?: OptionsBase,\n    ) {\n        let sourceTypeMetadata: JsonObjectMetadata|undefined;\n        let targetObject: IndexedObject;\n\n        if (sourceObject.constructor !== typeInfo.selfType && sourceObject instanceof typeInfo.selfType)\n        {\n            // The source object is not of the expected type, but it is a valid subtype.\n            // This is OK, and we'll proceed to gather object metadata from the subtype instead.\n            sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(sourceObject.constructor);\n        }\n        else\n        {\n            sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(typeInfo.selfType);\n        }\n\n        if (sourceTypeMetadata)\n        {\n\n            if (sourceTypeMetadata.beforeSerializationMethodName) {\n                // check for member first\n                if (typeof (sourceObject as any)[sourceTypeMetadata.beforeSerializationMethodName] === \"function\")\n                {\n                    (sourceObject as any)[sourceTypeMetadata.beforeSerializationMethodName]();\n                }\n                // check for static\n                else if (typeof (sourceObject.constructor as any)[sourceTypeMetadata.beforeSerializationMethodName] === \"function\")\n                {\n                    (sourceObject.constructor as any)[sourceTypeMetadata.beforeSerializationMethodName]();\n                }\n                else \n                {\n                    this._errorHandler(new TypeError(\n                        `beforeSerialization callback '${nameof(sourceTypeMetadata.classType)}.${sourceTypeMetadata.beforeSerializationMethodName}' is not a method.`\n                    ))\n                }\n            }\n\n            const sourceMeta = sourceTypeMetadata;\n            // Strong-typed serialization available.\n            // We'll serialize by members that have been marked with @jsonMember (including array/set/map members),\n            // and perform recursive conversion on each of them. The converted objects are put on the 'targetObject',\n            // which is what will be put into 'JSON.stringify' finally.\n            targetObject = {};\n\n            const classOptions = mergeOptions(this.options, sourceMeta.options);\n\n            sourceMeta.dataMembers.forEach((memberMetadata) =>\n            {\n                const memberOptions = mergeOptions(classOptions, memberMetadata.options);\n                let serialized;\n                if (memberMetadata.serializer) {\n                    serialized = memberMetadata.serializer(sourceObject[memberMetadata.key]);\n                } else if (memberMetadata.ctor) {\n                    serialized = this.convertSingleValue(\n                        sourceObject[memberMetadata.key],\n                        {\n                            selfType: memberMetadata.ctor,\n                            elementTypes: memberMetadata.elementType,\n                            keyType: memberMetadata.keyType,\n                        },\n                        `${nameof(sourceMeta.classType)}.${memberMetadata.key}`,\n                        memberOptions,\n                    );\n                } else {\n                    throw new TypeError(\n                        `Could not serialize ${memberMetadata.name}, there is`\n                        + ` no constructor nor serialization function to use.`,\n                    );\n                }\n\n                if (isValueDefined(serialized)\n                    || (this.retrievePreserveNull(memberOptions) && serialized === null)\n                ) {\n                    targetObject[memberMetadata.name] = serialized;\n                }\n            });\n        }\n        else\n        {\n            // Untyped serialization, \"as-is\", we'll just pass the object on.\n            // We'll clone the source object, because type hints are added to the object itself, and we don't want to modify to the original object.\n            targetObject = { ...sourceObject };\n        }\n\n        // Add type-hint.\n        this._typeHintEmitter(targetObject, sourceObject, typeInfo.selfType, sourceTypeMetadata);\n\n        return targetObject;\n    }\n\n    /**\n     * Performs the conversion of an array of typed objects (or primitive values) to an array of simple javascript objects (or primitive values) for\n     * serialization.\n     * @param expectedElementType The expected type of elements. If the array is supposed to be multi-dimensional, subsequent elements define lower dimensions.\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     */\n    public convertAsArray(\n        sourceObject: any[],\n        expectedElementType: Function[],\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): any[] {\n        if (expectedElementType.length === 0 || !expectedElementType[0])\n           throw new TypeError(`Could not serialize ${memberName} as Array: missing element type definition.`);\n\n        // Check the type of each element, individually.\n        // If at least one array element type is incorrect, we return undefined, which results in no\n        // value emitted during serialization. This is so that invalid element types don't unexpectedly\n        // alter the ordering of other, valid elements, and that no unexpected undefined values are in\n        // the emitted array.\n        sourceObject.forEach((element, i) =>\n        {\n            if (!(this.retrievePreserveNull(memberOptions) && element === null)\n                && !isInstanceOf(element, expectedElementType[0])\n            ) {\n                const expectedTypeName = nameof(expectedElementType[0]);\n                const actualTypeName = element && nameof(element.constructor);\n                throw new TypeError(`Could not serialize ${memberName}[${i}]:` +\n                    ` expected '${expectedTypeName}', got '${actualTypeName}'.`);\n            }\n        });\n\n        const typeInfoForElements: IScopeTypeInfo = {\n            selfType: expectedElementType[0],\n            // For multidimensional arrays.\n            elementTypes: expectedElementType.length > 1 ? expectedElementType.slice(1) : [],\n        };\n\n        if (memberName)\n        {\n            // Just for debugging purposes.\n            memberName += \"[]\";\n        }\n\n        return sourceObject.map(\n            element => this.convertSingleValue(\n                element, typeInfoForElements, memberName, memberOptions\n            ),\n        );\n    }\n\n    /**\n     * Performs the conversion of a set of typed objects (or primitive values) into an array\n     * of simple javascript objects.\n     *\n     * @param sourceObject\n     * @param expectedElementType The constructor of the expected Set elements\n     *        (e.g. `Number` for `Set<number>`, or `MyClass` for `Set<MyClass>`).\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     * @returns\n     */\n    public convertAsSet(\n        sourceObject: Set<any>,\n        expectedElementType: Function,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): any[] {\n        if (!expectedElementType)\n            throw new TypeError(`Could not serialize ${memberName} as Set: missing element type definition.`);\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            selfType: expectedElementType,\n        };\n\n        // For debugging and error tracking.\n        if (memberName) memberName += \"[]\";\n\n        let resultArray: any[] = [];\n\n        // Convert each element of the set, and put it into an output array.\n        // The output array is the one serialized, as JSON.stringify does not support Set serialization.\n        // (TODO: clarification needed)\n        sourceObject.forEach(element =>\n        {\n            let resultElement = this.convertSingleValue(element, elementTypeInfo, memberName, memberOptions);\n\n            // Add to output if the source element was undefined, OR the converted element is defined.\n            // This will add intentionally undefined values to output, but not values that became undefined\n            // DURING serializing (usually because of a type-error).\n            if (!isValueDefined(element) || isValueDefined(resultElement))\n            {\n                resultArray.push(resultElement);\n            }\n        });\n\n        return resultArray;\n    }\n\n    /**\n     * Performs the conversion of a map of typed objects (or primitive values) into an array\n     * of simple javascript objects with `key` and `value` properties.\n     *\n     * @param sourceObject\n     * @param expectedKeyType The constructor of the expected Map keys\n     *        (e.g. `Number` for `Map<number, any>`, or `MyClass` for `Map<MyClass, any>`).\n     * @param expectedElementType The constructor of the expected Map values\n     *        (e.g. `Number` for `Map<any, number>`, or `MyClass` for `Map<any, MyClass>`).\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     */\n    public convertAsMap(\n        sourceObject: Map<any, any>,\n        expectedKeyType: Function,\n        expectedElementType: Function,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): Array<{ key: any, value: any }> {\n        if (!expectedElementType)\n            throw new TypeError(`Could not serialize ${memberName} as Map: missing value type definition.`);\n\n        if (!expectedKeyType)\n            throw new TypeError(`Could not serialize ${memberName} as Map: missing key type definition.`);\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            selfType: expectedElementType,\n            elementTypes: [expectedElementType]\n        };\n\n        let keyTypeInfo: IScopeTypeInfo = {\n            selfType: expectedKeyType\n        };\n\n        if (memberName) memberName += \"[]\";\n\n        const resultArray: Array<{ key: any, value: any }> = [];\n        const preserveNull = this.retrievePreserveNull(memberOptions);\n\n        // Convert each *entry* in the map to a simple javascript object with key and value properties.\n        sourceObject.forEach((value, key) =>\n        {\n            let resultKeyValuePairObj = {\n                key: this.convertSingleValue(key, keyTypeInfo, memberName, memberOptions),\n                value: this.convertSingleValue(value, elementTypeInfo, memberName, memberOptions),\n            };\n\n            // We are not going to emit entries with undefined keys OR undefined values.\n            const keyDefined = isValueDefined(resultKeyValuePairObj.key);\n            const valueDefined = isValueDefined(resultKeyValuePairObj.value)\n                || (resultKeyValuePairObj.value === null && preserveNull);\n            if (keyDefined && valueDefined)\n            {\n                resultArray.push(resultKeyValuePairObj);\n            }\n        });\n\n        return resultArray;\n    }\n\n    /**\n     * Performs the conversion of a typed javascript array to a simple untyped javascript array.\n     * This is needed because typed arrays are otherwise serialized as objects, so we'll end up\n     * with something like \"{ 0: 0, 1: 1, ... }\".\n     *\n     * @param sourceObject\n     * @returns\n     */\n    public convertAsTypedArray(sourceObject: ArrayBufferView)\n    {\n        return Array.from(sourceObject as any);\n    }\n\n    /**\n     * Performs the conversion of a raw ArrayBuffer to a string.\n     */\n    public convertAsArrayBuffer(buffer: ArrayBuffer)\n    {\n        // ArrayBuffer -> 16-bit character codes -> character array -> joined string.\n        return Array.from(new Uint16Array(buffer)).map(charCode => String.fromCharCode(charCode)).join(\"\");\n    }\n\n    /**\n     * Performs the conversion of DataView, converting its internal ArrayBuffer to a string and\n     * returning that string.\n     */\n    public convertAsDataView(dataView: DataView)\n    {\n        return this.convertAsArrayBuffer(dataView.buffer);\n    }\n\n    private retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n}\n","import { nameof, logError, isSubtypeOf, isValueDefined } from \"./helpers\";\nimport { IndexedObject } from \"./types\";\nimport { JsonObjectMetadata } from \"./metadata\";\nimport { getOptionValue, mergeOptions, OptionsBase } from \"./options-base\";\n\nexport interface IScopeTypeInfo\n{\n    selfConstructor: Function;\n    elementConstructor?: Function[];\n    keyConstructor?: Function;\n    knownTypes: Map<string, Function>;\n}\n\n/**\n * Utility class, converts a simple/untyped javascript object-tree to a typed object-tree.\n * It is used after parsing a JSON-string.\n */\nexport class Deserializer<T>\n{\n    public options?: OptionsBase;\n    private _typeResolver: (sourceObject: Object, knownTypes: Map<string, Function>) => Function|undefined;\n    private _nameResolver?: (ctor: Function) => string;\n    private _errorHandler: (error: Error) => void;\n\n    constructor()\n    {\n        this._typeResolver = (sourceObject: any, knownTypes: Map<string, Function>) =>\n        {\n            if (sourceObject.__type) return knownTypes.get(sourceObject.__type);\n        };\n\n        this._errorHandler = (error) => logError(error);\n    }\n\n    public setNameResolver(nameResolverCallback: (ctor: Function) => string)\n    {\n        this._nameResolver = nameResolverCallback;\n    }\n\n    public setTypeResolver(typeResolverCallback: (sourceObject: Object, knownTypes: Map<string, Function>) => Function)\n    {\n        if (typeof typeResolverCallback !== \"function\") throw new TypeError(\"'typeResolverCallback' is not a function.\");\n\n        this._typeResolver = typeResolverCallback;\n    }\n\n    public setErrorHandler(errorHandlerCallback: (error: Error) => void)\n    {\n        if (typeof errorHandlerCallback !== \"function\")\n        {\n            throw new TypeError(\"'errorHandlerCallback' is not a function.\");\n        }\n\n        this._errorHandler = errorHandlerCallback;\n    }\n\n    public convertAsObject(\n        sourceObject: IndexedObject,\n        sourceObjectTypeInfo: IScopeTypeInfo,\n        objectName = \"object\",\n        memberOptions?: OptionsBase,\n    ) {\n        if (typeof sourceObject !== \"object\" || sourceObject === null)\n        {\n            this._errorHandler(new TypeError(`Cannot deserialize ${objectName}: 'sourceObject' must be a defined object.`));\n            return undefined;\n        }\n\n        let expectedSelfType = sourceObjectTypeInfo.selfConstructor;\n        let sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(expectedSelfType);\n        let knownTypeConstructors = sourceObjectTypeInfo.knownTypes;\n\n        if (sourceObjectMetadata)\n        {\n            // Merge known types received from \"above\" with known types defined on the current type.\n            knownTypeConstructors = this._mergeKnownTypes(\n                knownTypeConstructors,\n                this._createKnownTypesMap(sourceObjectMetadata.knownTypes),\n            );\n        }\n\n        // Check if a type-hint is available from the source object.\n        let typeFromTypeHint = this._typeResolver(sourceObject, knownTypeConstructors);\n\n        if (typeFromTypeHint)\n        {\n            // Check if type hint is a valid subtype of the expected source type.\n            if (isSubtypeOf(typeFromTypeHint, expectedSelfType))\n            {\n                // Hell yes.\n                expectedSelfType = typeFromTypeHint;\n                sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(typeFromTypeHint);\n\n                if (sourceObjectMetadata)\n                {\n                    // Also merge new known types from subtype.\n                    knownTypeConstructors = this._mergeKnownTypes(\n                        knownTypeConstructors,\n                        this._createKnownTypesMap(sourceObjectMetadata.knownTypes),\n                    );\n                }\n            }\n        }\n\n        if (sourceObjectMetadata && sourceObjectMetadata.isExplicitlyMarked)\n        {\n            const sourceMetadata = sourceObjectMetadata;\n            // Strong-typed deserialization available, get to it.\n            // First deserialize properties into a temporary object.\n            const sourceObjectWithDeserializedProperties = {} as IndexedObject;\n\n            const classOptions = mergeOptions(this.options, sourceMetadata.options);\n\n            // Deserialize by expected properties.\n            sourceMetadata.dataMembers.forEach((memberMetadata, propKey) =>\n            {\n                const memberValue = sourceObject[propKey];\n                const memberNameForDebug = `${nameof(sourceMetadata.classType)}.${propKey}`;\n                const memberOptions = mergeOptions(classOptions, memberMetadata.options);\n\n                let revivedValue;\n                if (memberMetadata.deserializer) {\n                    revivedValue = memberMetadata.deserializer(memberValue);\n                } else if (memberMetadata.ctor) {\n                    revivedValue = this.convertSingleValue(\n                        memberValue,\n                        {\n                            selfConstructor: memberMetadata.ctor,\n                            elementConstructor: memberMetadata.elementType,\n                            keyConstructor: memberMetadata.keyType,\n                            knownTypes: knownTypeConstructors\n                        },\n                        memberNameForDebug,\n                        memberOptions,\n                    );\n                } else {\n                    throw new TypeError(\n                        `Cannot deserialize ${memberNameForDebug} thers is`\n                        + ` no constructor nor deserlization function to use.`,\n                    );\n                }\n\n                if (isValueDefined(revivedValue)\n                    || (this.retrievePreserveNull(memberOptions) && revivedValue === null)\n                ) {\n                    sourceObjectWithDeserializedProperties[memberMetadata.key] = revivedValue;\n                }\n                else if (memberMetadata.isRequired)\n                {\n                    this._errorHandler(new TypeError(`Missing required member '${memberNameForDebug}'.`));\n                }\n            });\n\n            // Next, instantiate target object.\n            let targetObject: IndexedObject;\n\n            if (typeof sourceObjectMetadata.initializerCallback === \"function\")\n            {\n                try\n                {\n                    targetObject = sourceObjectMetadata.initializerCallback(\n                        sourceObjectWithDeserializedProperties,\n                        sourceObject,\n                    );\n\n                    // Check the validity of user-defined initializer callback.\n                    if (!targetObject)\n                    {\n                        throw new TypeError(\n                            `Cannot deserialize ${objectName}:`\n                            + ` 'initializer' function returned undefined/null`\n                            + `, but '${nameof(sourceObjectMetadata.classType)}' was expected.`,\n                        );\n                    }\n                    else if (!(targetObject instanceof sourceObjectMetadata.classType))\n                    {\n                        throw new TypeError(\n                            `Cannot deserialize ${objectName}:`\n                            + `'initializer' returned '${nameof(targetObject.constructor)}'`\n                            + `, but '${nameof(sourceObjectMetadata.classType)}' was expected`\n                            + `, and '${nameof(targetObject.constructor)}' is not a subtype of`\n                            + ` '${nameof(sourceObjectMetadata.classType)}'`,\n                        );\n                    }\n                }\n                catch (e)\n                {\n                    this._errorHandler(e);\n                    return undefined;\n                }\n            }\n            else\n            {\n                targetObject = this._instantiateType(expectedSelfType);\n            }\n\n            // Finally, assign deserialized properties to target object.\n            Object.assign(targetObject, sourceObjectWithDeserializedProperties);\n\n            // Call onDeserialized method (if any).\n            if (sourceObjectMetadata.onDeserializedMethodName)\n            {\n                // check for member first\n                if (typeof (targetObject as any)[sourceObjectMetadata.onDeserializedMethodName] === \"function\")\n                {\n                    (targetObject as any)[sourceObjectMetadata.onDeserializedMethodName]();\n                }\n                // check for static\n                else if (typeof (targetObject.constructor as any)[sourceObjectMetadata.onDeserializedMethodName] === \"function\")\n                {\n                    (targetObject.constructor as any)[sourceObjectMetadata.onDeserializedMethodName]();\n                }\n                else\n                {\n                    this._errorHandler(new TypeError(\n                        `onDeserialized callback '${nameof(sourceObjectMetadata.classType)}.${sourceObjectMetadata.onDeserializedMethodName}' is not a method.`\n                    ));\n                }\n            }\n\n            return targetObject;\n        }\n        else\n        {\n            // Untyped deserialization into Object instance.\n            let targetObject = {} as IndexedObject;\n\n            Object.keys(sourceObject).forEach(sourceKey =>\n            {\n                targetObject[sourceKey] = this.convertSingleValue(sourceObject[sourceKey], {\n                    selfConstructor: sourceObject[sourceKey].constructor,\n                    knownTypes: sourceObjectTypeInfo.knownTypes,\n                    elementConstructor: sourceObjectTypeInfo.elementConstructor,\n                    keyConstructor: sourceObjectTypeInfo.keyConstructor\n                }, sourceKey);\n            });\n\n            return targetObject;\n        }\n    }\n\n    public convertSingleValue(\n        sourceObject: any,\n        typeInfo: IScopeTypeInfo,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ) {\n        let expectedSelfType = typeInfo.selfConstructor;\n        let srcTypeNameForDebug = sourceObject ? nameof(sourceObject.constructor) : \"undefined\";\n\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null)\n        {\n            return null;\n        }\n        else if (!isValueDefined(sourceObject))\n        {\n            return;\n        }\n        else if (this._isDirectlyDeserializableNativeType(expectedSelfType))\n        {\n            if (sourceObject.constructor === expectedSelfType)\n            {\n                return sourceObject;\n            }\n            else\n            {\n                throw new TypeError(this._makeTypeErrorMessage(nameof(expectedSelfType), sourceObject.constructor, memberName));\n            }\n        }\n        else if (expectedSelfType === Date)\n        {\n            // Support for Date with ISO 8601 format, or with numeric timestamp (milliseconds elapsed since the Epoch).\n            // ISO 8601 spec.: https://www.w3.org/TR/NOTE-datetime\n\n            if (typeof sourceObject === \"string\" || (typeof sourceObject === \"number\" && sourceObject > 0))\n                return new Date(sourceObject as any);\n            else\n                this._throwTypeMismatchError(\"Date\", \"an ISO-8601 string\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Float32Array)\n        {\n            // Deserialize Float32Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Float32Array(sourceObject);\n            else\n                this._throwTypeMismatchError(\"Float32Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Float64Array)\n        {\n            // Deserialize Float64Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Float64Array(sourceObject);\n            else\n                this._throwTypeMismatchError(\"Float64Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint8Array)\n        {\n            // Deserialize Uint8Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Uint8Array(sourceObject.map(value => ~~value));\n            else\n                this._throwTypeMismatchError(\"Uint8Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint8ClampedArray)\n        {\n            // Deserialize Uint8Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Uint8ClampedArray(sourceObject.map(value => ~~value));\n            else\n                this._throwTypeMismatchError(\"Uint8ClampedArray\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint16Array)\n        {\n            // Deserialize Uint16Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Uint16Array(sourceObject.map(value => ~~value));\n            else\n                this._throwTypeMismatchError(\"Uint16Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Uint32Array)\n        {\n            // Deserialize Uint32Array from number[].\n\n            if (sourceObject instanceof Array && sourceObject.every(elem => !isNaN(elem)))\n                return new Uint32Array(sourceObject.map(value => ~~value));\n            else\n                this._throwTypeMismatchError(\"Uint32Array\", \"a numeric source array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === ArrayBuffer)\n        {\n            if (typeof sourceObject === \"string\")\n                return this._stringToArrayBuffer(sourceObject);\n            else\n                this._throwTypeMismatchError(\"ArrayBuffer\", \"a string source\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === DataView)\n        {\n            if (typeof sourceObject === \"string\")\n                return this._stringToDataView(sourceObject);\n            else\n                this._throwTypeMismatchError(\"DataView\", \"a string source\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Array)\n        {\n            if (sourceObject instanceof Array)\n                return this.convertAsArray(sourceObject, typeInfo, memberName, memberOptions);\n            else\n                throw new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName));\n        }\n        else if (expectedSelfType === Set)\n        {\n            if (sourceObject instanceof Array)\n                return this.convertAsSet(sourceObject, typeInfo, memberName, memberOptions);\n            else\n                this._throwTypeMismatchError(\"Set\", \"Array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType === Map)\n        {\n            if (sourceObject instanceof Array)\n                return this.convertAsMap(sourceObject, typeInfo, memberName, memberOptions);\n            else\n                this._throwTypeMismatchError(\"Map\", \"a source array of key-value-pair objects\", srcTypeNameForDebug, memberName);\n        }\n        else if (sourceObject && typeof sourceObject === \"object\")\n        {\n            return this.convertAsObject(sourceObject, typeInfo, memberName, memberOptions);\n        }\n    }\n\n    public convertAsArray(\n        sourceObject: any,\n        typeInfo: IScopeTypeInfo,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): any[] {\n        if (!(sourceObject instanceof Array))\n        {\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n            return [];\n        }\n\n        if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Array: missing constructor reference of Array elements.`));\n            return [];\n        }\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            selfConstructor: typeInfo.elementConstructor[0],\n            elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n\n        return sourceObject.map(element =>\n        {\n            // If an array element fails to deserialize, substitute with undefined. This is so that the original ordering is not interrupted by faulty\n            // entries, as an Array is ordered.\n            try\n            {\n                return this.convertSingleValue(element, elementTypeInfo, `${memberName}[]`, memberOptions);\n            }\n            catch (e)\n            {\n                this._errorHandler(e);\n\n                // Keep filling the array here with undefined to keep original ordering.\n                // Note: this is just aesthetics, not returning anything produces the same result.\n                return undefined;\n            }\n        });\n    }\n\n    public convertAsSet(\n        sourceObject: any,\n        typeInfo: IScopeTypeInfo,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): Set<any> {\n        if (!(sourceObject instanceof Array))\n        {\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n            return new Set<any>();\n        }\n\n        if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Set: missing constructor reference of Set elements.`));\n            return new Set<any>();\n        }\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            selfConstructor: typeInfo.elementConstructor[0],\n            elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n        let resultSet = new Set<any>();\n\n        sourceObject.forEach((element, i) =>\n        {\n            try\n            {\n                resultSet.add(this.convertSingleValue(\n                    element,\n                    elementTypeInfo,\n                    `${memberName}[${i}]`,\n                    memberOptions,\n                ));\n            }\n            catch (e)\n            {\n                // Faulty entries are skipped, because a Set is not ordered, and skipping an entry\n                // does not affect others.\n                this._errorHandler(e);\n            }\n        });\n\n        return resultSet;\n    }\n\n    public convertAsMap(\n        sourceObject: any,\n        typeInfo: IScopeTypeInfo,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): Map<any, any> {\n        if (!(sourceObject instanceof Array))\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n\n        if (!typeInfo.keyConstructor)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Map: missing key constructor.`));\n            return new Map<any, any>();\n        }\n\n        if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length)\n        {\n            this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Map: missing value constructor.`));\n            return new Map<any, any>();\n        }\n\n        let keyTypeInfo: IScopeTypeInfo = {\n            selfConstructor: typeInfo.keyConstructor,\n            knownTypes: typeInfo.knownTypes\n        };\n\n        let valueTypeInfo: IScopeTypeInfo = {\n            selfConstructor: typeInfo.elementConstructor[0],\n            elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n\n        let resultMap = new Map<any, any>();\n\n        sourceObject.forEach((element: any) =>\n        {\n            try\n            {\n                let key = this.convertSingleValue(element.key, keyTypeInfo, memberName, memberOptions);\n\n                // Undefined/null keys not supported, skip if so.\n                if (isValueDefined(key))\n                {\n                    resultMap.set(\n                        key,\n                        this.convertSingleValue(\n                            element.value,\n                            valueTypeInfo,\n                            `${memberName}[${key}]`,\n                            memberOptions,\n                        ),\n                    );\n                }\n            }\n            catch (e)\n            {\n                // Faulty entries are skipped, because a Map is not ordered,\n                // and skipping an entry does not affect others.\n                this._errorHandler(e);\n            }\n        });\n\n        return resultMap;\n    }\n\n    private _throwTypeMismatchError(\n        targetType: string,\n        expectedSourceType: string,\n        actualSourceType: string,\n        memberName: string = \"object\",\n    ) {\n        throw new TypeError(\n            `Could not deserialize ${memberName} as ${targetType}:`\n            + ` expected ${expectedSourceType}, got ${actualSourceType}.`,\n        );\n    }\n\n    private _makeTypeErrorMessage(expectedType: Function | string, actualType: Function | string, memberName = \"object\")\n    {\n        let expectedTypeName = (typeof expectedType === \"function\") ? nameof(expectedType) : expectedType;\n        let actualTypeName = (typeof actualType === \"function\") ? nameof(actualType) : actualType;\n\n        return `Could not deserialize ${memberName}: expected '${expectedTypeName}', got '${actualTypeName}'.`;\n    }\n\n    private _instantiateType(ctor: any)\n    {\n        return new ctor();\n    }\n\n    private _mergeKnownTypes(...knownTypeMaps: Array<Map<string, Function>>)\n    {\n        let result = new Map<string, Function>();\n\n        knownTypeMaps.forEach(knownTypes =>\n        {\n            knownTypes.forEach((ctor, name) =>\n            {\n                if (this._nameResolver)\n                {\n                    result.set(this._nameResolver(ctor), ctor);\n                }\n                else\n                {\n                    result.set(name, ctor);\n                }\n            });\n        });\n\n        return result;\n    }\n\n    private _createKnownTypesMap(knowTypes: Set<Function>)\n    {\n        const map = new Map<string, Function>();\n\n        knowTypes.forEach(ctor =>\n        {\n            if (this._nameResolver)\n            {\n                map.set(this._nameResolver(ctor), ctor);\n            }\n            else\n            {\n                const knownTypeMeta = JsonObjectMetadata.getFromConstructor(ctor);\n                const name = knownTypeMeta && knownTypeMeta.isExplicitlyMarked && knownTypeMeta.name\n                    ? knownTypeMeta.name\n                    : ctor.name;\n                map.set(name, ctor);\n            }\n        });\n\n        return map;\n    }\n\n    private _isDirectlyDeserializableNativeType(ctor: any)\n    {\n        return ~([Number, String, Boolean].indexOf(ctor));\n    }\n\n    public convertNativeObject(sourceObject: any)\n    {\n        return sourceObject;\n    }\n\n    private _stringToArrayBuffer(str: string)\n    {\n        let buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n        let bufView = new Uint16Array(buf);\n\n        for (let i = 0, strLen = str.length; i < strLen; i++)\n        {\n            bufView[i] = str.charCodeAt(i);\n        }\n\n        return buf;\n    }\n\n    private _stringToDataView(str: string)\n    {\n        return new DataView(this._stringToArrayBuffer(str));\n    }\n\n    private retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n}\n","import { Constructor, IndexedObject } from \"./typedjson/types\";\nimport { Serializer } from \"./typedjson/serializer\";\nimport { Deserializer } from \"./typedjson/deserializer\";\nimport { JsonObjectMetadata } from \"./typedjson/metadata\";\nimport { logError, logWarning, nameof, parseToJSObject } from \"./typedjson/helpers\";\nimport { extractOptionBase, OptionsBase } from \"./typedjson/options-base\";\n\nexport type JsonTypes = Object|boolean|string|number|null|undefined;\n\nexport interface ITypedJSONSettings extends OptionsBase\n{\n    /**\n     * Sets the handler callback to invoke on errors during serializing and deserializing.\n     * Re-throwing errors in this function will halt serialization/deserialization.\n     * The default behavior is to log errors to the console.\n     */\n    errorHandler?: (e: Error) => void;\n\n    /**\n     * Sets a callback that determines the constructor of the correct sub-type of polymorphic\n     * objects while deserializing.\n     * The default behavior is to read the type-name from the '__type' property of 'sourceObject',\n     * and look it up in 'knownTypes'.\n     * The constructor of the sub-type should be returned.\n     */\n    typeResolver?: (sourceObject: Object, knownTypes: Map<string, Function>) => Function;\n\n    nameResolver?: (ctor: Function) => string;\n\n    /**\n     * Sets a callback that writes type-hints to serialized objects.\n     * The default behavior is to write the type-name to the '__type' property, if a derived type\n     * is present in place of a base type.\n     */\n    typeHintEmitter?:\n        (targetObject: Object, sourceObject: Object, expectedSourceType: Function) => void;\n\n    /**\n     * Sets the amount of indentation to use in produced JSON strings.\n     * Default value is 0, or no indentation.\n     */\n    indent?: number;\n\n    replacer?: (key: string, value: any) => any;\n\n    knownTypes?: Array<Constructor<any>>;\n}\n\nexport class TypedJSON<T>\n{\n    //#region Static\n    public static parse<T>(\n        object: any, rootType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): T|undefined {\n        return new TypedJSON(rootType, settings).parse(object);\n    }\n\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: 1\n    ): T[];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 2\n    ): T[][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 3\n    ): T[][][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 4\n    ): T[][][][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 5\n    ): T[][][][][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: number\n    ): any[] {\n        return new TypedJSON(elementType, settings).parseAsArray(object, dimensions as any);\n    }\n\n    public static parseAsSet<T>(\n        object: any, elementType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): Set<T> {\n        return new TypedJSON(elementType, settings).parseAsSet(object);\n    }\n\n    public static parseAsMap<K, V>(\n        object: any,\n        keyType: Constructor<K>,\n        valueType: Constructor<V>,\n        settings?: ITypedJSONSettings,\n    ): Map<K, V> {\n        return new TypedJSON(valueType, settings).parseAsMap(object, keyType);\n    }\n\n    public static toPlainJson<T>(\n        object: T, rootType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): JsonTypes {\n        return new TypedJSON(rootType, settings).toPlainJson(object);\n    }\n\n    public static toPlainArray<T>(\n        object: T[], elementType: Constructor<T>, dimensions?: 1, settings?: ITypedJSONSettings,\n    ): Object[];\n    public static toPlainArray<T>(\n        object: T[][], elementType: Constructor<T>, dimensions: 2, settings?: ITypedJSONSettings,\n    ): Object[][];\n    public static toPlainArray<T>(\n        object: T[][][], elementType: Constructor<T>, dimensions: 3, settings?: ITypedJSONSettings,\n    ): Object[][][];\n    public static toPlainArray<T>(\n        object: T[][][][], elementType: Constructor<T>, dimensions: 4, settings?: ITypedJSONSettings,\n    ): Object[][][][];\n    public static toPlainArray<T>(\n        object: T[][][][][], elementType: Constructor<T>, dimensions: 5, settings?: ITypedJSONSettings,\n    ): Object[][][][][];\n    public static toPlainArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions: number, settings?: ITypedJSONSettings,\n    ): any[];\n    public static toPlainArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions?: any, settings?: ITypedJSONSettings,\n    ): any[] {\n        return new TypedJSON(elementType, settings).toPlainArray(object, dimensions);\n    }\n\n    public static toPlainSet<T>(\n        object: Set<T>, elementType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): Object[]|undefined {\n        return new TypedJSON(elementType, settings).toPlainSet(object);\n    }\n\n    public static toPlainMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Constructor<K>,\n        valueCtor: Constructor<V>,\n        settings?: ITypedJSONSettings,\n    ): { key: any, value: any }[]|undefined {\n        return new TypedJSON(valueCtor, settings).toPlainMap(object, keyCtor);\n    }\n\n    public static stringify<T>(\n        object: T, rootType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(rootType, settings).stringify(object);\n    }\n\n    public static stringifyAsArray<T>(\n        object: T[], elementType: Constructor<T>, dimensions?: 1, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][], elementType: Constructor<T>, dimensions: 2, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][][], elementType: Constructor<T>, dimensions: 3, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][][][], elementType: Constructor<T>, dimensions: 4, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][][][][], elementType: Constructor<T>, dimensions: 5, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions: number, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions?: any, settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(elementType, settings).stringifyAsArray(object, dimensions);\n    }\n\n    public static stringifyAsSet<T>(\n        object: Set<T>, elementType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(elementType, settings).stringifyAsSet(object);\n    }\n\n    public static stringifyAsMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Constructor<K>,\n        valueCtor: Constructor<V>,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(valueCtor, settings).stringifyAsMap(object, keyCtor);\n    }\n\n    private static _globalConfig: ITypedJSONSettings;\n\n    public static setGlobalConfig(config: ITypedJSONSettings)\n    {\n        if (this._globalConfig)\n        {\n            Object.assign(this._globalConfig, config);\n        }\n        else\n        {\n            this._globalConfig = config;\n        }\n    }\n\n    //#endregion\n\n    private serializer: Serializer = new Serializer();\n    private deserializer: Deserializer<T> = new Deserializer<T>();\n    private globalKnownTypes: Array<Constructor<any>> = [];\n    private indent: number = 0;\n    private rootConstructor: Constructor<T>;\n    private errorHandler: (e: Error) => void;\n    private nameResolver: (ctor: Function) => string;\n    private replacer?: (key: string, value: any) => any;\n\n    /**\n     * Creates a new TypedJSON instance to serialize (stringify) and deserialize (parse) object\n     *     instances of the specified root class type.\n     * @param rootType The constructor of the root class type.\n     * @param settings Additional configuration settings.\n     */\n    constructor(rootConstructor: Constructor<T>, settings?: ITypedJSONSettings)\n    {\n        let rootMetadata = JsonObjectMetadata.getFromConstructor(rootConstructor);\n\n        if (!rootMetadata || (!rootMetadata.isExplicitlyMarked && !rootMetadata.isHandledWithoutAnnotation))\n        {\n            throw new TypeError(\"The TypedJSON root data type must have the @jsonObject decorator used.\");\n        }\n\n        this.nameResolver = (ctor) => nameof(ctor);\n        this.rootConstructor = rootConstructor;\n        this.errorHandler = (error) => logError(error);\n\n        if (settings)\n        {\n            this.config(settings);\n        }\n        else if (TypedJSON._globalConfig)\n        {\n            this.config({});\n        }\n    }\n\n    /**\n     * Configures TypedJSON through a settings object.\n     * @param settings The configuration settings object.\n     */\n    public config(settings: ITypedJSONSettings)\n    {\n        if (TypedJSON._globalConfig)\n        {\n            settings = {\n                ...TypedJSON._globalConfig,\n                ...settings\n            };\n\n            if (settings.knownTypes && TypedJSON._globalConfig.knownTypes)\n            {\n                // Merge known-types (also de-duplicate them, so Array -> Set -> Array).\n                settings.knownTypes = Array.from(new Set(\n                    settings.knownTypes.concat(TypedJSON._globalConfig.knownTypes),\n                ));\n            }\n        }\n\n        const options = extractOptionBase(settings);\n        this.serializer.options = options;\n        this.deserializer.options = options;\n\n        if (settings.errorHandler)\n        {\n            this.errorHandler = settings.errorHandler;\n            this.deserializer.setErrorHandler(settings.errorHandler);\n            this.serializer.setErrorHandler(settings.errorHandler);\n        }\n\n        if (settings.replacer) this.replacer = settings.replacer;\n        if (settings.typeResolver) this.deserializer.setTypeResolver(settings.typeResolver);\n        if (settings.typeHintEmitter) this.serializer.setTypeHintEmitter(settings.typeHintEmitter);\n        if (settings.indent) this.indent = settings.indent;\n\n        if (settings.nameResolver)\n        {\n            this.nameResolver = settings.nameResolver;\n            this.deserializer.setNameResolver(settings.nameResolver);\n            // this.serializer.set\n        }\n\n        if (settings.knownTypes)\n        {\n            // Type-check knownTypes elements to recognize errors in advance.\n            settings.knownTypes.forEach((knownType, i) =>\n            {\n                // tslint:disable-next-line:no-null-keyword\n                if (typeof knownType === \"undefined\" || knownType === null)\n                {\n                    logWarning(\n                        `TypedJSON.config: 'knownTypes' contains an undefined/null value (element ${i}).`);\n                }\n            });\n\n            this.globalKnownTypes = settings.knownTypes;\n        }\n    }\n\n    /**\n     * Converts a JSON string to the root class type.\n     * @param object The JSON to parse and convert.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns Deserialized T or undefined if there were errors.\n     */\n    public parse(object: any): T|undefined\n    {\n        const json = parseToJSObject(object, this.rootConstructor);\n\n        let rootMetadata = JsonObjectMetadata.getFromConstructor(this.rootConstructor);\n        let result: T|undefined;\n        let knownTypes = new Map<string, Function>();\n\n        this.globalKnownTypes.filter(ktc => ktc).forEach(knownTypeCtor =>\n        {\n            knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n        });\n\n        if (rootMetadata)\n        {\n            rootMetadata.knownTypes.forEach(knownTypeCtor =>\n            {\n                knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n            });\n        }\n\n        try\n        {\n            result = this.deserializer.convertSingleValue(json, {\n                selfConstructor: this.rootConstructor,\n                knownTypes: knownTypes,\n            }) as T;\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n\n        return result;\n    }\n\n    public parseAsArray(object: any, dimensions?: 1): T[];\n    public parseAsArray(object: any, dimensions: 2): T[][];\n    public parseAsArray(object: any, dimensions: 3): T[][][];\n    public parseAsArray(object: any, dimensions: 4): T[][][][];\n    public parseAsArray(object: any, dimensions: 5): T[][][][][];\n    public parseAsArray(object: any, dimensions: number): any[];\n    public parseAsArray(object: any, dimensions: number = 1): any[]\n    {\n        const json = parseToJSObject(object, Array);\n        if (json instanceof Array)\n        {\n            return this.deserializer.convertAsArray(json, {\n                selfConstructor: Array,\n                elementConstructor: new Array(dimensions - 1)\n                    .fill(Array)\n                    .concat(this.rootConstructor),\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes),\n            });\n        }\n        else\n        {\n            this.errorHandler(new TypeError(`Expected 'json' to define an Array`\n                + `, but got ${typeof json}.`));\n        }\n\n        return [];\n    }\n\n    public parseAsSet(object: any): Set<T>\n    {\n        const json = parseToJSObject(object, Set);\n        // A Set<T> is serialized as T[].\n        if (json instanceof Array)\n        {\n            return this.deserializer.convertAsSet(json, {\n                selfConstructor: Array,\n                elementConstructor: [this.rootConstructor],\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes)\n            });\n        }\n        else\n        {\n            this.errorHandler(new TypeError(`Expected 'json' to define a Set (using an Array)`\n                + `, but got ${typeof json}.`,\n            ));\n        }\n\n        return new Set<T>();\n    }\n\n    public parseAsMap<K>(object: any, keyConstructor: Constructor<K>): Map<K, T>\n    {\n        const json = parseToJSObject(object, Map);\n        // A Set<T> is serialized as T[].\n        if (json instanceof Array)\n        {\n            return this.deserializer.convertAsMap(json, {\n                selfConstructor: Array,\n                elementConstructor: [this.rootConstructor],\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes),\n                keyConstructor: keyConstructor\n            });\n        }\n        else\n        {\n            this.errorHandler(new TypeError(`Expected 'json' to define a Set (using an Array)`\n                + `, but got ${typeof json}.`,\n            ));\n        }\n\n        return new Map<K, T>();\n    }\n\n    /**\n     * Converts an instance of the specified class type to a plain JSON object.\n     * @param object The instance to convert to a JSON string.\n     * @returns Serialized object or undefined if an error has occured.\n     */\n    public toPlainJson(object: T): JsonTypes\n    {\n        try\n        {\n            return this.serializer.convertSingleValue(\n                object,\n        {selfType: this.rootConstructor},\n            );\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    public toPlainArray(object: T[], dimensions?: 1): Object[];\n    public toPlainArray(object: T[][], dimensions: 2): Object[][];\n    public toPlainArray(object: T[][][], dimensions: 3): Object[][][];\n    public toPlainArray(object: T[][][][], dimensions: 4): Object[][][][];\n    public toPlainArray(object: T[][][][][], dimensions: 5): Object[][][][][];\n    public toPlainArray(object: any[], dimensions: 1|2|3|4|5 = 1): Object[]|undefined\n    {\n        try\n        {\n            const elementConstructorArray =\n                new Array(dimensions - 1).fill(Array).concat(this.rootConstructor);\n            return this.serializer.convertAsArray(object, elementConstructorArray);\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    public toPlainSet(object: Set<T>): Object[]|undefined\n    {\n        try\n        {\n            return this.serializer.convertAsSet(object, this.rootConstructor);\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    public toPlainMap<K>(object: Map<K, T>, keyConstructor: Constructor<K>): { key: any, value: any }[]|undefined\n    {\n        try\n        {\n            return this.serializer.convertAsMap(object, keyConstructor, this.rootConstructor);\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Converts an instance of the specified class type to a JSON string.\n     * @param object The instance to convert to a JSON string.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns String with the serialized object or an empty string if an error has occured, but\n     *     the errorHandler did not throw.\n     */\n    public stringify(object: T): string\n    {\n        const result = this.toPlainJson(object);\n        if (result === undefined) {\n            return '';\n        }\n        return JSON.stringify(result, this.replacer, this.indent);\n    }\n\n    public stringifyAsArray(object: T[], dimensions?: 1): string;\n    public stringifyAsArray(object: T[][], dimensions: 2): string;\n    public stringifyAsArray(object: T[][][], dimensions: 3): string;\n    public stringifyAsArray(object: T[][][][], dimensions: 4): string;\n    public stringifyAsArray(object: T[][][][][], dimensions: 5): string;\n    public stringifyAsArray(object: any[], dimensions: any): string\n    {\n        return JSON.stringify(this.toPlainArray(object, dimensions), this.replacer, this.indent);\n    }\n\n    public stringifyAsSet(object: Set<T>): string\n    {\n        return JSON.stringify(this.toPlainSet(object), this.replacer, this.indent);\n    }\n\n    public stringifyAsMap<K>(object: Map<K, T>, keyConstructor: Constructor<K>): string\n    {\n        return JSON.stringify(this.toPlainMap(object, keyConstructor), this.replacer, this.indent);\n    }\n\n    private _mapKnownTypes(constructors: Array<Constructor<any>>)\n    {\n        let map = new Map<string, Constructor<any>>();\n\n        constructors.filter(ctor => ctor).forEach(ctor => map.set(this.nameResolver(ctor), ctor));\n\n        return map;\n    }\n}\n","import { Constructor, ParameterlessConstructor } from \"./types\";\nimport { METADATA_FIELD_KEY } from \"./helpers\";\nimport { JsonObjectMetadata } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\n\nexport type InitializerCallback<T> = (sourceObject: T, rawSourceObject: T) => T;\n\nexport interface IJsonObjectOptionsBase extends OptionsBase\n{\n    /**\n     * An array of known types to recognize when encountering type-hints,\n     * or the name of a static method used for determining known types.\n     */\n    knownTypes?: Function[] | string;\n\n    /**\n     * The name of a static or instance method to call when deserialization\n     * of the object is completed.\n     */\n    onDeserialized?: string;\n\n    /**\n     * The name of a static or instance method to call before the serialization\n     * of the typed object is started.\n     */\n    beforeSerialization?: string;\n\n    /**\n     * The name used to differentiate between different polymorphic types.\n     */\n    name?: string;\n}\n\nexport interface IJsonObjectOptionsWithInitializer<T> extends IJsonObjectOptionsBase\n{\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer: InitializerCallback<T>;\n}\n\nexport interface IJsonObjectOptions<T> extends IJsonObjectOptionsBase\n{\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer?: InitializerCallback<T>;\n}\n\n/**\n * Marks that a class with a parameterized constructor is serializable using TypedJSON, with additional\n * settings. The 'initializer' setting must be specified.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(options?: IJsonObjectOptionsWithInitializer<T>): (target: Constructor<T>) => void;\n\n/**\n * Marks that a class is serializable using TypedJSON, with additional settings.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(options?: IJsonObjectOptions<T>): (target: ParameterlessConstructor<T>) => void;\n\n/**\n * Marks that a class with a parameterless constructor is serializable using TypedJSON.\n */\nexport function jsonObject<T>(target: ParameterlessConstructor<T>): void;\n\nexport function jsonObject<T extends Object>(optionsOrTarget?: IJsonObjectOptions<T> | Constructor<T>\n): ((target: Constructor<T>) => void) | void {\n    let options: IJsonObjectOptions<T>;\n\n    if (typeof optionsOrTarget === \"function\")\n    {\n        // jsonObject is being used as a decorator, directly.\n        options = {};\n    }\n    else\n    {\n        // jsonObject is being used as a decorator factory.\n        options = optionsOrTarget || {};\n    }\n\n    function decorator(\n        target: Function\n    ): void {\n        let objectMetadata: JsonObjectMetadata;\n\n        // Create or obtain JsonObjectMetadata object.\n        if (!target.prototype.hasOwnProperty(METADATA_FIELD_KEY))\n        {\n            // Target has no JsonObjectMetadata associated with it yet, create it now.\n            objectMetadata = new JsonObjectMetadata(target);\n\n            // Inherit json members and known types from parent @jsonObject (if any).\n            const parentMetadata: JsonObjectMetadata = target.prototype[METADATA_FIELD_KEY];\n            if (parentMetadata)\n            {\n                parentMetadata.dataMembers\n                    .forEach((memberMetadata, propKey) =>\n                        objectMetadata.dataMembers.set(propKey, memberMetadata));\n                parentMetadata.knownTypes\n                    .forEach((knownType) => objectMetadata.knownTypes.add(knownType));\n            }\n\n            Object.defineProperty(target.prototype, METADATA_FIELD_KEY, {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: objectMetadata\n            });\n        }\n        else\n        {\n            // Target already has JsonObjectMetadata associated with it.\n            objectMetadata = target.prototype[METADATA_FIELD_KEY];\n            objectMetadata.classType = target;\n        }\n\n        // Fill JsonObjectMetadata.\n        objectMetadata.isExplicitlyMarked = true;\n        objectMetadata.onDeserializedMethodName = options.onDeserialized;\n        objectMetadata.beforeSerializationMethodName = options.beforeSerialization;\n        \n        // T extend Object so it is fine\n        objectMetadata.initializerCallback = options.initializer as any;\n        if (options.name)\n        {\n            objectMetadata.name = options.name;\n        }\n        const optionsBase = extractOptionBase(options);\n        if (optionsBase)\n        {\n            objectMetadata.options = optionsBase;\n        }\n\n        // Obtain known-types.\n        if (typeof options.knownTypes === \"string\")\n        {\n            objectMetadata.knownTypeMethodName = options.knownTypes;\n        }\n        else if (options.knownTypes instanceof Array)\n        {\n            options.knownTypes\n                .filter(knownType => !!knownType)\n                .forEach(knownType => objectMetadata.knownTypes.add(knownType));\n        }\n    }\n\n    if (typeof optionsOrTarget === \"function\")\n    {\n        // jsonObject is being used as a decorator, directly.\n        decorator(optionsOrTarget);\n    }\n    else\n    {\n        // jsonObject is being used as a decorator factory.\n        return decorator;\n    }\n}\n","import {\n    nameof, logError, isReflectMetadataSupported, isValueDefined, logWarning, isSubtypeOf\n} from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMemberOptions extends OptionsBase\n{\n    /**\n     * Sets the constructor of the property.\n     * Optional with ReflectDecorators.\n     */\n    constructor?: Function;\n\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted if the property is uninitialized/undefined. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name. */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property is part of the object when serializing, with additional options.\n * Omitting the 'constructor' option requires ReflectDecorators and that the property type is always explicitly declared.\n * @param options Additional options.\n */\nexport function jsonMember<TFunction extends Function>(options: IJsonMemberOptions): PropertyDecorator;\n\n/**\n * Specifies that a property is part of the object when serializing.\n * This call signature requires ReflectDecorators and that the property type is always explicitly declared.\n */\nexport function jsonMember(target: Object, propertyKey: string | symbol): void;\n\nexport function jsonMember<TFunction extends Function>(optionsOrTarget?: IJsonMemberOptions | Object, propKey?: string | symbol): PropertyDecorator | void\n{\n    if (optionsOrTarget instanceof Object && (typeof propKey === \"string\" || typeof propKey === \"symbol\"))\n    {\n        const target = optionsOrTarget as Object;\n        // For error messages.\n        const decoratorName = `@jsonMember on ${nameof(target.constructor)}.${String(propKey)}`;\n\n        // jsonMember used directly, no additional information directly available besides target and propKey.\n        // Obtain property constructor through ReflectDecorators.\n        if (isReflectMetadataSupported)\n        {\n            const reflectPropCtor = Reflect.getMetadata(\"design:type\", target, propKey) as Function;\n\n            if (!reflectPropCtor)\n            {\n                logError(`${decoratorName}: could not resolve detected property constructor at runtime.`);\n                return;\n            }\n\n            if (isSpecialPropertyType(decoratorName, reflectPropCtor))\n            {\n                return;\n            }\n\n            injectMetadataInformation(target, propKey, {\n                ctor: reflectPropCtor,\n                key: propKey.toString(),\n                name: propKey.toString(),\n            });\n        }\n        else\n        {\n            logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is specified.`);\n            return;\n        }\n    }\n    else\n    {\n        // jsonMember used as a decorator factory.\n        return (target: Object, _propKey: string | symbol) =>\n        {\n            let options: IJsonMemberOptions = optionsOrTarget || {};\n            let propCtor: Function|undefined;\n            let decoratorName = `@jsonMember on ${nameof(target.constructor)}.${String(_propKey)}`; // For error messages.\n\n            if (options.hasOwnProperty(\"constructor\"))\n            {\n                if (!isValueDefined(options.constructor))\n                {\n                    logError(`${decoratorName}: cannot resolve specified property constructor at runtime.`);\n                    return;\n                }\n\n                // Property constructor has been specified. Use ReflectDecorators (if available) to check whether that constructor is correct. Warn if not.\n                if (isReflectMetadataSupported && !isSubtypeOf(options.constructor, Reflect.getMetadata(\"design:type\", target, _propKey)))\n                {\n                    logWarning(`${decoratorName}: detected property type does not match 'constructor' option.`);\n                }\n\n                propCtor = options.constructor;\n            }\n            else\n            {\n                // Use ReflectDecorators to obtain property constructor.\n                if (isReflectMetadataSupported)\n                {\n                    propCtor = Reflect.getMetadata(\"design:type\", target, _propKey) as Function;\n\n                    if (!propCtor)\n                    {\n                        logError(`${decoratorName}: cannot resolve detected property constructor at runtime.`);\n                        return;\n                    }\n                }\n                else if (!options.deserializer)\n                {\n                    logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is specified.`);\n                    return;\n                }\n            }\n\n            if (isSpecialPropertyType(decoratorName, propCtor))\n            {\n                return;\n            }\n\n            injectMetadataInformation(target, _propKey, {\n                ctor: propCtor,\n                emitDefaultValue: options.emitDefaultValue,\n                isRequired: options.isRequired,\n                options: extractOptionBase(options),\n                key: _propKey.toString(),\n                name: options.name || _propKey.toString(),\n                deserializer: options.deserializer,\n                serializer: options.serializer,\n            });\n        };\n    }\n}\n\nfunction isSpecialPropertyType(decoratorName: string, propCtor?: Function)\n{\n    if (propCtor === Array)\n    {\n        logError(`${decoratorName}: property is an Array. Use the jsonArrayMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (propCtor === Set)\n    {\n        logError(`${decoratorName}: property is a Set. Use the jsonSetMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (propCtor === Map)\n    {\n        logError(`${decoratorName}: property is a Map. Use the jsonMapMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    return false;\n}\n","import { nameof, logError, isReflectMetadataSupported } from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, getDefaultOptionOf, OptionsBase } from \"./options-base\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonArrayMemberOptions extends OptionsBase\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, an empty array is emitted if the property is undefined/uninitialized. */\n    emitDefaultValue?: boolean;\n\n    /** Sets array dimensions (e.g. 1 for 'number[]' or 2 for 'number[][]'). Defaults to 1. */\n    dimensions?: number;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property, of type array, is part of an object when serializing.\n * @param elementConstructor Constructor of array elements (e.g. 'Number' for 'number[]', or 'Date' for 'Date[]').\n * @param options Additional options.\n */\nexport function jsonArrayMember(elementConstructor: Function, options: IJsonArrayMemberOptions = {})\n{\n    return (target: Object, propKey: string | symbol) =>\n    {\n        let decoratorName = `@jsonArrayMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (typeof elementConstructor !== \"function\")\n        {\n            logError(`${decoratorName}: could not resolve constructor of array elements at runtime.`);\n            return;\n        }\n\n        const dimensions = options.dimensions === undefined ? 1 : options.dimensions;\n        if (!isNaN(dimensions) && dimensions < 1)\n        {\n            logError(`${decoratorName}: 'dimensions' option must be at least 1.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonArrayMember' has been used on an array.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Array)\n        {\n            logError(`${decoratorName}: property is not an Array.`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            ctor: Array,\n            elementType: createArrayElementType(elementConstructor, dimensions),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n\nfunction createArrayElementType(elementCtor: Function, dimensions: number) {\n    const elementTypes = new Array(dimensions).fill(Array, 0, -1);\n    elementTypes[dimensions-1] = elementCtor;\n    return elementTypes;\n}\n","import { isReflectMetadataSupported, logError, nameof } from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonSetMemberOptions extends OptionsBase\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Set<T>.\n * @param elementConstructor Constructor of set elements (e.g. 'Number' for Set<number> or 'Date' for Set<Date>).\n * @param options Additional options.\n */\nexport function jsonSetMember(elementConstructor: Function, options: IJsonSetMemberOptions = {})\n{\n    return (target: Object, propKey: string | symbol) =>\n    {\n        var decoratorName = `@jsonSetMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (typeof elementConstructor !== \"function\")\n        {\n            logError(`${decoratorName}: could not resolve constructor of set elements at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonSetMember' has been used on a set. Warn if not.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Set)\n        {\n            logError(`${decoratorName}: property is not a Set.`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            ctor: Set,\n            elementType: [elementConstructor],\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import { nameof, logError, isReflectMetadataSupported } from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, getDefaultOptionOf, OptionsBase } from \"./options-base\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMapMemberOptions extends OptionsBase\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Map<K, V>.\n * @param keyConstructor Constructor of map keys (e.g. 'Number' for 'Map<number, Date>').\n * @param valueConstructor Constructor of map values (e.g. 'Date' for 'Map<number, Date>').\n * @param options Additional options.\n */\nexport function jsonMapMember(keyConstructor: Function, valueConstructor: Function, options: IJsonMapMemberOptions = {})\n{\n    return (target: Object, propKey: string | symbol) =>\n    {\n        let decoratorName = `@jsonMapMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (typeof keyConstructor !== \"function\")\n        {\n            logError(`${decoratorName}: could not resolve constructor of map keys at runtime.`);\n            return;\n        }\n\n        if (typeof valueConstructor !== \"function\")\n        {\n            logError(`${decoratorName}: could not resolve constructor of map values at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonMapMember' has been used on a map. Warn if not.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Map)\n        {\n            logError(`${decoratorName}: property is not a Map.`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            ctor: Map,\n            elementType: [valueConstructor],\n            keyType: keyConstructor,\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import { TypedJSON } from \"../parser\";\n\n/**\n * Options for the @toJson decorator.\n */\nexport interface IToJsonOptions {\n    /**\n     * When set to true it will overwrite any toJSON already existing on the prototype.\n     */\n    overwrite?: boolean;\n}\n\n/**\n * Decorator that will generate toJSON function on the class prototype that allows\n * JSON.stringify to be used instead of TypedJSON.stringify. Under the hood it will\n * simply delegate to TypedJSON.\n * By default it will throw if the prototype already has a toJSON function defined.\n * @param target the class which prototype should be modified.\n */\nexport function toJson<T extends Object>(target: Function): void;\n/**\n * Decorator factory that accepts the options interface.\n * @param options for configuring the toJSON creation.\n */\nexport function toJson<T extends Object>(options: IToJsonOptions): ((target: Function) => void);\nexport function toJson<T extends Object>(optionsOrTarget: IToJsonOptions | Function\n): ((target: Function) => void) | void {\n    if (typeof optionsOrTarget === 'function') {\n        // used directly\n        toJsonDecorator(optionsOrTarget, {});\n        return;\n    }\n    // used as a factory\n    return (target: Function) => {\n        toJsonDecorator(target, optionsOrTarget);\n    }\n}\n\nfunction toJsonDecorator<T extends Object>(target: Function, options: IToJsonOptions): void {\n    if (!options.overwrite && target.prototype.toJSON) {\n        throw new Error(`${target.name} already has toJSON defined!`);\n    }\n    target.prototype.toJSON = function () {\n        return TypedJSON.toPlainJson(this, Object.getPrototypeOf(this).constructor);\n    }\n}\n","export { TypedJSON, ITypedJSONSettings, JsonTypes } from \"./parser\";\nexport { jsonObject } from \"./typedjson/json-object\";\nexport { jsonMember } from \"./typedjson/json-member\";\nexport { jsonArrayMember } from \"./typedjson/json-array-member\";\nexport { jsonSetMember } from \"./typedjson/json-set-member\";\nexport { jsonMapMember } from \"./typedjson/json-map-member\";\nexport { toJson } from \"./typedjson/to-json\";\n"],"sourceRoot":""}
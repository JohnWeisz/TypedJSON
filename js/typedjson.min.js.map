{"version":3,"sources":["webpack://typedjson/webpack/universalModuleDefinition","webpack://typedjson/webpack/bootstrap","webpack://typedjson/./src/typedjson/helpers.ts","webpack://typedjson/./src/typedjson/metadata.ts","webpack://typedjson/./src/typedjson/options-base.ts","webpack://typedjson/./src/typedjson/type-descriptor.ts","webpack://typedjson/./src/typedjson/deserializer.ts","webpack://typedjson/./src/typedjson/json-array-member.ts","webpack://typedjson/./src/typedjson/serializer.ts","webpack://typedjson/./src/parser.ts","webpack://typedjson/./src/typedjson/json-object.ts","webpack://typedjson/./src/typedjson/json-member.ts","webpack://typedjson/./src/typedjson/json-set-member.ts","webpack://typedjson/./src/typedjson/json-map-member.ts","webpack://typedjson/./src/typedjson/to-json.ts","webpack://typedjson/./src/typedjson.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","m","MISSING_REFLECT_CONF_MSG","parseToJSObject","json","expectedType","jsonStr","expectsTypesSerializedAsStrings","String","ArrayBuffer","DataView","hasQuotes","length","isInteger","test","trim","Date","JSON","parse","isSubtypeOf","A","B","prototype","logError","message","console","error","optionalParams","log","logWarning","warn","isValueDefined","value","isInstanceOf","constructor","Number","Boolean","isReflectMetadataSupported","Reflect","getMetadata","nameof","fn","name","identity","arg","METADATA_FIELD_KEY","getJsonObjectName","ctor","metadata","JsonObjectMetadata","getFromConstructor","undefined","classType","hasOwnProperty","isExplicitlyMarked","doesHandleWithoutAnnotation","primitiveMeta","ensurePresentInPrototype","objectMetadata","parentMetadata","dataMembers","forEach","memberMetadata","propKey","set","knownTypes","knownType","add","typeResolver","typeHintEmitter","Object","defineProperty","enumerable","configurable","writable","getKnownTypeNameFromType","indexOf","Float32Array","Float64Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Map","Set","isHandledWithoutAnnotation","injectMetadataInformation","decoratorName","type","deserializer","getTypes","keys","key","kAllOptions","extractOptionBase","from","options","filter","reduce","obj","getOptionValue","getDefaultOptionOf","mergeOptions","existing","moreSpecific","TypeDescriptor","GenericTypeDescriptor","concat","elementType","Array","ArrayT","ArrayTypeDescriptor","ensureTypeDescriptor","SetT","SetTypeDescriptor","keyType","valueType","getCompleteOptions","shape","MapT","MapTypeDescriptor","isTypelike","ConcreteTypeDescriptor","defaultTypeResolver","sourceObject","__type","get","setNameResolver","nameResolverCallback","nameResolver","setTypeResolver","typeResolverCallback","TypeError","getTypeResolver","setErrorHandler","errorHandlerCallback","errorHandler","getErrorHandler","convertSingleValue","typeDescriptor","memberName","memberOptions","retrievePreserveNull","deserializationStrategy","expectedSelfType","sourceObjectMetadata","knownTypeConstructors","mergeKnownTypes","createKnownTypesMap","typeFromTypeHint","objMemberMetadata","revivedValue","objMemberValue","objMemberDebugName","objMemberOptions","isRequired","targetObject","initializerCallback","e","instantiateType","assign","methodName","onDeserializedMethodName","sourceKey","convertAsObject","result","knownTypeMaps","knowTypes","map","knownTypeMeta","customName","isExpectedMapShape","source","expectedShape","isArray","deserializeDirectly","deserializeDate","stringToArrayBuffer","stringToDataView","convertAsArray","convertAsSet","convertAsMap","convertAsFloatArray","convertAsUintArray","throwTypeMismatchError","targetType","expectedSourceType","actualSourceType","makeTypeErrorMessage","actualType","srcTypeNameForDebug","objectName","element","resultSet","i","resultMap","resultKey","createArrayBufferFromString","input","buf","bufView","strLen","charCodeAt","every","elem","isNaN","jsonArrayMember","elementConstructor","target","dimensions","createArrayType","emitDefaultValue","toString","serializer","defaultTypeEmitter","sourceTypeMetadata","setTypeHintEmitter","typeEmitterCallback","getTypeHintEmitter","serializationStrategy","beforeSerializationMethodName","serialized","expectedName","actualName","convertAsArrayBuffer","convertAsDataView","convertAsTypedArray","expectedTypeName","actualTypeName","resultArray","resultElement","push","resultShape","preserveNull","resultKeyValuePairObj","keyDefined","valueDefined","buffer","charCode","fromCharCode","join","dataView","object","rootType","settings","TypedJSON","parseAsArray","parseAsSet","parseAsMap","toPlainJson","toPlainArray","toPlainSet","toPlainMap","keyCtor","valueCtor","stringify","stringifyAsArray","stringifyAsSet","stringifyAsMap","setGlobalConfig","config","_globalConfig","replacer","indent","globalKnownTypes","rootConstructor","rootMetadata","ktc","knownTypeCtor","_mapKnownTypes","keyConstructor","constructors","jsonObject","optionsOrTarget","decorator","onDeserialized","beforeSerialization","initializer","optionsBase","jsonMember","optionsOrPrototype","_propKey","reflectCtor","isSpecialPropertyType","reflectPropCtor","jsonSetMember","jsonMapMember","valueConstructor","toJson","toJsonDecorator","overwrite","toJSON","Error","getPrototypeOf","c","d","getter","o","r","Symbol","toStringTag","t","mode","__esModule","ns","create","bind","n","property","call","p","s","moduleId","l","modules"],"mappings":"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","file":"typedjson.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"typedjson\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"typedjson\"] = factory();\n\telse\n\t\troot[\"typedjson\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import {Serializable} from './types';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport const MISSING_REFLECT_CONF_MSG = 'Are you sure, that you have both \"experimentalDecorators\"'\n    + ' and \"emitDecoratorMetadata\" in your tsconfig.json?';\n\n/**\n * Determines whether the specified type is a type that can be passed on \"as-is\" into\n * `JSON.stringify`.\n * Values of these types don't need special conversion.\n * @param type The constructor of the type (wrapper constructor for primitive types, e.g. `Number`\n * for `number`).\n */\nexport function isDirectlySerializableNativeType(type: Function): boolean {\n    return [Date, Number, String, Boolean].indexOf(type as any) !== -1;\n}\n\nexport function isDirectlyDeserializableNativeType(type: Function): boolean {\n    return [Number, String, Boolean].indexOf(type as any) !== -1;\n}\n\nexport function isTypeTypedArray(type: Function): boolean {\n    return [\n        Float32Array,\n        Float64Array,\n        Int8Array,\n        Uint8Array,\n        Uint8ClampedArray,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n    ].indexOf(type as any) !== -1;\n}\n\nexport function isObject(value: any): value is Object {\n    return typeof value === 'object';\n}\n\nfunction shouldOmitParseString(jsonStr: string, expectedType: Function): boolean {\n    const expectsTypesSerializedAsStrings = expectedType === String\n        || expectedType === ArrayBuffer\n        || expectedType === DataView;\n\n    const hasQuotes = jsonStr.length >= 2\n        && jsonStr[0] === '\"'\n        && jsonStr[jsonStr.length - 1] === '\"';\n    const isInteger = /^\\d+$/.test(jsonStr.trim());\n\n    return (expectsTypesSerializedAsStrings && !hasQuotes)\n        || ((!hasQuotes && !isInteger) && expectedType === Date);\n}\n\nexport function parseToJSObject<T>(json: any, expectedType: Serializable<T>): Object {\n    if (typeof json !== 'string' || shouldOmitParseString(json, expectedType)) {\n        return json;\n    }\n    return JSON.parse(json);\n}\n\n/**\n * Determines if 'A' is a sub-type of 'B' (or if 'A' equals 'B').\n * @param A The supposed derived type.\n * @param B The supposed base type.\n */\nexport function isSubtypeOf(A: Function, B: Function) {\n    return A === B || A.prototype instanceof B;\n}\n\nexport function logError(message?: any, ...optionalParams: Array<any>) {\n    if (typeof console as any === 'object' && typeof console.error as any === 'function') {\n        console.error(message, ...optionalParams);\n    } else if (typeof console as any === 'object' && typeof console.log as any === 'function') {\n        console.log(`ERROR: ${message}`, ...optionalParams);\n    }\n}\n\nexport function logMessage(message?: any, ...optionalParams: Array<any>) {\n    if (typeof console as any === 'object' && typeof console.log as any === 'function') {\n        console.log(message, ...optionalParams);\n    }\n}\n\nexport function logWarning(message?: any, ...optionalParams: Array<any>) {\n    if (typeof console as any === 'object' && typeof console.warn as any === 'function') {\n        console.warn(message, ...optionalParams);\n    } else if (typeof console as any === 'object' && typeof console.log as any === 'function') {\n        console.log(`WARNING: ${message}`, ...optionalParams);\n    }\n}\n\nexport type NotNull<T> = T extends null ? never : T;\nexport type RequiredNoNull<T> = {[P in keyof T]-?: NotNull<T[P]>};\n\n/**\n * Checks if the value is considered defined (not undefined and not null).\n * @param value\n */\nexport function isValueDefined<T>(value: T): value is Exclude<T, undefined | null> {\n    return !(typeof value === 'undefined' || value === null);\n}\n\nexport function isInstanceOf<T>(value: any, constructor: Function): boolean {\n    if (typeof value === 'number') {\n        return constructor === Number;\n    } else if (typeof value === 'string') {\n        return constructor === String;\n    } else if (typeof value === 'boolean') {\n        return constructor === Boolean;\n    } else if (isObject(value)) {\n        return value instanceof constructor;\n    }\n\n    return false;\n}\n\nexport const isReflectMetadataSupported =\n    typeof Reflect as any === 'object' && typeof Reflect.getMetadata as any === 'function';\n\n/**\n * Gets the name of a function.\n * @param fn The function whose name to get.\n */\nexport function nameof(fn: Function & {name?: string}) {\n    if (typeof fn.name as string | undefined === 'string') {\n        return fn.name;\n    }\n    return 'undefined';\n}\n\nexport function identity<T>(arg: T): T {\n    return arg;\n}\n","import {isDirectlySerializableNativeType, isTypeTypedArray, logError, nameof} from './helpers';\nimport {OptionsBase} from './options-base';\nimport {TypeDescriptor} from './type-descriptor';\nimport {IndexedObject, Serializable} from './types';\n\nexport const METADATA_FIELD_KEY = '__typedJsonJsonObjectMetadataInformation__';\n\nexport type TypeResolver = (\n    sourceObject: IndexedObject,\n    knownTypes: Map<string, Function>,\n) => Function | undefined | null;\nexport type TypeHintEmitter\n    = (\n        targetObject: IndexedObject,\n        sourceObject: IndexedObject,\n        expectedSourceType: Function,\n        sourceTypeMetadata?: JsonObjectMetadata,\n    ) => void;\n\nexport interface JsonMemberMetadata {\n    /** If set, a default value will be emitted for uninitialized members. */\n    emitDefaultValue?: boolean | null;\n\n    /** Member name as it appears in the serialized JSON. */\n    name: string;\n\n    /** Property or field key of the json member. */\n    key: string;\n\n    /** Type descriptor of the member. */\n    type?: TypeDescriptor | null;\n\n    /** If set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean | null;\n\n    options?: OptionsBase | null;\n\n    /** Custom deserializer to use. */\n    deserializer?: ((json: any) => any) | null;\n\n    /** Custom serializer to use. */\n    serializer?: ((value: any) => any) | null;\n}\n\nexport class JsonObjectMetadata {\n\n    dataMembers = new Map<string, JsonMemberMetadata>();\n\n    /** Set of known types used for polymorphic deserialization */\n    knownTypes = new Set<Serializable<any>>();\n\n    /** If present override the global function */\n    typeHintEmitter?: TypeHintEmitter | null;\n    /** If present override the global function */\n    typeResolver?: TypeResolver | null;\n    /** Gets or sets the constructor function for the jsonObject. */\n    classType: Function;\n\n    /**\n     * Indicates whether this class was explicitly annotated with @jsonObject\n     * or implicitly by @jsonMember\n     */\n    isExplicitlyMarked: boolean = false;\n\n    /**\n     * Indicates whether this type is handled without annotation. This is usually\n     * used for the builtin types (except for Maps, Sets, and normal Arrays).\n     */\n    isHandledWithoutAnnotation: boolean = false;\n\n    /** Name used to encode polymorphic type */\n    name?: string | null;\n\n    options?: OptionsBase | null;\n\n    onDeserializedMethodName?: string | null;\n\n    beforeSerializationMethodName?: string | null;\n\n    initializerCallback?: ((sourceObject: Object, rawSourceObject: Object) => Object) | null;\n\n    constructor(\n        classType: Function,\n    ) {\n        this.classType = classType;\n    }\n\n    /**\n     * Gets the name of a class as it appears in a serialized JSON string.\n     * @param ctor The constructor of a class (with or without jsonObject).\n     */\n    static getJsonObjectName(ctor: Function): string {\n        const metadata = JsonObjectMetadata.getFromConstructor(ctor);\n        return metadata === undefined ? nameof(ctor) : nameof(metadata.classType);\n    }\n\n    /**\n     * Gets jsonObject metadata information from a class.\n     * @param ctor The constructor class.\n     */\n    static getFromConstructor<T>(ctor: Serializable<T>): JsonObjectMetadata | undefined {\n        const prototype = ctor.prototype;\n        if (prototype == null) {\n            return;\n        }\n\n        let metadata: JsonObjectMetadata | undefined;\n        if (prototype.hasOwnProperty(METADATA_FIELD_KEY) === true) {\n            // The class prototype contains own jsonObject metadata\n            metadata = prototype[METADATA_FIELD_KEY];\n        }\n\n        // Ignore implicitly added jsonObject (through jsonMember)\n        if (metadata?.isExplicitlyMarked === true) {\n            return metadata;\n        }\n\n        // In the end maybe it is something which we can handle directly\n        if (JsonObjectMetadata.doesHandleWithoutAnnotation(ctor)) {\n            const primitiveMeta = new JsonObjectMetadata(ctor);\n            primitiveMeta.isExplicitlyMarked = true;\n            // we do not store the metadata here to not modify builtin prototype\n            return primitiveMeta;\n        }\n    }\n\n    static ensurePresentInPrototype(prototype: IndexedObject): JsonObjectMetadata {\n        if (prototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n            return prototype[METADATA_FIELD_KEY];\n        }\n        // Target has no JsonObjectMetadata associated with it yet, create it now.\n        const objectMetadata = new JsonObjectMetadata(prototype.constructor);\n\n        // Inherit json members and known types from parent @jsonObject (if any).\n        const parentMetadata: JsonObjectMetadata | undefined = prototype[METADATA_FIELD_KEY];\n        if (parentMetadata !== undefined) {\n            parentMetadata.dataMembers.forEach((memberMetadata, propKey) => {\n                objectMetadata.dataMembers.set(propKey, memberMetadata);\n            });\n            parentMetadata.knownTypes.forEach((knownType) => {\n                objectMetadata.knownTypes.add(knownType);\n            });\n            objectMetadata.typeResolver = parentMetadata.typeResolver;\n            objectMetadata.typeHintEmitter = parentMetadata.typeHintEmitter;\n        }\n\n        Object.defineProperty(prototype, METADATA_FIELD_KEY, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: objectMetadata,\n        });\n        return objectMetadata;\n    }\n\n    /**\n     * Gets the known type name of a jsonObject class for type hint.\n     * @param constructor The constructor class.\n     */\n    static getKnownTypeNameFromType(constructor: Function): string {\n        const metadata = JsonObjectMetadata.getFromConstructor(constructor);\n        return metadata === undefined ? nameof(constructor) : nameof(metadata.classType);\n    }\n\n    private static doesHandleWithoutAnnotation(ctor: Function): boolean {\n        return isDirectlySerializableNativeType(ctor) || isTypeTypedArray(ctor)\n            || ctor === DataView || ctor === ArrayBuffer;\n    }\n}\n\nexport function injectMetadataInformation(\n    prototype: IndexedObject,\n    propKey: string | symbol,\n    metadata: JsonMemberMetadata,\n) {\n    // For error messages\n    const decoratorName = `@jsonMember on ${nameof(prototype.constructor)}.${String(propKey)}`;\n\n    // When a property decorator is applied to a static member, 'constructor' is a constructor\n    // function.\n    // See:\n    // eslint-disable-next-line max-len\n    // https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md#property-decorators\n    // ... and static members are not supported here, so abort.\n    if (typeof prototype as any === 'function') {\n        logError(`${decoratorName}: cannot use a static property.`);\n        return;\n    }\n\n    // Methods cannot be serialized.\n    // symbol indexing is not supported by ts\n    if (typeof prototype[propKey as string] === 'function') {\n        logError(`${decoratorName}: cannot use a method property.`);\n        return;\n    }\n\n    // @todo check if metadata is ever undefined, if so, change parameter type\n    if (metadata as any == null\n        || (metadata.type === undefined && metadata.deserializer === undefined)) {\n        logError(`${decoratorName}: JsonMemberMetadata has unknown type.`);\n        return;\n    }\n\n    // Add jsonObject metadata to 'constructor' if not yet exists ('constructor' is the prototype).\n    // NOTE: this will not fire up custom serialization, as 'constructor' must be explicitly marked\n    // with '@jsonObject' as well.\n    const objectMetadata = JsonObjectMetadata.ensurePresentInPrototype(prototype);\n\n    if (metadata.deserializer === undefined) {\n        // If deserializer is not present then type must be\n        metadata.type!.getTypes().forEach(ctor => objectMetadata.knownTypes.add(ctor));\n    }\n\n    // clear metadata of undefined properties to save memory\n    (Object.keys(metadata) as [keyof JsonMemberMetadata])\n        .forEach((key) => (metadata[key] === undefined) && delete metadata[key]);\n    objectMetadata.dataMembers.set(metadata.name, metadata);\n}\n","import {RequiredNoNull} from './helpers';\n\n/**\n * This options cascade through the annotations. Options set\n * in the more specific place override the previous option.\n * Ex. @jsonMember overrides TypedJson options.\n */\nexport interface OptionsBase {\n    /**\n     * Whether to preserve null in the JSON output. When false it\n     * will not emit nor store the property if its value is null.\n     * Default: false.\n     */\n    preserveNull?: boolean | null;\n}\n\nconst kAllOptions: Array<keyof OptionsBase> = [\n    'preserveNull',\n];\n\nexport function extractOptionBase(\n    from: {[key: string]: any} & OptionsBase,\n): OptionsBase | undefined {\n    const options = Object.keys(from)\n        .filter(key => (kAllOptions as Array<string>).indexOf(key) > -1)\n        .reduce((obj, key) => {\n            obj[key] = from[key];\n            return obj;\n        }, {} as any);\n    return Object.keys(options).length > 0 ? options : undefined;\n}\n\nexport function getDefaultOptionOf<K extends keyof OptionsBase>(\n    key: K,\n): RequiredNoNull<OptionsBase>[K] {\n    switch (key) {\n        case 'preserveNull':\n            return false;\n    }\n    // never reached\n    return null as any;\n}\n\nexport function getOptionValue<K extends keyof OptionsBase>(\n    key: K,\n    options?: OptionsBase | null,\n): RequiredNoNull<OptionsBase>[K] {\n    if (options != null && options[key] as any != null) {\n        return options[key]!;\n    }\n\n    return getDefaultOptionOf(key);\n}\n\nexport function mergeOptions(\n    existing?: OptionsBase,\n    moreSpecific?: OptionsBase | null,\n): OptionsBase | undefined {\n    return moreSpecific == null\n        ? existing\n        : {\n\n            ...existing,\n            ...moreSpecific,\n        };\n}\n","export abstract class TypeDescriptor {\n    protected constructor(readonly ctor: Function) {\n    }\n\n    getTypes(): Array<Function> {\n        return [this.ctor];\n    }\n}\n\nexport type Typelike = TypeDescriptor | Function;\n\nexport class ConcreteTypeDescriptor extends TypeDescriptor {\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(ctor: Function) {\n        super(ctor);\n    }\n}\n\nexport abstract class GenericTypeDescriptor extends TypeDescriptor {\n    protected constructor(ctor: Function) {\n        super(ctor);\n    }\n}\n\nexport class ArrayTypeDescriptor extends GenericTypeDescriptor {\n    constructor(readonly elementType: TypeDescriptor) {\n        super(Array);\n    }\n\n    getTypes(): Array<Function> {\n        return super.getTypes().concat(this.elementType.getTypes());\n    }\n}\n\nexport function ArrayT(elementType: Typelike): ArrayTypeDescriptor {\n    return new ArrayTypeDescriptor(ensureTypeDescriptor(elementType));\n}\n\nexport class SetTypeDescriptor extends GenericTypeDescriptor {\n    constructor(readonly elementType: TypeDescriptor) {\n        super(Set);\n    }\n\n    getTypes(): Array<Function> {\n        return super.getTypes().concat(this.elementType.getTypes());\n    }\n}\n\nexport function SetT(elementType: Typelike): SetTypeDescriptor {\n    return new SetTypeDescriptor(ensureTypeDescriptor(elementType));\n}\n\nexport const enum MapShape {\n    /**\n     * A map will be serialized as an array of {key: ..., value: ...} objects.\n     */\n    ARRAY,\n\n    /**\n     * A map will be serialized as a JSON object.\n     */\n    OBJECT,\n}\n\nexport interface MapOptions {\n    /**\n     * How the map should be serialized. Default is ARRAY.\n     */\n    shape: MapShape;\n}\n\nexport class MapTypeDescriptor extends GenericTypeDescriptor {\n    constructor(\n        readonly keyType: TypeDescriptor,\n        readonly valueType: TypeDescriptor,\n        readonly options?: Partial<MapOptions>,\n    ) {\n        super(Map);\n    }\n\n    getTypes(): Array<Function> {\n        return super.getTypes().concat(this.keyType.getTypes(), this.valueType.getTypes());\n    }\n\n    getCompleteOptions(): MapOptions {\n        return {\n            shape: this.options?.shape ?? MapShape.ARRAY,\n        };\n    }\n}\n\nexport function MapT(\n    keyType: Typelike,\n    valueType: Typelike,\n    options?: Partial<MapOptions>,\n): MapTypeDescriptor {\n    return new MapTypeDescriptor(\n        ensureTypeDescriptor(keyType),\n        ensureTypeDescriptor(valueType),\n        options,\n    );\n}\n\n// TODO support for dictionary types ie. maps that are plain objects\n// export class DictionaryTypeDescriptor extends GenericTypeDescriptor {\n//     constructor(public readonly elementType: TypeDescriptor) {\n//         super(Object);\n//     }\n//\n//     getTypes(): Function[] {\n//         return super.getTypes().concat(this.elementType.getTypes());\n//     }\n// }\n//\n// export function DictT(elementType: Typelike): DictionaryTypeDescriptor {\n//     return new DictionaryTypeDescriptor(ensureTypeDescriptor(elementType));\n// }\n\nexport function isTypelike(type: any): type is Typelike {\n    return type != null && (typeof type === 'function' || type instanceof TypeDescriptor);\n}\n\nexport function ensureTypeDescriptor(type: Typelike): TypeDescriptor {\n    return type instanceof TypeDescriptor ? type : new ConcreteTypeDescriptor(type);\n}\n","import {isSubtypeOf, isValueDefined, logError, nameof} from './helpers';\nimport {JsonObjectMetadata, TypeResolver} from './metadata';\nimport {getOptionValue, mergeOptions, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ConcreteTypeDescriptor,\n    MapShape,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from './type-descriptor';\nimport {Constructor, IndexedObject, Serializable} from './types';\n\nexport function defaultTypeResolver(\n    sourceObject: IndexedObject,\n    knownTypes: Map<string, Function>,\n): Function | undefined {\n    if (sourceObject.__type != null) {\n        return knownTypes.get(sourceObject.__type);\n    }\n}\n\nexport type DeserializerFn<T, TD extends TypeDescriptor, Raw> = (\n    sourceObject: Raw,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<T>,\n    memberOptions?: OptionsBase,\n) => T;\n\n/**\n * Utility class, converts a simple/untyped javascript object-tree to a typed object-tree.\n * It is used after parsing a JSON-string.\n */\nexport class Deserializer<T> {\n    options?: OptionsBase;\n\n    private typeResolver: TypeResolver = defaultTypeResolver;\n    private nameResolver?: (ctor: Function) => string;\n    private errorHandler: (error: Error) => void = logError;\n    private deserializationStrategy = new Map<\n        Serializable<any>,\n        DeserializerFn<any, TypeDescriptor, any>\n    >([\n        // primitives\n        [Number, deserializeDirectly],\n        [String, deserializeDirectly],\n        [Boolean, deserializeDirectly],\n\n        [Date, deserializeDate],\n        [ArrayBuffer, stringToArrayBuffer],\n        [DataView, stringToDataView],\n\n        [Array, convertAsArray],\n        [Set, convertAsSet],\n        [Map, convertAsMap],\n\n        // typed arrays\n        [Float32Array, convertAsFloatArray],\n        [Float64Array, convertAsFloatArray],\n        [Uint8Array, convertAsUintArray],\n        [Uint8ClampedArray, convertAsUintArray],\n        [Uint16Array, convertAsUintArray],\n        [Uint32Array, convertAsUintArray],\n    ]);\n\n    setNameResolver(nameResolverCallback: (ctor: Function) => string) {\n        this.nameResolver = nameResolverCallback;\n    }\n\n    setTypeResolver(typeResolverCallback: TypeResolver) {\n        if (typeof typeResolverCallback as any !== 'function') {\n            throw new TypeError('\\'typeResolverCallback\\' is not a function.');\n        }\n\n        this.typeResolver = typeResolverCallback;\n    }\n\n    getTypeResolver(): TypeResolver {\n        return this.typeResolver;\n    }\n\n    setErrorHandler(errorHandlerCallback: (error: Error) => void) {\n        if (typeof errorHandlerCallback as any !== 'function') {\n            throw new TypeError('\\'errorHandlerCallback\\' is not a function.');\n        }\n\n        this.errorHandler = errorHandlerCallback;\n    }\n\n    getErrorHandler(): (error: Error) => void {\n        return this.errorHandler;\n    }\n\n    convertSingleValue(\n        sourceObject: any,\n        typeDescriptor: TypeDescriptor,\n        knownTypes: Map<string, Function>,\n        memberName = 'object',\n        memberOptions?: OptionsBase,\n    ): any {\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) {\n            return null;\n        } else if (!isValueDefined(sourceObject)) {\n            return;\n        }\n\n        const deserializer = this.deserializationStrategy.get(typeDescriptor.ctor);\n        if (deserializer !== undefined) {\n            return deserializer(\n                sourceObject,\n                typeDescriptor,\n                knownTypes,\n                memberName,\n                this,\n                memberOptions,\n            );\n        }\n\n        if (typeof sourceObject === 'object') {\n            return convertAsObject(sourceObject, typeDescriptor, knownTypes, memberName, this);\n        }\n        this.errorHandler(new TypeError(\n            `Could not deserialize '${memberName}': don't know how to deserialize this type'.`,\n        ));\n    }\n\n    instantiateType(ctor: any) {\n        return new ctor();\n    }\n\n    mergeKnownTypes(...knownTypeMaps: Array<Map<string, Function>>) {\n        const result = new Map<string, Function>();\n\n        knownTypeMaps.forEach(knownTypes => {\n            knownTypes.forEach((ctor, name) => {\n                if (this.nameResolver === undefined) {\n                    result.set(name, ctor);\n                } else {\n                    result.set(this.nameResolver(ctor), ctor);\n                }\n            });\n        });\n\n        return result;\n    }\n\n    createKnownTypesMap(knowTypes: Set<Function>) {\n        const map = new Map<string, Function>();\n\n        knowTypes.forEach(ctor => {\n            if (this.nameResolver === undefined) {\n                const knownTypeMeta = JsonObjectMetadata.getFromConstructor(ctor);\n                const customName = knownTypeMeta?.isExplicitlyMarked === true\n                    ? knownTypeMeta.name\n                    : null;\n                map.set(customName ?? ctor.name, ctor);\n            } else {\n                map.set(this.nameResolver(ctor), ctor);\n            }\n        });\n\n        return map;\n    }\n\n    retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n\n    private isExpectedMapShape(source: any, expectedShape: MapShape): boolean {\n        return (expectedShape === MapShape.ARRAY && Array.isArray(source))\n            || (expectedShape === MapShape.OBJECT && typeof source === 'object');\n    }\n}\n\nfunction throwTypeMismatchError(\n    targetType: string,\n    expectedSourceType: string,\n    actualSourceType: string,\n    memberName: string,\n): never {\n    throw new TypeError(\n        `Could not deserialize ${memberName} as ${targetType}:`\n        + ` expected ${expectedSourceType}, got ${actualSourceType}.`,\n    );\n}\n\nfunction makeTypeErrorMessage(\n    expectedType: Function | string,\n    actualType: Function | string,\n    memberName: string,\n) {\n    const expectedTypeName = typeof expectedType === 'function'\n        ? nameof(expectedType)\n        : expectedType;\n    const actualTypeName = typeof actualType === 'function' ? nameof(actualType) : actualType;\n\n    return `Could not deserialize ${memberName}: expected '${expectedTypeName}',`\n        + ` got '${actualTypeName}'.`;\n}\n\nfunction srcTypeNameForDebug(sourceObject: any) {\n    return sourceObject == null ? 'undefined' : nameof(sourceObject.constructor);\n}\n\nfunction deserializeDirectly<T extends string | number | boolean>(\n    sourceObject: T,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    objectName: string,\n): T {\n    if (sourceObject.constructor !== typeDescriptor.ctor) {\n        throw new TypeError(makeTypeErrorMessage(\n            nameof(typeDescriptor.ctor),\n            sourceObject.constructor,\n            objectName,\n        ));\n    }\n    return sourceObject;\n}\n\nfunction convertAsObject<T>(\n    sourceObject: IndexedObject,\n    typeDescriptor: ConcreteTypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n): IndexedObject | T | undefined {\n    if (typeof sourceObject as any !== 'object' || sourceObject as any === null) {\n        deserializer.getErrorHandler()(new TypeError(\n            `Cannot deserialize ${memberName}: 'sourceObject' must be a defined object.`,\n        ));\n        return undefined;\n    }\n\n    let expectedSelfType = typeDescriptor.ctor;\n    let sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(expectedSelfType);\n    let knownTypeConstructors = knownTypes;\n    let typeResolver = deserializer.getTypeResolver();\n\n    if (sourceObjectMetadata !== undefined) {\n        // Merge known types received from \"above\" with known types defined on the current type.\n        knownTypeConstructors = deserializer.mergeKnownTypes(\n            knownTypeConstructors,\n            deserializer.createKnownTypesMap(sourceObjectMetadata.knownTypes),\n        );\n        if (sourceObjectMetadata.typeResolver != null) {\n            typeResolver = sourceObjectMetadata.typeResolver;\n        }\n    }\n\n    // Check if a type-hint is available from the source object.\n    const typeFromTypeHint = typeResolver(sourceObject, knownTypeConstructors);\n\n    if (typeFromTypeHint != null) {\n        // Check if type hint is a valid subtype of the expected source type.\n        if (isSubtypeOf(typeFromTypeHint, expectedSelfType)) {\n            // Hell yes.\n            expectedSelfType = typeFromTypeHint;\n            sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(typeFromTypeHint);\n\n            if (sourceObjectMetadata !== undefined) {\n                // Also merge new known types from subtype.\n                knownTypeConstructors = deserializer.mergeKnownTypes(\n                    knownTypeConstructors,\n                    deserializer.createKnownTypesMap(sourceObjectMetadata.knownTypes),\n                );\n            }\n        }\n    }\n\n    if (sourceObjectMetadata?.isExplicitlyMarked === true) {\n        const sourceMetadata = sourceObjectMetadata;\n        // Strong-typed deserialization available, get to it.\n        // First deserialize properties into a temporary object.\n        const sourceObjectWithDeserializedProperties = {} as IndexedObject;\n\n        const classOptions = mergeOptions(deserializer.options, sourceMetadata.options);\n\n        // Deserialize by expected properties.\n        sourceMetadata.dataMembers.forEach((objMemberMetadata, propKey) => {\n            const objMemberValue = sourceObject[propKey];\n            const objMemberDebugName = `${nameof(sourceMetadata.classType)}.${propKey}`;\n            const objMemberOptions = mergeOptions(classOptions, objMemberMetadata.options);\n\n            let revivedValue;\n            if (objMemberMetadata.deserializer != null) {\n                revivedValue = objMemberMetadata.deserializer(objMemberValue);\n            } else if (objMemberMetadata.type == null) {\n                throw new TypeError(\n                    `Cannot deserialize ${objMemberDebugName} there is`\n                    + ` no constructor nor deserialization function to use.`,\n                );\n            } else {\n                revivedValue = deserializer.convertSingleValue(\n                    objMemberValue,\n                    objMemberMetadata.type,\n                    knownTypeConstructors,\n                    objMemberDebugName,\n                    objMemberOptions,\n                );\n            }\n\n            // @todo revivedValue will never be null in RHS of ||\n            if (isValueDefined(revivedValue)\n                || (deserializer.retrievePreserveNull(objMemberOptions)\n                    && revivedValue as any === null)\n            ) {\n                sourceObjectWithDeserializedProperties[objMemberMetadata.key] = revivedValue;\n            } else if (objMemberMetadata.isRequired === true) {\n                deserializer.getErrorHandler()(new TypeError(\n                    `Missing required member '${objMemberDebugName}'.`,\n                ));\n            }\n        });\n\n        // Next, instantiate target object.\n        let targetObject: IndexedObject;\n\n        if (typeof sourceObjectMetadata.initializerCallback === 'function') {\n            try {\n                targetObject = sourceObjectMetadata.initializerCallback(\n                    sourceObjectWithDeserializedProperties,\n                    sourceObject,\n                );\n\n                // Check the validity of user-defined initializer callback.\n                if (targetObject as any == null) {\n                    throw new TypeError(\n                        `Cannot deserialize ${memberName}:`\n                        + ` 'initializer' function returned undefined/null`\n                        + `, but '${nameof(sourceObjectMetadata.classType)}' was expected.`,\n                    );\n                } else if (!(targetObject instanceof sourceObjectMetadata.classType)) {\n                    throw new TypeError(\n                        `Cannot deserialize ${memberName}:`\n                        + `'initializer' returned '${nameof(targetObject.constructor)}'`\n                        + `, but '${nameof(sourceObjectMetadata.classType)}' was expected`\n                        + `, and '${nameof(targetObject.constructor)}' is not a subtype of`\n                        + ` '${nameof(sourceObjectMetadata.classType)}'`,\n                    );\n                }\n            } catch (e) {\n                deserializer.getErrorHandler()(e);\n                return undefined;\n            }\n        } else {\n            targetObject = deserializer.instantiateType(expectedSelfType);\n        }\n\n        // Finally, assign deserialized properties to target object.\n        Object.assign(targetObject, sourceObjectWithDeserializedProperties);\n\n        // Call onDeserialized method (if any).\n        const methodName = sourceObjectMetadata.onDeserializedMethodName;\n        if (methodName != null) {\n            if (typeof (targetObject as any)[methodName] === 'function') {\n                // check for member first\n                (targetObject as any)[methodName]();\n            } else if (typeof (targetObject.constructor as any)[methodName] === 'function') {\n                // check for static\n                (targetObject.constructor as any)[methodName]();\n            } else {\n                deserializer.getErrorHandler()(new TypeError(\n                    `onDeserialized callback`\n                    + `'${nameof(sourceObjectMetadata.classType)}.${methodName}' is not a method.`,\n                ));\n            }\n        }\n\n        return targetObject;\n    } else {\n        // Untyped deserialization into Object instance.\n        const targetObject = {} as IndexedObject;\n\n        Object.keys(sourceObject).forEach(sourceKey => {\n            targetObject[sourceKey] = deserializer.convertSingleValue(\n                sourceObject[sourceKey],\n                new ConcreteTypeDescriptor(sourceObject[sourceKey].constructor),\n                knownTypes,\n                sourceKey,\n            );\n        });\n\n        return targetObject;\n    }\n}\n\nfunction convertAsArray(\n    sourceObject: any,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n    memberOptions?: OptionsBase,\n): Array<any> {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor)) {\n        throw new TypeError(\n            `Could not deserialize ${memberName} as Array: incorrect TypeDescriptor detected,`\n            + ' please use proper annotation or function for this type',\n        );\n    }\n    if (!Array.isArray(sourceObject)) {\n        deserializer.getErrorHandler()(\n            new TypeError(makeTypeErrorMessage(Array, sourceObject.constructor, memberName)),\n        );\n        return [];\n    }\n\n    if (typeDescriptor.elementType as any == null) {\n        deserializer.getErrorHandler()(\n            new TypeError(\n                `Could not deserialize ${memberName} as Array: missing constructor reference of`\n                + ` Array elements.`,\n            ),\n        );\n        return [];\n    }\n\n    return sourceObject.map(element => {\n        // If an array element fails to deserialize, substitute with undefined. This is so that the\n        // original ordering is not interrupted by faulty\n        // entries, as an Array is ordered.\n        try {\n            return deserializer.convertSingleValue(\n                element,\n                typeDescriptor.elementType,\n                knownTypes,\n                `${memberName}[]`,\n                memberOptions,\n            );\n        } catch (e) {\n            deserializer.getErrorHandler()(e);\n\n            // Keep filling the array here with undefined to keep original ordering.\n            // Note: this is just aesthetics, not returning anything produces the same result.\n            return undefined;\n        }\n    });\n}\n\nfunction convertAsSet(\n    sourceObject: any,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n    memberOptions?: OptionsBase,\n): Set<any> {\n    if (!(typeDescriptor instanceof SetTypeDescriptor)) {\n        throw new TypeError(\n            `Could not deserialize ${memberName} as Set: incorrect TypeDescriptor detected,`\n            + ` please use proper annotation or function for this type`,\n        );\n    }\n    if (!Array.isArray(sourceObject)) {\n        deserializer.getErrorHandler()(new TypeError(makeTypeErrorMessage(\n            Array,\n            sourceObject.constructor,\n            memberName,\n        )));\n        return new Set<any>();\n    }\n\n    if (typeDescriptor.elementType as any == null) {\n        deserializer.getErrorHandler()(\n            new TypeError(\n                `Could not deserialize ${memberName} as Set: missing constructor reference of`\n                + ` Set elements.`,\n            ),\n        );\n        return new Set<any>();\n    }\n\n    const resultSet = new Set<any>();\n\n    sourceObject.forEach((element, i) => {\n        try {\n            resultSet.add(deserializer.convertSingleValue(\n                element,\n                typeDescriptor.elementType,\n                knownTypes,\n                `${memberName}[${i}]`,\n                memberOptions,\n            ));\n        } catch (e) {\n            // Faulty entries are skipped, because a Set is not ordered, and skipping an entry\n            // does not affect others.\n            deserializer.getErrorHandler()(e);\n        }\n    });\n\n    return resultSet;\n}\n\nfunction isExpectedMapShape(source: any, expectedShape: MapShape): boolean {\n    return (expectedShape === MapShape.ARRAY && Array.isArray(source))\n        || (expectedShape === MapShape.OBJECT && typeof source === 'object');\n}\n\nfunction convertAsMap(\n    sourceObject: any,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n    memberOptions?: OptionsBase,\n): Map<any, any> {\n    if (!(typeDescriptor instanceof MapTypeDescriptor)) {\n        throw new TypeError(\n            `Could not deserialize ${memberName} as Map: incorrect TypeDescriptor detected,`\n            + 'please use proper annotation or function for this type',\n        );\n    }\n    const expectedShape = typeDescriptor.getCompleteOptions().shape;\n    if (!isExpectedMapShape(sourceObject, expectedShape)) {\n        const expectedType = expectedShape === MapShape.ARRAY ? Array : Object;\n        deserializer.getErrorHandler()(\n            new TypeError(makeTypeErrorMessage(expectedType, sourceObject.constructor, memberName)),\n        );\n        return new Map<any, any>();\n    }\n\n    if (typeDescriptor.keyType as any == null) {\n        deserializer.getErrorHandler()(\n            new TypeError(`Could not deserialize ${memberName} as Map: missing key constructor.`),\n        );\n        return new Map<any, any>();\n    }\n\n    if (typeDescriptor.valueType as any == null) {\n        deserializer.getErrorHandler()(\n            new TypeError(`Could not deserialize ${memberName} as Map: missing value constructor.`),\n        );\n        return new Map<any, any>();\n    }\n\n    const resultMap = new Map<any, any>();\n\n    if (expectedShape === MapShape.OBJECT) {\n        Object.keys(sourceObject).forEach(key => {\n            try {\n                const resultKey = deserializer.convertSingleValue(\n                    key,\n                    typeDescriptor.keyType,\n                    knownTypes,\n                    memberName,\n                    memberOptions,\n                );\n                if (isValueDefined(resultKey)) {\n                    resultMap.set(\n                        resultKey,\n                        deserializer.convertSingleValue(\n                            sourceObject[key],\n                            typeDescriptor.valueType,\n                            knownTypes,\n                            `${memberName}[${resultKey}]`,\n                            memberOptions,\n                        ),\n                    );\n                }\n            } catch (e) {\n                // Faulty entries are skipped, because a Map is not ordered,\n                // and skipping an entry does not affect others.\n                deserializer.getErrorHandler()(e);\n            }\n        });\n    } else {\n        sourceObject.forEach((element: any) => {\n            try {\n                const key = deserializer.convertSingleValue(\n                    element.key,\n                    typeDescriptor.keyType,\n                    knownTypes,\n                    memberName,\n                    memberOptions,\n                );\n\n                // Undefined/null keys not supported, skip if so.\n                if (isValueDefined(key)) {\n                    resultMap.set(\n                        key,\n                        deserializer.convertSingleValue(\n                            element.value,\n                            typeDescriptor.valueType,\n                            knownTypes,\n                            `${memberName}[${key}]`,\n                            memberOptions,\n                        ),\n                    );\n                }\n            } catch (e) {\n                // Faulty entries are skipped, because a Map is not ordered,\n                // and skipping an entry does not affect others.\n                deserializer.getErrorHandler()(e);\n            }\n        });\n    }\n\n    return resultMap;\n}\n\nfunction deserializeDate(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n): Date {\n    // Support for Date with ISO 8601 format, or with numeric timestamp (milliseconds elapsed since\n    // the Epoch).\n    // ISO 8601 spec.: https://www.w3.org/TR/NOTE-datetime\n\n    if (typeof sourceObject === 'string'\n        || (typeof sourceObject === 'number' && sourceObject > 0)) {\n        return new Date(sourceObject as any);\n    } else if (sourceObject instanceof Date) {\n        return sourceObject;\n    } else {\n        throwTypeMismatchError(\n            'Date',\n            'an ISO-8601 string',\n            srcTypeNameForDebug(sourceObject),\n            memberName,\n        );\n    }\n}\n\nfunction stringToArrayBuffer(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n) {\n    if (typeof sourceObject !== 'string') {\n        throwTypeMismatchError(\n            'ArrayBuffer',\n            'a string source',\n            srcTypeNameForDebug(sourceObject),\n            memberName,\n        );\n    }\n    return createArrayBufferFromString(sourceObject);\n}\n\nfunction stringToDataView(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n) {\n    if (typeof sourceObject !== 'string') {\n        throwTypeMismatchError(\n            'DataView',\n            'a string source',\n            srcTypeNameForDebug(sourceObject),\n            memberName,\n        );\n    }\n    return new DataView(createArrayBufferFromString(sourceObject));\n}\n\nfunction createArrayBufferFromString(input: string): ArrayBuffer {\n    const buf = new ArrayBuffer(input.length * 2); // 2 bytes for each char\n    const bufView = new Uint16Array(buf);\n\n    for (let i = 0, strLen = input.length; i < strLen; i++) {\n        bufView[i] = input.charCodeAt(i);\n    }\n\n    return buf;\n}\n\nfunction convertAsFloatArray<T extends Float32Array | Float64Array>(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n): T {\n    const constructor = typeDescriptor.ctor as Constructor<T>;\n    if (Array.isArray(sourceObject) && sourceObject.every(elem => !isNaN(elem))) {\n        return new constructor(sourceObject);\n    }\n    return throwTypeMismatchError(\n        constructor.name,\n        'a numeric source array',\n        srcTypeNameForDebug(sourceObject),\n        memberName,\n    );\n}\n\n// @todo: investigate bitwise and types\nfunction convertAsUintArray<T extends Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array>(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n): T {\n    const constructor = typeDescriptor.ctor as Constructor<T>;\n    if (Array.isArray(sourceObject) && sourceObject.every(elem => !isNaN(elem))) {\n        // eslint-disable-next-line no-bitwise\n        return new constructor(sourceObject.map(value => ~~value));\n    }\n    return throwTypeMismatchError(\n        typeDescriptor.ctor.name,\n        'a numeric source array',\n        srcTypeNameForDebug(sourceObject),\n        memberName,\n    );\n}\n","import {isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ensureTypeDescriptor,\n    isTypelike,\n    TypeDescriptor,\n} from './type-descriptor';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonArrayMemberOptions extends OptionsBase {\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean | null;\n\n    /** When set, an empty array is emitted if the property is undefined/uninitialized. */\n    emitDefaultValue?: boolean | null;\n\n    /** Sets array dimensions (e.g. 1 for 'number[]' or 2 for 'number[][]'). Defaults to 1. */\n    dimensions?: number | null;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string | null;\n\n    /**\n     * When set, this deserializer will be used to deserialize the member. The callee must assure\n     * the correct type.\n     */\n    deserializer?: ((json: any) => any) | null;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: ((value: any) => any) | null;\n}\n\n/**\n * Specifies that a property, of type array, is part of an object when serializing.\n * @param elementConstructor Constructor of array elements (e.g. 'Number' for 'number[]', or 'Date'\n * for 'Date[]').\n * @param options Additional options.\n */\nexport function jsonArrayMember(\n    elementConstructor: Function | TypeDescriptor,\n    options: IJsonArrayMemberOptions = {},\n) {\n    return (target: Object, propKey: string | symbol) => {\n        const decoratorName =\n            `@jsonArrayMember on ${nameof(target.constructor)}.${String(propKey)}`;\n\n        if (!isTypelike(elementConstructor)) {\n            logError(\n                `${decoratorName}: could not resolve constructor of array elements at runtime.`,\n            );\n            return;\n        }\n\n        const dimensions = options.dimensions == null ? 1 : options.dimensions;\n        if (!isNaN(dimensions) && dimensions < 1) {\n            logError(`${decoratorName}: 'dimensions' option must be at least 1.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonArrayMember' has been\n        // used on an array.\n        if (isReflectMetadataSupported\n            && Reflect.getMetadata('design:type', target, propKey) !== Array) {\n            logError(`${decoratorName}: property is not an Array. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: createArrayType(ensureTypeDescriptor(elementConstructor), dimensions),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name ?? propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n\nexport function createArrayType(\n    elementType: TypeDescriptor,\n    dimensions: number,\n): ArrayTypeDescriptor {\n    let type = new ArrayTypeDescriptor(elementType);\n    for (let i = 1; i < dimensions; ++i) {\n        type = new ArrayTypeDescriptor(type);\n    }\n    return type;\n}\n","import {\n    identity,\n    isInstanceOf,\n    isValueDefined,\n    logError,\n    nameof,\n} from './helpers';\nimport {JsonObjectMetadata, TypeHintEmitter} from './metadata';\nimport {getOptionValue, mergeOptions, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ConcreteTypeDescriptor,\n    MapShape,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from './type-descriptor';\nimport {IndexedObject, Serializable} from './types';\n\nexport function defaultTypeEmitter(\n    targetObject: IndexedObject,\n    sourceObject: IndexedObject,\n    expectedSourceType: Function,\n    sourceTypeMetadata?: JsonObjectMetadata,\n) {\n    // By default, we put a \"__type\" property on the output object if the actual object is not the\n    // same as the expected one, so that deserialization will know what to deserialize into (given\n    // the required known-types are defined, and the object is a valid subtype of the expected\n    // type).\n    if (sourceObject.constructor !== expectedSourceType) {\n        targetObject.__type = sourceTypeMetadata?.name ?? nameof(sourceObject.constructor);\n    }\n}\n\n/**\n * @param sourceObject The original object that should be serialized.\n * @param typeDescriptor Instance of TypeDescriptor containing information about expected\n * serialization.\n * @param memberName Name of the object being serialized, used for debugging purposes.\n * @param serializer Serializer instance, aiding with recursive serialization.\n * @param memberOptions If converted as a member, the member options.\n */\nexport type SerializerFn<T, TD extends TypeDescriptor, Raw> = (\n    sourceObject: T,\n    typeDescriptor: TD,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n) => Raw;\n\n/**\n * Utility class, converts a typed object tree (i.e. a tree of class instances, arrays of class\n * instances, and so on) to an untyped javascript object (also called \"simple javascript object\"),\n * and emits any necessary type hints in the process (for polymorphism).\n *\n * The converted object tree is what will be given to `JSON.stringify` to convert to string as the\n * last step, the serialization is basically like:\n *\n * (1) typed object-tree -> (2) simple JS object-tree -> (3) JSON-string\n */\nexport class Serializer {\n    options?: OptionsBase;\n    private typeHintEmitter: TypeHintEmitter = defaultTypeEmitter;\n    private errorHandler: (error: Error) => void = logError;\n    private serializationStrategy = new Map<\n        Serializable<any>,\n        SerializerFn<any, TypeDescriptor, any>\n    >([\n        // primitives\n        [Date, identity],\n        [Number, identity],\n        [String, identity],\n        [Boolean, identity],\n\n        [ArrayBuffer, convertAsArrayBuffer],\n        [DataView, convertAsDataView],\n\n        [Array, convertAsArray],\n        [Set, convertAsSet],\n        [Map, convertAsMap],\n\n        // typed arrays\n        [Float32Array, convertAsTypedArray],\n        [Float64Array, convertAsTypedArray],\n        [Int8Array, convertAsTypedArray],\n        [Uint8Array, convertAsTypedArray],\n        [Uint8ClampedArray, convertAsTypedArray],\n        [Int16Array, convertAsTypedArray],\n        [Uint16Array, convertAsTypedArray],\n        [Int32Array, convertAsTypedArray],\n        [Uint32Array, convertAsTypedArray],\n    ]);\n\n    setTypeHintEmitter(typeEmitterCallback: TypeHintEmitter) {\n        if (typeof typeEmitterCallback as any !== 'function') {\n            throw new TypeError('\\'typeEmitterCallback\\' is not a function.');\n        }\n\n        this.typeHintEmitter = typeEmitterCallback;\n    }\n\n    getTypeHintEmitter(): TypeHintEmitter {\n        return this.typeHintEmitter;\n    }\n\n    setErrorHandler(errorHandlerCallback: (error: Error) => void) {\n        if (typeof errorHandlerCallback as any !== 'function') {\n            throw new TypeError('\\'errorHandlerCallback\\' is not a function.');\n        }\n\n        this.errorHandler = errorHandlerCallback;\n    }\n\n    getErrorHandler(): (error: Error) => void {\n        return this.errorHandler;\n    }\n\n    retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n\n    /**\n     * Convert a value of any supported serializable type.\n     * The value type will be detected, and the correct serialization method will be called.\n     */\n    convertSingleValue(\n        sourceObject: any,\n        typeDescriptor: TypeDescriptor,\n        memberName: string = 'object',\n        memberOptions?: OptionsBase,\n    ): any {\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) {\n            return null;\n        }\n        if (!isValueDefined(sourceObject)) {\n            return;\n        }\n\n        if (!isInstanceOf(sourceObject, typeDescriptor.ctor)) {\n            const expectedName = nameof(typeDescriptor.ctor);\n            const actualName = nameof(sourceObject.constructor);\n\n            this.errorHandler(new TypeError(\n                `Could not serialize '${memberName}': expected '${expectedName}',`\n                + ` got '${actualName}'.`,\n            ));\n            return;\n        }\n\n        const serializer = this.serializationStrategy.get(typeDescriptor.ctor);\n        if (serializer !== undefined) {\n            return serializer(sourceObject, typeDescriptor, memberName, this, memberOptions);\n        }\n        // if not present in the strategy do property by property serialization\n        if (typeof sourceObject === 'object') {\n            return convertAsObject(sourceObject, typeDescriptor, memberName, this, memberOptions);\n        }\n        this.errorHandler(new TypeError(\n            `Could not serialize '${memberName}': don't know how to serialize this type'.`,\n        ));\n    }\n}\n\n/**\n * Performs the conversion of a typed object (usually a class instance) to a simple\n * javascript object for serialization.\n */\nfunction convertAsObject(\n    sourceObject: IndexedObject,\n    typeDescriptor: ConcreteTypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n) {\n    let sourceTypeMetadata: JsonObjectMetadata | undefined;\n    let targetObject: IndexedObject;\n    let typeHintEmitter = serializer.getTypeHintEmitter();\n\n    if (sourceObject.constructor !== typeDescriptor.ctor\n        && sourceObject instanceof typeDescriptor.ctor) {\n        // The source object is not of the expected type, but it is a valid subtype.\n        // This is OK, and we'll proceed to gather object metadata from the subtype instead.\n        sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(sourceObject.constructor);\n    } else {\n        sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(typeDescriptor.ctor);\n    }\n\n    if (sourceTypeMetadata === undefined) {\n        // Untyped serialization, \"as-is\", we'll just pass the object on.\n        // We'll clone the source object, because type hints are added to the object itself, and we\n        // don't want to modify\n        // to the original object.\n        targetObject = {...sourceObject};\n    } else {\n        const beforeSerializationMethodName = sourceTypeMetadata.beforeSerializationMethodName;\n        if (beforeSerializationMethodName != null) {\n            if (typeof (sourceObject as any)[beforeSerializationMethodName] === 'function') {\n                // check for member first\n                (sourceObject as any)[beforeSerializationMethodName]();\n            } else if (typeof (sourceObject.constructor as any)[beforeSerializationMethodName]\n                === 'function') {\n                // check for static\n                (sourceObject.constructor as any)[beforeSerializationMethodName]();\n            } else {\n                serializer.getErrorHandler()(new TypeError(\n                    `beforeSerialization callback '`\n                    + `${nameof(sourceTypeMetadata.classType)}.${beforeSerializationMethodName}`\n                    + `' is not a method.`,\n                ));\n            }\n        }\n\n        const sourceMeta = sourceTypeMetadata;\n        // Strong-typed serialization available.\n        // We'll serialize by members that have been marked with @jsonMember (including\n        // array/set/map members), and perform recursive conversion on each of them. The converted\n        // objects are put on the 'targetObject', which is what will be put into 'JSON.stringify'\n        // finally.\n        targetObject = {};\n\n        const classOptions = mergeOptions(serializer.options, sourceMeta.options);\n        if (sourceMeta.typeHintEmitter != null) {\n            typeHintEmitter = sourceMeta.typeHintEmitter;\n        }\n\n        sourceMeta.dataMembers.forEach((objMemberMetadata) => {\n            const objMemberOptions = mergeOptions(classOptions, objMemberMetadata.options);\n            let serialized;\n            if (objMemberMetadata.serializer != null) {\n                serialized = objMemberMetadata.serializer(sourceObject[objMemberMetadata.key]);\n            } else if (objMemberMetadata.type == null) {\n                throw new TypeError(\n                    `Could not serialize ${objMemberMetadata.name}, there is`\n                    + ` no constructor nor serialization function to use.`,\n                );\n            } else {\n                serialized = serializer.convertSingleValue(\n                    sourceObject[objMemberMetadata.key],\n                    objMemberMetadata.type,\n                    `${nameof(sourceMeta.classType)}.${objMemberMetadata.key}`,\n                    objMemberOptions,\n                );\n            }\n\n            if ((serializer.retrievePreserveNull(objMemberOptions) && serialized === null)\n                || isValueDefined(serialized)\n            ) {\n                targetObject[objMemberMetadata.name] = serialized;\n            }\n        });\n    }\n\n    // Add type-hint.\n    typeHintEmitter(targetObject, sourceObject, typeDescriptor.ctor, sourceTypeMetadata);\n\n    return targetObject;\n}\n\n/**\n * Performs the conversion of an array of typed objects (or primitive values) to an array of simple\n * javascript objects\n * (or primitive values) for serialization.\n */\nfunction convertAsArray(\n    sourceObject: Array<any>,\n    typeDescriptor: TypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n): Array<any> {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor)) {\n        throw new TypeError(\n            `Could not serialize ${memberName} as Array: incorrect TypeDescriptor detected, please`\n            + ' use proper annotation or function for this type',\n        );\n    }\n    if (typeDescriptor.elementType as any == null) {\n        throw new TypeError(\n            `Could not serialize ${memberName} as Array: missing element type definition.`,\n        );\n    }\n\n    // Check the type of each element, individually.\n    // If at least one array element type is incorrect, we return undefined, which results in no\n    // value emitted during serialization. This is so that invalid element types don't unexpectedly\n    // alter the ordering of other, valid elements, and that no unexpected undefined values are in\n    // the emitted array.\n    sourceObject.forEach((element, i) => {\n        if (!(serializer.retrievePreserveNull(memberOptions) && element === null)\n            && !isInstanceOf(element, typeDescriptor.elementType.ctor)\n        ) {\n            const expectedTypeName = nameof(typeDescriptor.elementType.ctor);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            const actualTypeName = element && nameof(element.constructor);\n            throw new TypeError(`Could not serialize ${memberName}[${i}]:`\n                + ` expected '${expectedTypeName}', got '${actualTypeName}'.`);\n        }\n    });\n\n    return sourceObject.map(element => {\n        return serializer.convertSingleValue(\n            element,\n            typeDescriptor.elementType,\n            memberName,\n            memberOptions,\n        );\n    });\n}\n\n/**\n * Performs the conversion of a set of typed objects (or primitive values) into an array\n * of simple javascript objects.\n * @returns\n */\nfunction convertAsSet(\n    sourceObject: Set<any>,\n    typeDescriptor: TypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n): Array<any> {\n    if (!(typeDescriptor instanceof SetTypeDescriptor)) {\n        throw new TypeError(\n            `Could not serialize ${memberName} as Set: incorrect TypeDescriptor detected, please`\n            + ' use proper annotation or function for this type',\n        );\n    }\n    if (typeDescriptor.elementType as any == null) {\n        throw new TypeError(\n            `Could not serialize ${memberName} as Set: missing element type definition.`,\n        );\n    }\n\n    const resultArray: Array<any> = [];\n\n    // Convert each element of the set, and put it into an output array.\n    // The output array is the one serialized, as JSON.stringify does not support Set serialization.\n    // (TODO: clarification needed)\n    sourceObject.forEach(element => {\n        const resultElement = serializer.convertSingleValue(\n            element,\n            typeDescriptor.elementType,\n            memberName,\n            memberOptions,\n        );\n\n        // Add to output if the source element was undefined, OR the converted element is defined.\n        // This will add intentionally undefined values to output, but not values that became\n        // undefined\n        // DURING serializing (usually because of a type-error).\n        if (!isValueDefined(element) || isValueDefined(resultElement)) {\n            resultArray.push(resultElement);\n        }\n    });\n\n    return resultArray;\n}\n\n/**\n * Performs the conversion of a map of typed objects (or primitive values) into an array\n * of simple javascript objects with `key` and `value` properties.\n */\nfunction convertAsMap(\n    sourceObject: Map<any, any>,\n    typeDescriptor: TypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n): IndexedObject | Array<{key: any; value: any}> {\n    if (!(typeDescriptor instanceof MapTypeDescriptor)) {\n        throw new TypeError(\n            `Could not serialize ${memberName} as Map: incorrect TypeDescriptor detected, please`\n            + ' use proper annotation or function for this type',\n        );\n    }\n    if (typeDescriptor.valueType as any == null) { // @todo Check type\n        throw new TypeError(\n            `Could not serialize ${memberName} as Map: missing value type definition.`,\n        );\n    }\n\n    if (typeDescriptor.keyType as any == null) { // @todo Check type\n        throw new TypeError(\n            `Could not serialize ${memberName} as Map: missing key type definition.`,\n        );\n    }\n\n    // const resultArray: Array<{ key: any, value: any }> = [];\n    const resultShape = typeDescriptor.getCompleteOptions().shape;\n    const result = resultShape === MapShape.OBJECT ? ({} as IndexedObject) : [];\n    const preserveNull = serializer.retrievePreserveNull(memberOptions);\n\n    // Convert each *entry* in the map to a simple javascript object with key and value properties.\n    sourceObject.forEach((value, key) => {\n        const resultKeyValuePairObj = {\n            key: serializer.convertSingleValue(\n                key,\n                typeDescriptor.keyType,\n                memberName,\n                memberOptions,\n            ),\n            value: serializer.convertSingleValue(\n                value,\n                typeDescriptor.valueType,\n                memberName,\n                memberOptions,\n            ),\n        };\n\n        // We are not going to emit entries with undefined keys OR undefined values.\n        const keyDefined = isValueDefined(resultKeyValuePairObj.key);\n        const valueDefined = (resultKeyValuePairObj.value === null && preserveNull)\n            || isValueDefined(resultKeyValuePairObj.value);\n        if (keyDefined && valueDefined) {\n            if (resultShape === MapShape.OBJECT) {\n                result[resultKeyValuePairObj.key] = resultKeyValuePairObj.value;\n            } else {\n                result.push(resultKeyValuePairObj);\n            }\n        }\n    });\n\n    return result;\n}\n\n/**\n * Performs the conversion of a typed javascript array to a simple untyped javascript array.\n * This is needed because typed arrays are otherwise serialized as objects, so we'll end up\n * with something like \"{ 0: 0, 1: 1, ... }\".\n */\nfunction convertAsTypedArray(sourceObject: ArrayBufferView) {\n    return Array.from(sourceObject as any);\n}\n\n/**\n * Performs the conversion of a raw ArrayBuffer to a string.\n */\nfunction convertAsArrayBuffer(buffer: ArrayBuffer) {\n    // ArrayBuffer -> 16-bit character codes -> character array -> joined string.\n    return Array.from(new Uint16Array(buffer))\n        .map(charCode => String.fromCharCode(charCode)).join('');\n}\n\n/**\n * Performs the conversion of DataView, converting its internal ArrayBuffer to a string and\n * returning that string.\n */\nfunction convertAsDataView(dataView: DataView) {\n    return convertAsArrayBuffer(dataView.buffer);\n}\n","import {defaultTypeResolver, Deserializer} from './typedjson/deserializer';\nimport {logError, logWarning, nameof, parseToJSObject} from './typedjson/helpers';\nimport {createArrayType} from './typedjson/json-array-member';\nimport {JsonObjectMetadata, TypeHintEmitter, TypeResolver} from './typedjson/metadata';\nimport {extractOptionBase, OptionsBase} from './typedjson/options-base';\nimport {defaultTypeEmitter, Serializer} from './typedjson/serializer';\nimport {ensureTypeDescriptor, MapT, SetT} from './typedjson/type-descriptor';\nimport {Constructor, IndexedObject, Serializable} from './typedjson/types';\n\nexport type JsonTypes = Object | boolean | string | number | null | undefined;\nexport {defaultTypeResolver, defaultTypeEmitter};\n\nexport interface ITypedJSONSettings extends OptionsBase {\n    /**\n     * Sets the handler callback to invoke on errors during serializing and deserializing.\n     * Re-throwing errors in this function will halt serialization/deserialization.\n     * The default behavior is to log errors to the console.\n     */\n    errorHandler?: ((e: Error) => void) | null;\n\n    /**\n     * Sets a callback that determines the constructor of the correct sub-type of polymorphic\n     * objects while deserializing.\n     * The default behavior is to read the type-name from the '__type' property of 'sourceObject',\n     * and look it up in 'knownTypes'.\n     * The constructor of the sub-type should be returned.\n     */\n    typeResolver?: TypeResolver | null;\n\n    nameResolver?: ((ctor: Function) => string) | null;\n\n    /**\n     * Sets a callback that writes type-hints to serialized objects.\n     * The default behavior is to write the type-name to the '__type' property, if a derived type\n     * is present in place of a base type.\n     */\n    typeHintEmitter?: TypeHintEmitter | null;\n\n    /**\n     * Sets the amount of indentation to use in produced JSON strings.\n     * Default value is 0, or no indentation.\n     */\n    indent?: number | null;\n\n    replacer?: ((key: string, value: any) => any) | null;\n\n    knownTypes?: Array<Constructor<any>> | null;\n}\n\nexport class TypedJSON<T> {\n\n    private static _globalConfig: ITypedJSONSettings | null | undefined;\n\n    private serializer: Serializer = new Serializer();\n    private deserializer: Deserializer<T> = new Deserializer<T>();\n    private globalKnownTypes: Array<Constructor<any>> = [];\n    private indent: number = 0;\n    private rootConstructor: Serializable<T>;\n    private errorHandler: (e: Error) => void;\n    private nameResolver: (ctor: Function) => string;\n    private replacer?: (key: string, value: any) => any;\n\n    /**\n     * Creates a new TypedJSON instance to serialize (stringify) and deserialize (parse) object\n     *     instances of the specified root class type.\n     * @param rootConstructor The constructor of the root class type.\n     * @param settings Additional configuration settings.\n     */\n    constructor(rootConstructor: Serializable<T>, settings?: ITypedJSONSettings) {\n        const rootMetadata = JsonObjectMetadata.getFromConstructor(rootConstructor);\n\n        if (rootMetadata === undefined\n            || (!rootMetadata.isExplicitlyMarked && !rootMetadata.isHandledWithoutAnnotation)) {\n            throw new TypeError(\n                'The TypedJSON root data type must have the @jsonObject decorator used.',\n            );\n        }\n\n        this.nameResolver = (ctor) => nameof(ctor);\n        this.rootConstructor = rootConstructor;\n        this.errorHandler = (error) => logError(error);\n\n        if (settings !== undefined) {\n            this.config(settings);\n        } else if (TypedJSON._globalConfig !== undefined) {\n            this.config({});\n        }\n    }\n\n    static parse<T>(\n        object: any,\n        rootType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): T | undefined {\n        return new TypedJSON(rootType, settings).parse(object);\n    }\n\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: 1,\n    ): Array<T>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 2,\n    ): Array<Array<T>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 3,\n    ): Array<Array<Array<T>>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 4,\n    ): Array<Array<Array<Array<T>>>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 5,\n    ): Array<Array<Array<Array<Array<T>>>>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: number,\n    ): Array<any> {\n        return new TypedJSON(elementType, settings).parseAsArray(object, dimensions as any);\n    }\n\n    static parseAsSet<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): Set<T> {\n        return new TypedJSON(elementType, settings).parseAsSet(object);\n    }\n\n    static parseAsMap<K, V>(\n        object: any,\n        keyType: Serializable<K>,\n        valueType: Serializable<V>,\n        settings?: ITypedJSONSettings,\n    ): Map<K, V> {\n        return new TypedJSON(valueType, settings).parseAsMap(object, keyType);\n    }\n\n    static toPlainJson<T>(\n        object: T,\n        rootType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): JsonTypes {\n        return new TypedJSON(rootType, settings).toPlainJson(object);\n    }\n\n    static toPlainArray<T>(\n        object: Array<T>,\n        elementType: Serializable<T>,\n        dimensions?: 1,\n        settings?: ITypedJSONSettings,\n    ): Array<Object>;\n    static toPlainArray<T>(\n        object: Array<Array<T>>,\n        elementType: Serializable<T>,\n        dimensions: 2,\n        settings?: ITypedJSONSettings,\n    ): Array<Array<Object>>;\n    static toPlainArray<T>(\n        object: Array<Array<Array<T>>>,\n        elementType: Serializable<T>,\n        dimensions: 3,\n        settings?: ITypedJSONSettings,\n    ): Array<Array<Array<Object>>>;\n    static toPlainArray<T>(\n        object: Array<Array<Array<Array<T>>>>,\n        elementType: Serializable<T>,\n        dimensions: 4, settings?: ITypedJSONSettings,\n    ): Array<Array<Array<Array<Object>>>>;\n    static toPlainArray<T>(\n        object: Array<Array<Array<Array<Array<T>>>>>,\n        elementType: Serializable<T>,\n        dimensions: 5,\n        settings?: ITypedJSONSettings,\n    ): Array<Array<Array<Array<Array<Object>>>>>;\n    static toPlainArray<T>(\n        object: Array<any>,\n        elementType: Serializable<T>,\n        dimensions: number,\n        settings?: ITypedJSONSettings,\n    ): Array<any>;\n    static toPlainArray<T>(\n        object: Array<any>,\n        elementType: Serializable<T>,\n        dimensions?: any,\n        settings?: ITypedJSONSettings,\n    ): Array<any> {\n        return new TypedJSON(elementType, settings).toPlainArray(object, dimensions);\n    }\n\n    static toPlainSet<T>(\n        object: Set<T>,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): Array<Object> | undefined {\n        return new TypedJSON(elementType, settings).toPlainSet(object);\n    }\n\n    static toPlainMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Serializable<K>,\n        valueCtor: Serializable<V>,\n        settings?: ITypedJSONSettings,\n    ): IndexedObject | Array<{key: any; value: any}> | undefined {\n        return new TypedJSON(valueCtor, settings).toPlainMap(object, keyCtor);\n    }\n\n    static stringify<T>(\n        object: T,\n        rootType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(rootType, settings).stringify(object);\n    }\n\n    static stringifyAsArray<T>(\n        object: Array<T>,\n        elementType: Serializable<T>,\n        dimensions?: 1,\n        settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<T>>,\n        elementType: Serializable<T>,\n        dimensions: 2,\n        settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<Array<T>>>,\n        elementType: Serializable<T>,\n        dimensions: 3,\n        settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<Array<Array<T>>>>,\n        elementType: Serializable<T>,\n        dimensions: 4,\n        settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<Array<Array<Array<T>>>>>,\n        elementType: Serializable<T>,\n        dimensions: 5,\n        settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<any>,\n        elementType: Serializable<T>,\n        dimensions: number, settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<any>,\n        elementType: Serializable<T>,\n        dimensions?: any,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(elementType, settings).stringifyAsArray(object, dimensions);\n    }\n\n    static stringifyAsSet<T>(\n        object: Set<T>,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(elementType, settings).stringifyAsSet(object);\n    }\n\n    static stringifyAsMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Serializable<K>,\n        valueCtor: Serializable<V>,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(valueCtor, settings).stringifyAsMap(object, keyCtor);\n    }\n\n    static setGlobalConfig(config: ITypedJSONSettings) {\n        if (this._globalConfig == null) {\n            this._globalConfig = config;\n        } else {\n            Object.assign(this._globalConfig, config);\n        }\n    }\n\n    /**\n     * Configures TypedJSON through a settings object.\n     * @param settings The configuration settings object.\n     */\n    config(settings: ITypedJSONSettings) {\n        if (TypedJSON._globalConfig != null) {\n            settings = {\n                ...TypedJSON._globalConfig,\n                ...settings,\n            };\n\n            if (settings.knownTypes != null\n                && TypedJSON._globalConfig.knownTypes != null) {\n                // Merge known-types (also de-duplicate them, so Array -> Set -> Array).\n                settings.knownTypes = Array.from(new Set(\n                    settings.knownTypes.concat(TypedJSON._globalConfig.knownTypes),\n                ));\n            }\n        }\n\n        const options = extractOptionBase(settings);\n        this.serializer.options = options;\n        this.deserializer.options = options;\n\n        if (settings.errorHandler != null) {\n            this.errorHandler = settings.errorHandler;\n            this.deserializer.setErrorHandler(settings.errorHandler);\n            this.serializer.setErrorHandler(settings.errorHandler);\n        }\n\n        if (settings.replacer != null) {\n            this.replacer = settings.replacer;\n        }\n        if (settings.typeResolver != null) {\n            this.deserializer.setTypeResolver(settings.typeResolver);\n        }\n        if (settings.typeHintEmitter != null) {\n            this.serializer.setTypeHintEmitter(settings.typeHintEmitter);\n        }\n        if (settings.indent != null) {\n            this.indent = settings.indent;\n        }\n\n        if (settings.nameResolver != null) {\n            this.nameResolver = settings.nameResolver;\n            this.deserializer.setNameResolver(settings.nameResolver);\n        }\n\n        if (settings.knownTypes != null) {\n            // Type-check knownTypes elements to recognize errors in advance.\n            settings.knownTypes.forEach((knownType: any, i) => {\n                if (typeof knownType === 'undefined' || knownType === null) {\n                    logWarning(\n                        `TypedJSON.config: 'knownTypes' contains an undefined/null value`\n                        + ` (element ${i}).`,\n                    );\n                }\n            });\n\n            this.globalKnownTypes = settings.knownTypes;\n        }\n    }\n\n    /**\n     * Converts a JSON string to the root class type.\n     * @param object The JSON to parse and convert.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns Deserialized T or undefined if there were errors.\n     */\n    parse(object: any): T | undefined {\n        const json = parseToJSObject(object, this.rootConstructor);\n\n        const rootMetadata = JsonObjectMetadata.getFromConstructor(this.rootConstructor);\n        let result: T | undefined;\n        const knownTypes = new Map<string, Function>();\n\n        this.globalKnownTypes.filter(ktc => ktc).forEach(knownTypeCtor => {\n            knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n        });\n\n        if (rootMetadata !== undefined) {\n            rootMetadata.knownTypes.forEach(knownTypeCtor => {\n                knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n            });\n        }\n\n        try {\n            result = this.deserializer.convertSingleValue(\n                json,\n                ensureTypeDescriptor(this.rootConstructor),\n                knownTypes,\n            ) as T;\n        } catch (e) {\n            this.errorHandler(e);\n        }\n\n        return result;\n    }\n\n    parseAsArray(object: any, dimensions?: 1): Array<T>;\n    parseAsArray(object: any, dimensions: 2): Array<Array<T>>;\n    parseAsArray(object: any, dimensions: 3): Array<Array<Array<T>>>;\n    parseAsArray(object: any, dimensions: 4): Array<Array<Array<Array<T>>>>;\n    parseAsArray(object: any, dimensions: 5): Array<Array<Array<Array<Array<T>>>>>;\n    parseAsArray(object: any, dimensions: number): Array<any>;\n    parseAsArray(object: any, dimensions: number = 1): Array<any> {\n        const json = parseToJSObject(object, Array);\n        return this.deserializer.convertSingleValue(\n            json,\n            createArrayType(ensureTypeDescriptor(this.rootConstructor), dimensions),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    parseAsSet(object: any): Set<T> {\n        const json = parseToJSObject(object, Set);\n        return this.deserializer.convertSingleValue(\n            json,\n            SetT(this.rootConstructor),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    parseAsMap<K>(object: any, keyConstructor: Serializable<K>): Map<K, T> {\n        const json = parseToJSObject(object, Map);\n        return this.deserializer.convertSingleValue(\n            json,\n            MapT(keyConstructor, this.rootConstructor),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    /**\n     * Converts an instance of the specified class type to a plain JSON object.\n     * @param object The instance to convert to a JSON string.\n     * @returns Serialized object or undefined if an error has occured.\n     */\n    toPlainJson(object: T): JsonTypes {\n        try {\n            return this.serializer.convertSingleValue(\n                object,\n                ensureTypeDescriptor(this.rootConstructor),\n            );\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    toPlainArray(object: Array<T>, dimensions?: 1): Array<Object>;\n    toPlainArray(object: Array<Array<T>>, dimensions: 2): Array<Array<Object>>;\n    toPlainArray(object: Array<Array<Array<T>>>, dimensions: 3): Array<Array<Array<Object>>>;\n    toPlainArray(\n        object: Array<Array<Array<Array<T>>>>,\n        dimensions: 4,\n    ): Array<Array<Array<Array<Object>>>>;\n    toPlainArray(\n        object: Array<Array<Array<Array<Array<T>>>>>,\n        dimensions: 5,\n    ): Array<Array<Array<Array<Array<Object>>>>>;\n    toPlainArray(object: Array<any>, dimensions: 1 | 2 | 3 | 4 | 5 = 1): Array<Object> | undefined {\n        try {\n            return this.serializer.convertSingleValue(\n                object,\n                createArrayType(ensureTypeDescriptor(this.rootConstructor), dimensions),\n            );\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    toPlainSet(object: Set<T>): Array<Object> | undefined {\n        try {\n            return this.serializer.convertSingleValue(object, SetT(this.rootConstructor));\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    toPlainMap<K>(\n        object: Map<K, T>,\n        keyConstructor: Serializable<K>,\n    ): IndexedObject | Array<{key: any; value: any}> | undefined {\n        try {\n            return this.serializer.convertSingleValue(\n                object,\n                MapT(keyConstructor, this.rootConstructor),\n            );\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Converts an instance of the specified class type to a JSON string.\n     * @param object The instance to convert to a JSON string.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns String with the serialized object or an empty string if an error has occured, but\n     *     the errorHandler did not throw.\n     */\n    stringify(object: T): string {\n        const result = this.toPlainJson(object);\n        if (result === undefined) {\n            return '';\n        }\n        return JSON.stringify(result, this.replacer, this.indent);\n    }\n\n    stringifyAsArray(object: Array<T>, dimensions?: 1): string;\n    stringifyAsArray(object: Array<Array<T>>, dimensions: 2): string;\n    stringifyAsArray(object: Array<Array<Array<T>>>, dimensions: 3): string;\n    stringifyAsArray(object: Array<Array<Array<Array<T>>>>, dimensions: 4): string;\n    stringifyAsArray(object: Array<Array<Array<Array<Array<T>>>>>, dimensions: 5): string;\n    stringifyAsArray(object: Array<any>, dimensions: any): string {\n        return JSON.stringify(this.toPlainArray(object, dimensions), this.replacer, this.indent);\n    }\n\n    stringifyAsSet(object: Set<T>): string {\n        return JSON.stringify(this.toPlainSet(object), this.replacer, this.indent);\n    }\n\n    stringifyAsMap<K>(object: Map<K, T>, keyConstructor: Serializable<K>): string {\n        return JSON.stringify(this.toPlainMap(object, keyConstructor), this.replacer, this.indent);\n    }\n\n    private _mapKnownTypes(constructors: Array<Constructor<any>>) {\n        const map = new Map<string, Constructor<any>>();\n\n        constructors.filter(ctor => ctor).forEach(ctor => map.set(this.nameResolver(ctor), ctor));\n\n        return map;\n    }\n}\n","import {JsonObjectMetadata, TypeHintEmitter, TypeResolver} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {Serializable} from './types';\n\nexport type InitializerCallback<T> = (sourceObject: T, rawSourceObject: T) => T;\n\nexport interface IJsonObjectOptionsBase extends OptionsBase {\n    /**\n     * An array of known types to recognize when encountering type-hints.\n     */\n    knownTypes?: Array<Function> | null;\n\n    /**\n     * A function that will emit a type hint on the resulting JSON. It will override the global\n     * typeEmitter.\n     */\n    typeHintEmitter?: TypeHintEmitter | null;\n\n    /**\n     * A function that given a source object will resolve the type that should be instantiated.\n     * It will override the global type resolver.\n     */\n    typeResolver?: TypeResolver | null;\n\n    /**\n     * The name of a static or instance method to call when deserialization\n     * of the object is completed.\n     */\n    onDeserialized?: string | null;\n\n    /**\n     * The name of a static or instance method to call before the serialization\n     * of the typed object is started.\n     */\n    beforeSerialization?: string | null;\n\n    /**\n     * The name used to differentiate between different polymorphic types.\n     */\n    name?: string | null;\n}\n\nexport interface IJsonObjectOptionsWithInitializer<T> extends IJsonObjectOptionsBase {\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer: InitializerCallback<T>;\n}\n\nexport interface IJsonObjectOptions<T> extends IJsonObjectOptionsBase {\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer?: InitializerCallback<T> | null;\n}\n\n/**\n * Marks that a class with a parameterized constructor is serializable using TypedJSON, with\n * additional settings. The 'initializer' setting must be specified.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(\n    options?: IJsonObjectOptionsWithInitializer<T>,\n): (target: Serializable<T>) => void;\n\n/**\n * Marks that a class is serializable using TypedJSON, with additional settings.\n * @param options Configuration settings.\n */\n// eslint-disable-next-line @typescript-eslint/unified-signatures\nexport function jsonObject<T>(options?: IJsonObjectOptions<T>): (target: Serializable<T>) => void;\n\n/**\n * Marks that a class with a parameterless constructor is serializable using TypedJSON.\n */\nexport function jsonObject<T>(target: Serializable<T>): void;\n\nexport function jsonObject<T extends Object>(\n    optionsOrTarget?: IJsonObjectOptions<T> | Serializable<T>,\n): ((target: Serializable<T>) => void) | void {\n    let options: IJsonObjectOptions<T>;\n\n    if (typeof optionsOrTarget === 'function') {\n        // jsonObject is being used as a decorator, directly.\n        options = {};\n    } else {\n        // jsonObject is being used as a decorator factory.\n        options = optionsOrTarget ?? {};\n    }\n\n    function decorator(\n        target: Serializable<T>,\n    ): void {\n        // Create or obtain JsonObjectMetadata object.\n        const objectMetadata = JsonObjectMetadata.ensurePresentInPrototype(target.prototype);\n\n        // Fill JsonObjectMetadata.\n        objectMetadata.isExplicitlyMarked = true;\n        objectMetadata.onDeserializedMethodName = options.onDeserialized;\n        objectMetadata.beforeSerializationMethodName = options.beforeSerialization;\n\n        if (options.typeResolver != null) {\n            objectMetadata.typeResolver = options.typeResolver;\n        }\n        if (options.typeHintEmitter != null) {\n            objectMetadata.typeHintEmitter = options.typeHintEmitter;\n        }\n\n        // T extend Object so it is fine\n        objectMetadata.initializerCallback = options.initializer as any;\n        if (options.name != null) {\n            objectMetadata.name = options.name;\n        }\n        const optionsBase = extractOptionBase(options);\n        if (optionsBase !== undefined) {\n            objectMetadata.options = optionsBase;\n        }\n\n        if (options.knownTypes != null) {\n            options.knownTypes\n                .filter(knownType => Boolean(knownType))\n                .forEach(knownType => objectMetadata.knownTypes.add(knownType));\n        }\n    }\n\n    if (typeof optionsOrTarget === 'function') {\n        // jsonObject is being used as a decorator, directly.\n        decorator(optionsOrTarget);\n    } else {\n        // jsonObject is being used as a decorator factory.\n        return decorator;\n    }\n}\n\nfunction isSubClass<T>(target: Serializable<T>) {\n    return;\n}\n","import {\n    isReflectMetadataSupported,\n    isSubtypeOf,\n    isValueDefined,\n    logError,\n    logWarning,\n    MISSING_REFLECT_CONF_MSG,\n    nameof,\n} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ensureTypeDescriptor,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from './type-descriptor';\nimport {IndexedObject} from './types';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMemberOptions extends OptionsBase {\n    /**\n     * Sets the constructor of the property.\n     * Optional with ReflectDecorators.\n     */\n    constructor?: Function | TypeDescriptor | null;\n\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean | null;\n\n    /** When set, a default value is emitted if the property is uninitialized/undefined. */\n    emitDefaultValue?: boolean | null;\n\n    /** When set, the key on the JSON that should be used instead of the class property name. */\n    name?: string | null;\n\n    /**\n     * When set, this deserializer will be used to deserialize the member. The callee must assure\n     * the correct type.\n     */\n    deserializer?: ((json: any) => any) | null;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: ((value: any) => any) | null;\n}\n\n/**\n * Specifies that a property is part of the object when serializing, with additional options.\n * Omitting the 'constructor' option requires ReflectDecorators and that the property type is always\n * explicitly declared.\n * @param options Additional options.\n */\nexport function jsonMember(options: IJsonMemberOptions): PropertyDecorator;\n\n/**\n * Specifies that a property is part of the object when serializing.\n * This call signature requires ReflectDecorators and that the property type is always explicitly\n * declared.\n */\nexport function jsonMember<T extends Function>(\n    prototype: IndexedObject,\n    propertyKey: string | symbol,\n): void;\n\nexport function jsonMember<T extends Function>(\n    optionsOrPrototype?: IJsonMemberOptions | IndexedObject,\n    propKey?: string | symbol,\n): PropertyDecorator | void {\n    // @todo, why do we check if propkey is string or symbol? the type only allows symbol/string\n    //    The check is not required.\n    if (propKey !== undefined\n        && (typeof propKey === 'string' || typeof propKey as any === 'symbol')) {\n        const prototype = optionsOrPrototype as IndexedObject;\n        // For error messages.\n        const decoratorName = `@jsonMember on ${nameof(prototype.constructor)}.${String(propKey)}`;\n\n        // jsonMember used directly, no additional information directly available besides target and\n        // propKey.\n        // Obtain property constructor through ReflectDecorators.\n        if (!isReflectMetadataSupported) {\n            logError(\n                `${decoratorName}: ReflectDecorators is required if no 'constructor' option is`\n                + ` specified.`,\n            );\n            return;\n        }\n\n        const reflectPropCtor: Function | null | undefined =\n            Reflect.getMetadata('design:type', prototype, propKey);\n\n        if (reflectPropCtor == null) {\n            logError(\n                `${decoratorName}: could not resolve detected property constructor at runtime.${\n                    MISSING_REFLECT_CONF_MSG}`,\n            );\n            return;\n        }\n\n        const typeDescriptor = ensureTypeDescriptor(reflectPropCtor);\n        if (isSpecialPropertyType(decoratorName, typeDescriptor)) {\n            return;\n        }\n\n        injectMetadataInformation(prototype, propKey, {\n            type: typeDescriptor,\n            key: propKey.toString(),\n            name: propKey.toString(),\n        });\n    } else {\n        // jsonMember used as a decorator factory.\n        return (target: Object, _propKey: string | symbol) => {\n            const options: IJsonMemberOptions = optionsOrPrototype as IJsonMemberOptions ?? {};\n            let typeDescriptor: TypeDescriptor | undefined;\n            const decoratorName =\n                `@jsonMember on ${nameof(target.constructor)}.${String(_propKey)}`;\n\n            if (options.hasOwnProperty('constructor')) {\n                if (!isValueDefined(options.constructor)) {\n                    logError(\n                        `${decoratorName}: cannot resolve specified property constructor at`\n                        + ' runtime.',\n                    );\n                    return;\n                }\n\n                // Property constructor has been specified. Use ReflectDecorators (if available) to\n                // check whether that constructor is correct. Warn if not.\n                typeDescriptor = ensureTypeDescriptor(options.constructor);\n                if (isReflectMetadataSupported && !isSubtypeOf(\n                    typeDescriptor.ctor,\n                    Reflect.getMetadata('design:type', target, _propKey),\n                )) {\n                    logWarning(\n                        `${decoratorName}: detected property type does not match`\n                        + ` 'constructor' option.`,\n                    );\n                }\n            } else if (isReflectMetadataSupported) {\n                const reflectCtor = Reflect.getMetadata(\n                    'design:type',\n                    target,\n                    _propKey,\n                ) as Function | null | undefined;\n\n                if (reflectCtor == null) {\n                    logError(\n                        `${decoratorName}: cannot resolve detected property constructor at`\n                        + ` runtime.`,\n                    );\n                    return;\n                }\n                typeDescriptor = ensureTypeDescriptor(reflectCtor);\n            } else if (options.deserializer === undefined) {\n                logError(\n                    `${decoratorName}: ReflectDecorators is required if no 'constructor' option`\n                    + ` is specified.`,\n                );\n                return;\n            }\n\n            if (typeDescriptor !== undefined\n                && isSpecialPropertyType(decoratorName, typeDescriptor)) {\n                return;\n            }\n            injectMetadataInformation(target, _propKey, {\n                type: typeDescriptor,\n                emitDefaultValue: options.emitDefaultValue,\n                isRequired: options.isRequired,\n                options: extractOptionBase(options),\n                key: _propKey.toString(),\n                name: options.name ?? _propKey.toString(),\n                deserializer: options.deserializer,\n                serializer: options.serializer,\n            });\n        };\n    }\n}\n\nfunction isSpecialPropertyType(decoratorName: string, typeDescriptor: TypeDescriptor) {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor) && typeDescriptor.ctor === Array) {\n        logError(`${decoratorName}: property is an Array. Use the jsonArrayMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (!(typeDescriptor instanceof SetTypeDescriptor) && typeDescriptor.ctor === Set) {\n        logError(`${decoratorName}: property is a Set. Use the jsonSetMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (!(typeDescriptor instanceof MapTypeDescriptor) && typeDescriptor.ctor === Map) {\n        logError(`${decoratorName}: property is a Map. Use the jsonMapMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    return false;\n}\n","import {isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {isTypelike, SetT} from './type-descriptor';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonSetMemberOptions extends OptionsBase {\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean | null;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean | null;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string | null;\n\n    /**\n     * When set, this deserializer will be used to deserialize the member. The callee must assure\n     * the correct type.\n     */\n    deserializer?: ((json: any) => any) | null;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: ((value: any) => any) | null;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Set<T>.\n * @param elementConstructor Constructor of set elements (e.g. 'Number' for Set<number> or 'Date'\n * for Set<Date>).\n * @param options Additional options.\n */\nexport function jsonSetMember(elementConstructor: Function, options: IJsonSetMemberOptions = {}) {\n    return (target: Object, propKey: string | symbol) => {\n        // For error messages\n        const decoratorName = `@jsonSetMember on ${nameof(target.constructor)}.${String(propKey)}`;\n\n        if (!isTypelike(elementConstructor)) {\n            logError(`${decoratorName}: could not resolve constructor of set elements at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonSetMember' has been used\n        // on a set. Warn if not.\n        if (isReflectMetadataSupported\n            && Reflect.getMetadata('design:type', target, propKey) !== Set) {\n            logError(`${decoratorName}: property is not a Set. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: SetT(elementConstructor),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name ?? propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import {isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {isTypelike, MapOptions, MapT, TypeDescriptor} from './type-descriptor';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMapMemberOptions extends OptionsBase, Partial<MapOptions> {\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean | null;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean | null;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string | null;\n\n    /**\n     * When set, this deserializer will be used to deserialize the member. The callee must assure\n     * the correct type.\n     */\n    deserializer?: ((json: any) => any) | null;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: ((value: any) => any) | null;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Map<K, V>.\n * @param keyConstructor Constructor of map keys (e.g. 'Number' for 'Map<number, Date>').\n * @param valueConstructor Constructor of map values (e.g. 'Date' for 'Map<number, Date>').\n * @param options Additional options.\n */\nexport function jsonMapMember(\n    keyConstructor: Function | TypeDescriptor,\n    valueConstructor: Function | TypeDescriptor,\n    options: IJsonMapMemberOptions = {},\n) {\n    return (target: Object, propKey: string | symbol) => {\n        // For error messages\n        const decoratorName = `@jsonMapMember on ${nameof(target.constructor)}.${String(propKey)}`;\n\n        if (!isTypelike(keyConstructor)) {\n            logError(`${decoratorName}: could not resolve constructor of map keys at runtime.`);\n            return;\n        }\n\n        if (!isTypelike(valueConstructor)) {\n            logError(`${decoratorName}: could not resolve constructor of map values at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonMapMember' has been used\n        // on a map. Warn if not.\n        if (isReflectMetadataSupported\n            && Reflect.getMetadata('design:type', target, propKey) !== Map) {\n            logError(`${decoratorName}: property is not a Map. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: MapT(keyConstructor, valueConstructor, {shape: options.shape}),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name ?? propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import {TypedJSON} from '../parser';\n\n/**\n * Options for the @toJson decorator.\n */\nexport interface IToJsonOptions {\n    /**\n     * When set to true it will overwrite any toJSON already existing on the prototype.\n     */\n    overwrite?: boolean;\n}\n\n/**\n * Decorator that will generate toJSON function on the class prototype that allows\n * JSON.stringify to be used instead of TypedJSON.stringify. Under the hood it will\n * simply delegate to TypedJSON.\n * By default it will throw if the prototype already has a toJSON function defined.\n * @param target the class which prototype should be modified.\n */\nexport function toJson<T extends Object>(target: Function): void;\n/**\n * Decorator factory that accepts the options interface.\n * @param options for configuring the toJSON creation.\n */\nexport function toJson<T extends Object>(options: IToJsonOptions): ((target: Function) => void);\nexport function toJson<T extends Object>(\n    optionsOrTarget: IToJsonOptions | Function,\n): ((target: Function) => void) | void {\n    if (typeof optionsOrTarget === 'function') {\n        // used directly\n        toJsonDecorator(optionsOrTarget, {});\n        return;\n    }\n    // used as a factory\n    return (target: Function) => {\n        toJsonDecorator(target, optionsOrTarget);\n    };\n}\n\nfunction toJsonDecorator<T extends Object>(target: Function, options: IToJsonOptions): void {\n    if (options.overwrite !== true && target.prototype.toJSON !== undefined) {\n        throw new Error(`${target.name} already has toJSON defined!`);\n    }\n    target.prototype.toJSON = function toJSON() {\n        return TypedJSON.toPlainJson(this, Object.getPrototypeOf(this).constructor);\n    };\n}\n","export {\n    TypedJSON,\n    ITypedJSONSettings,\n    JsonTypes,\n    defaultTypeResolver,\n    defaultTypeEmitter,\n} from './parser';\nexport {TypeResolver, TypeHintEmitter, JsonObjectMetadata} from './typedjson/metadata';\nexport {jsonObject} from './typedjson/json-object';\nexport {jsonMember} from './typedjson/json-member';\nexport {jsonArrayMember} from './typedjson/json-array-member';\nexport {jsonSetMember} from './typedjson/json-set-member';\nexport {jsonMapMember} from './typedjson/json-map-member';\nexport {toJson} from './typedjson/to-json';\nexport {ArrayT, SetT, MapT} from './typedjson/type-descriptor';\n"],"sourceRoot":""}
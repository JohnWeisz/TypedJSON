{"version":3,"sources":["webpack://typedjson/webpack/universalModuleDefinition","webpack://typedjson/webpack/bootstrap","webpack://typedjson/./src/typedjson/helpers.ts","webpack://typedjson/./src/typedjson/metadata.ts","webpack://typedjson/./src/typedjson/options-base.ts","webpack://typedjson/./src/typedjson/type-descriptor.ts","webpack://typedjson/./src/typedjson/deserializer.ts","webpack://typedjson/./src/typedjson/json-array-member.ts","webpack://typedjson/./src/typedjson/serializer.ts","webpack://typedjson/./src/parser.ts","webpack://typedjson/./src/typedjson/json-object.ts","webpack://typedjson/./src/typedjson/json-member.ts","webpack://typedjson/./src/typedjson/json-set-member.ts","webpack://typedjson/./src/typedjson/json-map-member.ts","webpack://typedjson/./src/typedjson/to-json.ts","webpack://typedjson/./src/typedjson.ts"],"names":[],"mappings":"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","file":"typedjson.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"typedjson\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"typedjson\"] = factory();\n\telse\n\t\troot[\"typedjson\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import {Serializable} from './types';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport const MISSING_REFLECT_CONF_MSG = 'Are you sure, that you have both \"experimentalDecorators\"'\n    + ' and \"emitDecoratorMetadata\" in your tsconfig.json?';\n\n/**\n * Determines whether the specified type is a type that can be passed on \"as-is\" into\n * `JSON.stringify`.\n * Values of these types don't need special conversion.\n * @param type The constructor of the type (wrapper constructor for primitive types, e.g. `Number`\n * for `number`).\n */\nexport function isDirectlySerializableNativeType(type: Function): boolean {\n    return Boolean(~[Date, Number, String, Boolean].indexOf(type as any));\n}\n\nexport function isDirectlyDeserializableNativeType(type: Function): boolean {\n    return Boolean(~[Number, String, Boolean].indexOf(type as any));\n}\n\nexport function isTypeTypedArray(type: Function): boolean {\n    return Boolean(~[\n        Float32Array,\n        Float64Array,\n        Int8Array,\n        Uint8Array,\n        Uint8ClampedArray,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n    ].indexOf(type as any));\n}\n\nexport function isObject(value: any): value is Object {\n    return typeof value === 'object';\n}\n\nfunction shouldOmitParseString(jsonStr: string, expectedType: Function): boolean {\n    const expectsTypesSerializedAsStrings = expectedType === String\n        || expectedType === ArrayBuffer\n        || expectedType === DataView;\n\n    const hasQuotes = jsonStr.length >= 2\n        && jsonStr[0] === '\"'\n        && jsonStr[jsonStr.length - 1] === '\"';\n    const isInteger = /^\\d+$/.test(jsonStr.trim());\n\n    return (expectsTypesSerializedAsStrings && !hasQuotes)\n        || ((!hasQuotes && !isInteger) && expectedType === Date);\n}\n\nexport function parseToJSObject<T>(json: any, expectedType: Serializable<T>): Object {\n    if (typeof json !== 'string' || shouldOmitParseString(json, expectedType)) {\n        return json;\n    }\n    return JSON.parse(json);\n}\n\n/**\n * Determines if 'A' is a sub-type of 'B' (or if 'A' equals 'B').\n * @param A The supposed derived type.\n * @param B The supposed base type.\n */\nexport function isSubtypeOf(A: Function, B: Function) {\n    return A === B || A.prototype instanceof B;\n}\n\nexport function logError(message?: any, ...optionalParams: Array<any>) {\n    if (typeof console === 'object' && typeof console.error === 'function') {\n        console.error(message, ...optionalParams);\n    } else if (typeof console === 'object' && typeof console.log === 'function') {\n        console.log(`ERROR: ${message}`, ...optionalParams);\n    }\n}\n\nexport function logMessage(message?: any, ...optionalParams: Array<any>) {\n    if (typeof console === 'object' && typeof console.log === 'function') {\n        console.log(message, ...optionalParams);\n    }\n}\n\nexport function logWarning(message?: any, ...optionalParams: Array<any>) {\n    if (typeof console === 'object' && typeof console.warn === 'function') {\n        console.warn(message, ...optionalParams);\n    } else if (typeof console === 'object' && typeof console.log === 'function') {\n        console.log(`WARNING: ${message}`, ...optionalParams);\n    }\n}\n\n/**\n * Checks if the value is considered defined (not undefined and not null).\n * @param value\n */\nexport function isValueDefined<T>(value: T): value is Exclude<T, undefined | null> {\n    return !(typeof value === 'undefined' || value === null);\n}\n\nexport function isInstanceOf<T>(value: any, constructor: Function): boolean {\n    if (typeof value === 'number') {\n        return constructor === Number;\n    } else if (typeof value === 'string') {\n        return constructor === String;\n    } else if (typeof value === 'boolean') {\n        return constructor === Boolean;\n    } else if (isObject(value)) {\n        return value instanceof constructor;\n    }\n\n    return false;\n}\n\nexport const isReflectMetadataSupported =\n    typeof Reflect === 'object' && typeof Reflect.getMetadata === 'function';\n\n/**\n * Gets the name of a function.\n * @param fn The function whose name to get.\n */\nexport function nameof(fn: Function & {name?: string}) {\n    if (typeof fn.name === 'string') {\n        return fn.name;\n    }\n    return 'undefined';\n}\n\nexport function identity<T>(arg: T): T {\n    return arg;\n}\n","import {isDirectlySerializableNativeType, isTypeTypedArray, logError, nameof} from './helpers';\nimport {OptionsBase} from './options-base';\nimport {TypeDescriptor} from './type-descriptor';\nimport {IndexedObject, Serializable} from './types';\n\nexport const METADATA_FIELD_KEY = '__typedJsonJsonObjectMetadataInformation__';\n\nexport type TypeResolver = (\n    sourceObject: IndexedObject,\n    knownTypes: Map<string, Function>,\n) => Function | undefined | null;\nexport type TypeHintEmitter\n    = (\n        targetObject: IndexedObject,\n        sourceObject: IndexedObject,\n        expectedSourceType: Function,\n        sourceTypeMetadata?: JsonObjectMetadata,\n    ) => void;\n\nexport interface JsonMemberMetadata {\n    /** If set, a default value will be emitted for uninitialized members. */\n    emitDefaultValue?: boolean;\n\n    /** Member name as it appears in the serialized JSON. */\n    name: string;\n\n    /** Property or field key of the json member. */\n    key: string;\n\n    /** Type descriptor of the member. */\n    type?: TypeDescriptor;\n\n    /** If set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    options?: OptionsBase;\n\n    /** Custom deserializer to use. */\n    deserializer?: (json: any) => any;\n\n    /** Custom serializer to use. */\n    serializer?: (value: any) => any;\n}\n\nexport class JsonObjectMetadata {\n\n    dataMembers = new Map<string, JsonMemberMetadata>();\n\n    /** Set of known types used for polymorphic deserialization */\n    knownTypes = new Set<Serializable<any>>();\n\n    /** If present override the global function */\n    typeHintEmitter?: TypeHintEmitter;\n    /** If present override the global function */\n    typeResolver?: TypeResolver;\n    /** Gets or sets the constructor function for the jsonObject. */\n    classType: Function;\n\n    /**\n     * Indicates whether this class was explicitly annotated with @jsonObject\n     * or implicitly by @jsonMember\n     */\n    isExplicitlyMarked: boolean = false;\n\n    /**\n     * Indicates whether this type is handled without annotation. This is usually\n     * used for the builtin types (except for Maps, Sets, and normal Arrays).\n     */\n    isHandledWithoutAnnotation: boolean = false;\n\n    /** Name used to encode polymorphic type */\n    name?: string;\n\n    options?: OptionsBase;\n\n    onDeserializedMethodName?: string;\n\n    beforeSerializationMethodName?: string;\n\n    initializerCallback?: (sourceObject: Object, rawSourceObject: Object) => Object;\n\n    constructor(\n        classType: Function,\n    ) {\n        this.classType = classType;\n    }\n\n    /**\n     * Gets the name of a class as it appears in a serialized JSON string.\n     * @param ctor The constructor of a class (with or without jsonObject).\n     */\n    static getJsonObjectName(ctor: Function): string {\n        const metadata = JsonObjectMetadata.getFromConstructor(ctor);\n        return metadata === undefined ? nameof(ctor) : nameof(metadata.classType);\n    }\n\n    /**\n     * Gets jsonObject metadata information from a class.\n     * @param ctor The constructor class.\n     */\n    static getFromConstructor<T>(ctor: Serializable<T>): JsonObjectMetadata | undefined {\n        const prototype = ctor.prototype;\n        if (prototype == null) {\n            return;\n        }\n\n        let metadata: JsonObjectMetadata | undefined;\n        if (prototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n            // The class prototype contains own jsonObject metadata\n            metadata = prototype[METADATA_FIELD_KEY];\n        }\n\n        // Ignore implicitly added jsonObject (through jsonMember)\n        if (metadata?.isExplicitlyMarked === true) {\n            return metadata;\n        }\n\n        // In the end maybe it is something which we can handle directly\n        if (JsonObjectMetadata.doesHandleWithoutAnnotation(ctor)) {\n            const primitiveMeta = new JsonObjectMetadata(ctor);\n            primitiveMeta.isExplicitlyMarked = true;\n            // we do not store the metadata here to not modify builtin prototype\n            return primitiveMeta;\n        }\n    }\n\n    static ensurePresentInPrototype(prototype: IndexedObject): JsonObjectMetadata {\n        if (prototype.hasOwnProperty(METADATA_FIELD_KEY)) {\n            return prototype[METADATA_FIELD_KEY];\n        }\n        // Target has no JsonObjectMetadata associated with it yet, create it now.\n        const objectMetadata = new JsonObjectMetadata(prototype.constructor);\n\n        // Inherit json members and known types from parent @jsonObject (if any).\n        const parentMetadata: JsonObjectMetadata | undefined = prototype[METADATA_FIELD_KEY];\n        if (parentMetadata !== undefined) {\n            parentMetadata.dataMembers.forEach((memberMetadata, propKey) => {\n                objectMetadata.dataMembers.set(propKey, memberMetadata);\n            });\n            parentMetadata.knownTypes.forEach((knownType) => {\n                objectMetadata.knownTypes.add(knownType);\n            });\n            objectMetadata.typeResolver = parentMetadata.typeResolver;\n            objectMetadata.typeHintEmitter = parentMetadata.typeHintEmitter;\n        }\n\n        Object.defineProperty(prototype, METADATA_FIELD_KEY, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: objectMetadata,\n        });\n        return objectMetadata;\n    }\n\n    /**\n     * Gets the known type name of a jsonObject class for type hint.\n     * @param constructor The constructor class.\n     */\n    static getKnownTypeNameFromType(constructor: Function): string {\n        const metadata = JsonObjectMetadata.getFromConstructor(constructor);\n        return metadata === undefined ? nameof(constructor) : nameof(metadata.classType);\n    }\n\n    private static doesHandleWithoutAnnotation(ctor: Function): boolean {\n        return isDirectlySerializableNativeType(ctor) || isTypeTypedArray(ctor)\n            || ctor === DataView || ctor === ArrayBuffer;\n    }\n}\n\nexport function injectMetadataInformation(\n    prototype: IndexedObject,\n    propKey: string | symbol,\n    metadata: JsonMemberMetadata,\n) {\n    // For error messages\n    const decoratorName = `@jsonMember on ${nameof(prototype.constructor)}.${String(propKey)}`;\n\n    // When a property decorator is applied to a static member, 'constructor' is a constructor\n    // function.\n    // See:\n    // eslint-disable-next-line max-len\n    // https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md#property-decorators\n    // ... and static members are not supported here, so abort.\n    if (typeof prototype as any === 'function') {\n        logError(`${decoratorName}: cannot use a static property.`);\n        return;\n    }\n\n    // Methods cannot be serialized.\n    // symbol indexing is not supported by ts\n    if (typeof prototype[propKey as string] === 'function') {\n        logError(`${decoratorName}: cannot use a method property.`);\n        return;\n    }\n\n    // @todo check if metadata is ever undefined, if so, change parameter type\n    if (metadata as any === undefined\n        || (metadata.type === undefined && metadata.deserializer === undefined)) {\n        logError(`${decoratorName}: JsonMemberMetadata has unknown type.`);\n        return;\n    }\n\n    // Add jsonObject metadata to 'constructor' if not yet exists ('constructor' is the prototype).\n    // NOTE: this will not fire up custom serialization, as 'constructor' must be explicitly marked\n    // with '@jsonObject' as well.\n    const objectMetadata = JsonObjectMetadata.ensurePresentInPrototype(prototype);\n\n    if (metadata.deserializer === undefined) {\n        // If deserializer is not present then type must be\n        metadata.type!.getTypes().forEach(ctor => objectMetadata.knownTypes.add(ctor));\n    }\n\n    // clear metadata of undefined properties to save memory\n    (Object.keys(metadata) as [keyof JsonMemberMetadata])\n        .forEach((key) => (metadata[key] === undefined) && delete metadata[key]);\n    objectMetadata.dataMembers.set(metadata.name, metadata);\n}\n","/**\n * This options cascade through the annotations. Options set\n * in the more specific place override the previous option.\n * Ex. @jsonMember overrides TypedJson options.\n */\nexport interface OptionsBase {\n    /**\n     * Whether to preserve null in the JSON output. When false it\n     * will not emit nor store the property if its value is null.\n     * Default: false.\n     */\n    preserveNull?: boolean;\n}\n\nconst kAllOptions: Array<keyof OptionsBase> = [\n    'preserveNull',\n];\n\nexport function extractOptionBase(\n    from: {[key: string]: any} & OptionsBase,\n): OptionsBase | undefined {\n    const options = Object.keys(from)\n        .filter(key => (kAllOptions as Array<string>).indexOf(key) > -1)\n        .reduce((obj, key) => {\n            obj[key] = from[key];\n            return obj;\n        }, {} as any);\n    return Object.keys(options).length > 0 ? options : undefined;\n}\n\nexport function getDefaultOptionOf<K extends keyof OptionsBase>(key: K): Required<OptionsBase>[K] {\n    switch (key) {\n        case 'preserveNull':\n            return false;\n    }\n    // never reached\n    return null as any;\n}\n\nexport function getOptionValue<K extends keyof OptionsBase>(\n    key: K,\n    options?: OptionsBase,\n): Required<OptionsBase>[K] {\n    if (options?.[key] !== undefined) {\n        return options[key]!;\n    }\n    return getDefaultOptionOf(key);\n}\n\nexport function mergeOptions(\n    existing?: OptionsBase,\n    moreSpecific?: OptionsBase,\n): OptionsBase | undefined {\n    return moreSpecific === undefined\n        ? existing\n        : {\n\n            ...existing,\n            ...moreSpecific,\n        };\n}\n","export abstract class TypeDescriptor {\n    protected constructor(readonly ctor: Function) {\n    }\n\n    getTypes(): Array<Function> {\n        return [this.ctor];\n    }\n}\n\nexport type Typelike = TypeDescriptor | Function;\n\nexport class ConcreteTypeDescriptor extends TypeDescriptor {\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(ctor: Function) {\n        super(ctor);\n    }\n}\n\nexport abstract class GenericTypeDescriptor extends TypeDescriptor {\n    protected constructor(ctor: Function) {\n        super(ctor);\n    }\n}\n\nexport class ArrayTypeDescriptor extends GenericTypeDescriptor {\n    constructor(readonly elementType: TypeDescriptor) {\n        super(Array);\n    }\n\n    getTypes(): Array<Function> {\n        return super.getTypes().concat(this.elementType.getTypes());\n    }\n}\n\nexport function ArrayT(elementType: Typelike): ArrayTypeDescriptor {\n    return new ArrayTypeDescriptor(ensureTypeDescriptor(elementType));\n}\n\nexport class SetTypeDescriptor extends GenericTypeDescriptor {\n    constructor(readonly elementType: TypeDescriptor) {\n        super(Set);\n    }\n\n    getTypes(): Array<Function> {\n        return super.getTypes().concat(this.elementType.getTypes());\n    }\n}\n\nexport function SetT(elementType: Typelike): SetTypeDescriptor {\n    return new SetTypeDescriptor(ensureTypeDescriptor(elementType));\n}\n\nexport const enum MapShape {\n    /**\n     * A map will be serialized as an array of {key: ..., value: ...} objects.\n     */\n    ARRAY,\n\n    /**\n     * A map will be serialized as a JSON object.\n     */\n    OBJECT,\n}\n\nexport interface MapOptions {\n    /**\n     * How the map should be serialized. Default is ARRAY.\n     */\n    shape: MapShape;\n}\n\nexport class MapTypeDescriptor extends GenericTypeDescriptor {\n    constructor(\n        readonly keyType: TypeDescriptor,\n        readonly valueType: TypeDescriptor,\n        readonly options?: Partial<MapOptions>,\n    ) {\n        super(Map);\n    }\n\n    getTypes(): Array<Function> {\n        return super.getTypes().concat(this.keyType.getTypes(), this.valueType.getTypes());\n    }\n\n    getCompleteOptions(): MapOptions {\n        return {\n            shape: this.options?.shape ?? MapShape.ARRAY,\n        };\n    }\n}\n\nexport function MapT(\n    keyType: Typelike,\n    valueType: Typelike,\n    options?: Partial<MapOptions>,\n): MapTypeDescriptor {\n    return new MapTypeDescriptor(\n        ensureTypeDescriptor(keyType),\n        ensureTypeDescriptor(valueType),\n        options,\n    );\n}\n\n// TODO support for dictionary types ie. maps that are plain objects\n// export class DictionaryTypeDescriptor extends GenericTypeDescriptor {\n//     constructor(public readonly elementType: TypeDescriptor) {\n//         super(Object);\n//     }\n//\n//     getTypes(): Function[] {\n//         return super.getTypes().concat(this.elementType.getTypes());\n//     }\n// }\n//\n// export function DictT(elementType: Typelike): DictionaryTypeDescriptor {\n//     return new DictionaryTypeDescriptor(ensureTypeDescriptor(elementType));\n// }\n\nexport function isTypelike(type: any): type is Typelike {\n    return type != null && (typeof type === 'function' || type instanceof TypeDescriptor);\n}\n\nexport function ensureTypeDescriptor(type: Typelike): TypeDescriptor {\n    return type instanceof TypeDescriptor ? type : new ConcreteTypeDescriptor(type);\n}\n","import {isSubtypeOf, isValueDefined, logError, nameof} from './helpers';\nimport {JsonObjectMetadata, TypeResolver} from './metadata';\nimport {getOptionValue, mergeOptions, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ConcreteTypeDescriptor,\n    MapShape,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from './type-descriptor';\nimport {Constructor, IndexedObject, Serializable} from './types';\n\nexport function defaultTypeResolver(\n    sourceObject: IndexedObject,\n    knownTypes: Map<string, Function>,\n): Function | undefined {\n    if (sourceObject.__type != null) {\n        return knownTypes.get(sourceObject.__type);\n    }\n}\n\nexport type DeserializerFn<T, TD extends TypeDescriptor, Raw> = (\n    sourceObject: Raw,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<T>,\n    memberOptions?: OptionsBase,\n) => T;\n\n/**\n * Utility class, converts a simple/untyped javascript object-tree to a typed object-tree.\n * It is used after parsing a JSON-string.\n */\nexport class Deserializer<T> {\n    options?: OptionsBase;\n\n    private typeResolver: TypeResolver = defaultTypeResolver;\n    private nameResolver?: (ctor: Function) => string;\n    private errorHandler: (error: Error) => void = logError;\n    private deserializationStrategy = new Map<\n        Serializable<any>,\n        DeserializerFn<any, TypeDescriptor, any>\n    >([\n        // primitives\n        [Number, deserializeDirectly],\n        [String, deserializeDirectly],\n        [Boolean, deserializeDirectly],\n\n        [Date, deserializeDate],\n        [ArrayBuffer, stringToArrayBuffer],\n        [DataView, stringToDataView],\n\n        [Array, convertAsArray],\n        [Set, convertAsSet],\n        [Map, convertAsMap],\n\n        // typed arrays\n        [Float32Array, convertAsFloatArray],\n        [Float64Array, convertAsFloatArray],\n        [Uint8Array, convertAsUintArray],\n        [Uint8ClampedArray, convertAsUintArray],\n        [Uint16Array, convertAsUintArray],\n        [Uint32Array, convertAsUintArray],\n    ]);\n\n    setNameResolver(nameResolverCallback: (ctor: Function) => string) {\n        this.nameResolver = nameResolverCallback;\n    }\n\n    setTypeResolver(typeResolverCallback: TypeResolver) {\n        if (typeof typeResolverCallback !== 'function') {\n            throw new TypeError('\\'typeResolverCallback\\' is not a function.');\n        }\n\n        this.typeResolver = typeResolverCallback;\n    }\n\n    getTypeResolver(): TypeResolver {\n        return this.typeResolver;\n    }\n\n    setErrorHandler(errorHandlerCallback: (error: Error) => void) {\n        if (typeof errorHandlerCallback !== 'function') {\n            throw new TypeError('\\'errorHandlerCallback\\' is not a function.');\n        }\n\n        this.errorHandler = errorHandlerCallback;\n    }\n\n    getErrorHandler(): (error: Error) => void {\n        return this.errorHandler;\n    }\n\n    convertSingleValue(\n        sourceObject: any,\n        typeDescriptor: TypeDescriptor,\n        knownTypes: Map<string, Function>,\n        memberName = 'object',\n        memberOptions?: OptionsBase,\n    ): any {\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) {\n            return null;\n        } else if (!isValueDefined(sourceObject)) {\n            return;\n        }\n\n        const deserializer = this.deserializationStrategy.get(typeDescriptor.ctor);\n        if (deserializer !== undefined) {\n            return deserializer(\n                sourceObject,\n                typeDescriptor,\n                knownTypes,\n                memberName,\n                this,\n                memberOptions,\n            );\n        }\n\n        if (typeof sourceObject === 'object') {\n            return convertAsObject(sourceObject, typeDescriptor, knownTypes, memberName, this);\n        }\n        this.errorHandler(new TypeError(\n            `Could not deserialize '${memberName}': don't know how to deserialize this type'.`,\n        ));\n    }\n\n    instantiateType(ctor: any) {\n        return new ctor();\n    }\n\n    mergeKnownTypes(...knownTypeMaps: Array<Map<string, Function>>) {\n        const result = new Map<string, Function>();\n\n        knownTypeMaps.forEach(knownTypes => {\n            knownTypes.forEach((ctor, name) => {\n                if (this.nameResolver === undefined) {\n                    result.set(name, ctor);\n                } else {\n                    result.set(this.nameResolver(ctor), ctor);\n                }\n            });\n        });\n\n        return result;\n    }\n\n    createKnownTypesMap(knowTypes: Set<Function>) {\n        const map = new Map<string, Function>();\n\n        knowTypes.forEach(ctor => {\n            if (this.nameResolver === undefined) {\n                const knownTypeMeta = JsonObjectMetadata.getFromConstructor(ctor);\n                const name = knownTypeMeta?.isExplicitlyMarked === true ? knownTypeMeta.name : null;\n                map.set(name ?? ctor.name, ctor);\n            } else {\n                map.set(this.nameResolver(ctor), ctor);\n            }\n        });\n\n        return map;\n    }\n\n    retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n\n    private isExpectedMapShape(source: any, expectedShape: MapShape): boolean {\n        return (expectedShape === MapShape.ARRAY && Array.isArray(source))\n            || (expectedShape === MapShape.OBJECT && typeof source === 'object');\n    }\n}\n\nfunction throwTypeMismatchError(\n    targetType: string,\n    expectedSourceType: string,\n    actualSourceType: string,\n    memberName: string,\n): never {\n    throw new TypeError(\n        `Could not deserialize ${memberName} as ${targetType}:`\n        + ` expected ${expectedSourceType}, got ${actualSourceType}.`,\n    );\n}\n\nfunction makeTypeErrorMessage(\n    expectedType: Function | string,\n    actualType: Function | string,\n    memberName: string,\n) {\n    const expectedTypeName = typeof expectedType === 'function'\n        ? nameof(expectedType)\n        : expectedType;\n    const actualTypeName = typeof actualType === 'function' ? nameof(actualType) : actualType;\n\n    return `Could not deserialize ${memberName}: expected '${expectedTypeName}',`\n        + ` got '${actualTypeName}'.`;\n}\n\nfunction srcTypeNameForDebug(sourceObject: any) {\n    return sourceObject == null ? 'undefined' : nameof(sourceObject.constructor);\n}\n\nfunction deserializeDirectly<T extends string | number | boolean>(\n    sourceObject: T,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    objectName: string,\n): T {\n    if (sourceObject.constructor !== typeDescriptor.ctor) {\n        throw new TypeError(makeTypeErrorMessage(\n            nameof(typeDescriptor.ctor),\n            sourceObject.constructor,\n            objectName,\n        ));\n    }\n    return sourceObject;\n}\n\nfunction convertAsObject<T>(\n    sourceObject: IndexedObject,\n    typeDescriptor: ConcreteTypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n): IndexedObject | T | undefined {\n    if (typeof sourceObject !== 'object' || sourceObject === null) {\n        deserializer.getErrorHandler()(new TypeError(\n            `Cannot deserialize ${memberName}: 'sourceObject' must be a defined object.`,\n        ));\n        return undefined;\n    }\n\n    let expectedSelfType = typeDescriptor.ctor;\n    let sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(expectedSelfType);\n    let knownTypeConstructors = knownTypes;\n    let typeResolver = deserializer.getTypeResolver();\n\n    if (sourceObjectMetadata !== undefined) {\n        // Merge known types received from \"above\" with known types defined on the current type.\n        knownTypeConstructors = deserializer.mergeKnownTypes(\n            knownTypeConstructors,\n            deserializer.createKnownTypesMap(sourceObjectMetadata.knownTypes),\n        );\n        if (sourceObjectMetadata.typeResolver !== undefined) {\n            typeResolver = sourceObjectMetadata.typeResolver;\n        }\n    }\n\n    // Check if a type-hint is available from the source object.\n    const typeFromTypeHint = typeResolver(sourceObject, knownTypeConstructors);\n\n    if (typeFromTypeHint != null) {\n        // Check if type hint is a valid subtype of the expected source type.\n        if (isSubtypeOf(typeFromTypeHint, expectedSelfType)) {\n            // Hell yes.\n            expectedSelfType = typeFromTypeHint;\n            sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(typeFromTypeHint);\n\n            if (sourceObjectMetadata !== undefined) {\n                // Also merge new known types from subtype.\n                knownTypeConstructors = deserializer.mergeKnownTypes(\n                    knownTypeConstructors,\n                    deserializer.createKnownTypesMap(sourceObjectMetadata.knownTypes),\n                );\n            }\n        }\n    }\n\n    if (sourceObjectMetadata?.isExplicitlyMarked === true) {\n        const sourceMetadata = sourceObjectMetadata;\n        // Strong-typed deserialization available, get to it.\n        // First deserialize properties into a temporary object.\n        const sourceObjectWithDeserializedProperties = {} as IndexedObject;\n\n        const classOptions = mergeOptions(deserializer.options, sourceMetadata.options);\n\n        // Deserialize by expected properties.\n        sourceMetadata.dataMembers.forEach((objMemberMetadata, propKey) => {\n            const objMemberValue = sourceObject[propKey];\n            const objMemberDebugName = `${nameof(sourceMetadata.classType)}.${propKey}`;\n            const objMemberOptions = mergeOptions(classOptions, objMemberMetadata.options);\n\n            let revivedValue;\n            if (objMemberMetadata.deserializer !== undefined) {\n                revivedValue = objMemberMetadata.deserializer(objMemberValue);\n            } else if (objMemberMetadata.type === undefined) {\n                throw new TypeError(\n                    `Cannot deserialize ${objMemberDebugName} there is`\n                    + ` no constructor nor deserialization function to use.`,\n                );\n            } else {\n                revivedValue = deserializer.convertSingleValue(\n                    objMemberValue,\n                    objMemberMetadata.type,\n                    knownTypeConstructors,\n                    objMemberDebugName,\n                    objMemberOptions,\n                );\n            }\n\n            // @todo revivedValue will never be null in RHS of ||\n            if (isValueDefined(revivedValue)\n                || (deserializer.retrievePreserveNull(objMemberOptions)\n                    && revivedValue as any === null)\n            ) {\n                sourceObjectWithDeserializedProperties[objMemberMetadata.key] = revivedValue;\n            } else if (objMemberMetadata.isRequired === true) {\n                deserializer.getErrorHandler()(new TypeError(\n                    `Missing required member '${objMemberDebugName}'.`,\n                ));\n            }\n        });\n\n        // Next, instantiate target object.\n        let targetObject: IndexedObject;\n\n        if (typeof sourceObjectMetadata.initializerCallback === 'function') {\n            try {\n                targetObject = sourceObjectMetadata.initializerCallback(\n                    sourceObjectWithDeserializedProperties,\n                    sourceObject,\n                );\n\n                // Check the validity of user-defined initializer callback.\n                if (targetObject as any === undefined) {\n                    throw new TypeError(\n                        `Cannot deserialize ${memberName}:`\n                        + ` 'initializer' function returned undefined/null`\n                        + `, but '${nameof(sourceObjectMetadata.classType)}' was expected.`,\n                    );\n                } else if (!(targetObject instanceof sourceObjectMetadata.classType)) {\n                    throw new TypeError(\n                        `Cannot deserialize ${memberName}:`\n                        + `'initializer' returned '${nameof(targetObject.constructor)}'`\n                        + `, but '${nameof(sourceObjectMetadata.classType)}' was expected`\n                        + `, and '${nameof(targetObject.constructor)}' is not a subtype of`\n                        + ` '${nameof(sourceObjectMetadata.classType)}'`,\n                    );\n                }\n            } catch (e) {\n                deserializer.getErrorHandler()(e);\n                return undefined;\n            }\n        } else {\n            targetObject = deserializer.instantiateType(expectedSelfType);\n        }\n\n        // Finally, assign deserialized properties to target object.\n        Object.assign(targetObject, sourceObjectWithDeserializedProperties);\n\n        // Call onDeserialized method (if any).\n        const methodName = sourceObjectMetadata.onDeserializedMethodName;\n        if (methodName !== undefined) {\n            if (typeof (targetObject as any)[methodName] === 'function') {\n                // check for member first\n                (targetObject as any)[methodName]();\n            } else if (typeof (targetObject.constructor as any)[methodName] === 'function') {\n                // check for static\n                (targetObject.constructor as any)[methodName]();\n            } else {\n                deserializer.getErrorHandler()(new TypeError(\n                    `onDeserialized callback`\n                    + `'${nameof(sourceObjectMetadata.classType)}.${methodName}' is not a method.`,\n                ));\n            }\n        }\n\n        return targetObject;\n    } else {\n        // Untyped deserialization into Object instance.\n        const targetObject = {} as IndexedObject;\n\n        Object.keys(sourceObject).forEach(sourceKey => {\n            targetObject[sourceKey] = deserializer.convertSingleValue(\n                sourceObject[sourceKey],\n                new ConcreteTypeDescriptor(sourceObject[sourceKey].constructor),\n                knownTypes,\n                sourceKey,\n            );\n        });\n\n        return targetObject;\n    }\n}\n\nfunction convertAsArray(\n    sourceObject: any,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n    memberOptions?: OptionsBase,\n): Array<any> {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor)) {\n        throw new TypeError(\n            `Could not deserialize ${memberName} as Array: incorrect TypeDescriptor detected,`\n            + ' please use proper annotation or function for this type',\n        );\n    }\n    if (!Array.isArray(sourceObject)) {\n        deserializer.getErrorHandler()(\n            new TypeError(makeTypeErrorMessage(Array, sourceObject.constructor, memberName)),\n        );\n        return [];\n    }\n\n    if (typeDescriptor.elementType as any == null) {\n        deserializer.getErrorHandler()(\n            new TypeError(\n                `Could not deserialize ${memberName} as Array: missing constructor reference of`\n                + ` Array elements.`,\n            ),\n        );\n        return [];\n    }\n\n    return sourceObject.map(element => {\n        // If an array element fails to deserialize, substitute with undefined. This is so that the\n        // original ordering is not interrupted by faulty\n        // entries, as an Array is ordered.\n        try {\n            return deserializer.convertSingleValue(\n                element,\n                typeDescriptor.elementType,\n                knownTypes,\n                `${memberName}[]`,\n                memberOptions,\n            );\n        } catch (e) {\n            deserializer.getErrorHandler()(e);\n\n            // Keep filling the array here with undefined to keep original ordering.\n            // Note: this is just aesthetics, not returning anything produces the same result.\n            return undefined;\n        }\n    });\n}\n\nfunction convertAsSet(\n    sourceObject: any,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n    memberOptions?: OptionsBase,\n): Set<any> {\n    if (!(typeDescriptor instanceof SetTypeDescriptor)) {\n        throw new TypeError(\n            `Could not deserialize ${memberName} as Set: incorrect TypeDescriptor detected,`\n            + ` please use proper annotation or function for this type`,\n        );\n    }\n    if (!Array.isArray(sourceObject)) {\n        deserializer.getErrorHandler()(new TypeError(makeTypeErrorMessage(\n            Array,\n            sourceObject.constructor,\n            memberName,\n        )));\n        return new Set<any>();\n    }\n\n    if (typeDescriptor.elementType as any == null) {\n        deserializer.getErrorHandler()(\n            new TypeError(\n                `Could not deserialize ${memberName} as Set: missing constructor reference of`\n                + ` Set elements.`,\n            ),\n        );\n        return new Set<any>();\n    }\n\n    const resultSet = new Set<any>();\n\n    sourceObject.forEach((element, i) => {\n        try {\n            resultSet.add(deserializer.convertSingleValue(\n                element,\n                typeDescriptor.elementType,\n                knownTypes,\n                `${memberName}[${i}]`,\n                memberOptions,\n            ));\n        } catch (e) {\n            // Faulty entries are skipped, because a Set is not ordered, and skipping an entry\n            // does not affect others.\n            deserializer.getErrorHandler()(e);\n        }\n    });\n\n    return resultSet;\n}\n\nfunction isExpectedMapShape(source: any, expectedShape: MapShape): boolean {\n    return (expectedShape === MapShape.ARRAY && Array.isArray(source))\n        || (expectedShape === MapShape.OBJECT && typeof source === 'object');\n}\n\nfunction convertAsMap(\n    sourceObject: any,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n    deserializer: Deserializer<any>,\n    memberOptions?: OptionsBase,\n): Map<any, any> {\n    if (!(typeDescriptor instanceof MapTypeDescriptor)) {\n        throw new TypeError(\n            `Could not deserialize ${memberName} as Map: incorrect TypeDescriptor detected,`\n            + 'please use proper annotation or function for this type',\n        );\n    }\n    const expectedShape = typeDescriptor.getCompleteOptions().shape;\n    if (!isExpectedMapShape(sourceObject, expectedShape)) {\n        const expectedType = expectedShape === MapShape.ARRAY ? Array : Object;\n        deserializer.getErrorHandler()(\n            new TypeError(makeTypeErrorMessage(expectedType, sourceObject.constructor, memberName)),\n        );\n        return new Map<any, any>();\n    }\n\n    if (typeDescriptor.keyType as any == null) {\n        deserializer.getErrorHandler()(\n            new TypeError(`Could not deserialize ${memberName} as Map: missing key constructor.`),\n        );\n        return new Map<any, any>();\n    }\n\n    if (typeDescriptor.valueType as any == null) {\n        deserializer.getErrorHandler()(\n            new TypeError(`Could not deserialize ${memberName} as Map: missing value constructor.`),\n        );\n        return new Map<any, any>();\n    }\n\n    const resultMap = new Map<any, any>();\n\n    if (expectedShape === MapShape.OBJECT) {\n        Object.keys(sourceObject).forEach(key => {\n            try {\n                const resultKey = deserializer.convertSingleValue(\n                    key,\n                    typeDescriptor.keyType,\n                    knownTypes,\n                    memberName,\n                    memberOptions,\n                );\n                if (isValueDefined(resultKey)) {\n                    resultMap.set(\n                        resultKey,\n                        deserializer.convertSingleValue(\n                            sourceObject[key],\n                            typeDescriptor.valueType,\n                            knownTypes,\n                            `${memberName}[${resultKey}]`,\n                            memberOptions,\n                        ),\n                    );\n                }\n            } catch (e) {\n                // Faulty entries are skipped, because a Map is not ordered,\n                // and skipping an entry does not affect others.\n                deserializer.getErrorHandler()(e);\n            }\n        });\n    } else {\n        sourceObject.forEach((element: any) => {\n            try {\n                const key = deserializer.convertSingleValue(\n                    element.key,\n                    typeDescriptor.keyType,\n                    knownTypes,\n                    memberName,\n                    memberOptions,\n                );\n\n                // Undefined/null keys not supported, skip if so.\n                if (isValueDefined(key)) {\n                    resultMap.set(\n                        key,\n                        deserializer.convertSingleValue(\n                            element.value,\n                            typeDescriptor.valueType,\n                            knownTypes,\n                            `${memberName}[${key}]`,\n                            memberOptions,\n                        ),\n                    );\n                }\n            } catch (e) {\n                // Faulty entries are skipped, because a Map is not ordered,\n                // and skipping an entry does not affect others.\n                deserializer.getErrorHandler()(e);\n            }\n        });\n    }\n\n    return resultMap;\n}\n\nfunction deserializeDate(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n): Date {\n    // Support for Date with ISO 8601 format, or with numeric timestamp (milliseconds elapsed since\n    // the Epoch).\n    // ISO 8601 spec.: https://www.w3.org/TR/NOTE-datetime\n\n    if (typeof sourceObject === 'string'\n        || (typeof sourceObject === 'number' && sourceObject > 0)) {\n        return new Date(sourceObject as any);\n    } else if (sourceObject instanceof Date) {\n        return sourceObject;\n    } else {\n        throwTypeMismatchError(\n            'Date',\n            'an ISO-8601 string',\n            srcTypeNameForDebug(sourceObject),\n            memberName,\n        );\n    }\n}\n\nfunction stringToArrayBuffer(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n) {\n    if (typeof sourceObject !== 'string') {\n        throwTypeMismatchError(\n            'ArrayBuffer',\n            'a string source',\n            srcTypeNameForDebug(sourceObject),\n            memberName,\n        );\n    }\n    return createArrayBufferFromString(sourceObject);\n}\n\nfunction stringToDataView(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n) {\n    if (typeof sourceObject !== 'string') {\n        throwTypeMismatchError(\n            'DataView',\n            'a string source',\n            srcTypeNameForDebug(sourceObject),\n            memberName,\n        );\n    }\n    return new DataView(createArrayBufferFromString(sourceObject));\n}\n\nfunction createArrayBufferFromString(input: string): ArrayBuffer {\n    const buf = new ArrayBuffer(input.length * 2); // 2 bytes for each char\n    const bufView = new Uint16Array(buf);\n\n    for (let i = 0, strLen = input.length; i < strLen; i++) {\n        bufView[i] = input.charCodeAt(i);\n    }\n\n    return buf;\n}\n\nfunction convertAsFloatArray<T extends Float32Array | Float64Array>(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n): T {\n    const constructor = typeDescriptor.ctor as Constructor<T>;\n    if (Array.isArray(sourceObject) && sourceObject.every(elem => !isNaN(elem))) {\n        return new constructor(sourceObject);\n    }\n    return throwTypeMismatchError(\n        constructor.name,\n        'a numeric source array',\n        srcTypeNameForDebug(sourceObject),\n        memberName,\n    );\n}\n\nfunction convertAsUintArray<T extends Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array>(\n    sourceObject: string | number | Date,\n    typeDescriptor: TypeDescriptor,\n    knownTypes: Map<string, Function>,\n    memberName: string,\n): T {\n    const constructor = typeDescriptor.ctor as Constructor<T>;\n    if (Array.isArray(sourceObject) && sourceObject.every(elem => !isNaN(elem))) {\n        return new constructor(sourceObject.map(value => ~~value));\n    }\n    return throwTypeMismatchError(\n        typeDescriptor.ctor.name,\n        'a numeric source array',\n        srcTypeNameForDebug(sourceObject),\n        memberName,\n    );\n}\n","import {isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ensureTypeDescriptor,\n    isTypelike,\n    TypeDescriptor,\n} from './type-descriptor';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonArrayMemberOptions extends OptionsBase {\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, an empty array is emitted if the property is undefined/uninitialized. */\n    emitDefaultValue?: boolean;\n\n    /** Sets array dimensions (e.g. 1 for 'number[]' or 2 for 'number[][]'). Defaults to 1. */\n    dimensions?: number;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /**\n     * When set, this deserializer will be used to deserialize the member. The callee must assure\n     * the correct type.\n     */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property, of type array, is part of an object when serializing.\n * @param elementConstructor Constructor of array elements (e.g. 'Number' for 'number[]', or 'Date'\n * for 'Date[]').\n * @param options Additional options.\n */\nexport function jsonArrayMember(\n    elementConstructor: Function | TypeDescriptor,\n    options: IJsonArrayMemberOptions = {},\n) {\n    return (target: Object, propKey: string | symbol) => {\n        const decoratorName =\n            `@jsonArrayMember on ${nameof(target.constructor)}.${String(propKey)}`;\n\n        if (!isTypelike(elementConstructor)) {\n            logError(\n                `${decoratorName}: could not resolve constructor of array elements at runtime.`,\n            );\n            return;\n        }\n\n        const dimensions = options.dimensions === undefined ? 1 : options.dimensions;\n        if (!isNaN(dimensions) && dimensions < 1) {\n            logError(`${decoratorName}: 'dimensions' option must be at least 1.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonArrayMember' has been\n        // used on an array.\n        if (isReflectMetadataSupported\n            && Reflect.getMetadata('design:type', target, propKey) !== Array) {\n            logError(`${decoratorName}: property is not an Array. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: createArrayType(ensureTypeDescriptor(elementConstructor), dimensions),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name ?? propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n\nexport function createArrayType(\n    elementType: TypeDescriptor,\n    dimensions: number,\n): ArrayTypeDescriptor {\n    let type = new ArrayTypeDescriptor(elementType);\n    for (let i = 1; i < dimensions; ++i) {\n        type = new ArrayTypeDescriptor(type);\n    }\n    return type;\n}\n","import {\n    identity,\n    isInstanceOf,\n    isValueDefined,\n    logError,\n    nameof,\n} from './helpers';\nimport {JsonObjectMetadata, TypeHintEmitter} from './metadata';\nimport {getOptionValue, mergeOptions, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ConcreteTypeDescriptor,\n    MapShape,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from './type-descriptor';\nimport {IndexedObject, Serializable} from './types';\n\nexport function defaultTypeEmitter(\n    targetObject: IndexedObject,\n    sourceObject: IndexedObject,\n    expectedSourceType: Function,\n    sourceTypeMetadata?: JsonObjectMetadata,\n) {\n    // By default, we put a \"__type\" property on the output object if the actual object is not the\n    // same as the expected one, so that deserialization will know what to deserialize into (given\n    // the required known-types are defined, and the object is a valid subtype of the expected\n    // type).\n    if (sourceObject.constructor !== expectedSourceType) {\n        targetObject.__type = sourceTypeMetadata?.name ?? nameof(sourceObject.constructor);\n    }\n}\n\n/**\n * @param sourceObject The original object that should be serialized.\n * @param typeDescriptor Instance of TypeDescriptor containing information about expected\n * serialization.\n * @param memberName Name of the object being serialized, used for debugging purposes.\n * @param serializer Serializer instance, aiding with recursive serialization.\n * @param memberOptions If converted as a member, the member options.\n */\nexport type SerializerFn<T, TD extends TypeDescriptor, Raw> = (\n    sourceObject: T,\n    typeDescriptor: TD,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n) => Raw;\n\n/**\n * Utility class, converts a typed object tree (i.e. a tree of class instances, arrays of class\n * instances, and so on) to an untyped javascript object (also called \"simple javascript object\"),\n * and emits any necessary type hints in the process (for polymorphism).\n *\n * The converted object tree is what will be given to `JSON.stringify` to convert to string as the\n * last step, the serialization is basically like:\n *\n * (1) typed object-tree -> (2) simple JS object-tree -> (3) JSON-string\n */\nexport class Serializer {\n    options?: OptionsBase;\n    private typeHintEmitter: TypeHintEmitter = defaultTypeEmitter;\n    private errorHandler: (error: Error) => void = logError;\n    private serializationStrategy = new Map<\n        Serializable<any>,\n        SerializerFn<any, TypeDescriptor, any>\n    >([\n        // primitives\n        [Date, identity],\n        [Number, identity],\n        [String, identity],\n        [Boolean, identity],\n\n        [ArrayBuffer, convertAsArrayBuffer],\n        [DataView, convertAsDataView],\n\n        [Array, convertAsArray],\n        [Set, convertAsSet],\n        [Map, convertAsMap],\n\n        // typed arrays\n        [Float32Array, convertAsTypedArray],\n        [Float64Array, convertAsTypedArray],\n        [Int8Array, convertAsTypedArray],\n        [Uint8Array, convertAsTypedArray],\n        [Uint8ClampedArray, convertAsTypedArray],\n        [Int16Array, convertAsTypedArray],\n        [Uint16Array, convertAsTypedArray],\n        [Int32Array, convertAsTypedArray],\n        [Uint32Array, convertAsTypedArray],\n    ]);\n\n    setTypeHintEmitter(typeEmitterCallback: TypeHintEmitter) {\n        if (typeof typeEmitterCallback as any !== 'function') {\n            throw new TypeError('\\'typeEmitterCallback\\' is not a function.');\n        }\n\n        this.typeHintEmitter = typeEmitterCallback;\n    }\n\n    getTypeHintEmitter(): TypeHintEmitter {\n        return this.typeHintEmitter;\n    }\n\n    setErrorHandler(errorHandlerCallback: (error: Error) => void) {\n        if (typeof errorHandlerCallback as any !== 'function') {\n            throw new TypeError('\\'errorHandlerCallback\\' is not a function.');\n        }\n\n        this.errorHandler = errorHandlerCallback;\n    }\n\n    getErrorHandler(): (error: Error) => void {\n        return this.errorHandler;\n    }\n\n    retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n\n    /**\n     * Convert a value of any supported serializable type.\n     * The value type will be detected, and the correct serialization method will be called.\n     */\n    convertSingleValue(\n        sourceObject: any,\n        typeDescriptor: TypeDescriptor,\n        memberName: string = 'object',\n        memberOptions?: OptionsBase,\n    ): any {\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) {\n            return null;\n        }\n        if (!isValueDefined(sourceObject)) {\n            return;\n        }\n\n        if (!isInstanceOf(sourceObject, typeDescriptor.ctor)) {\n            const expectedName = nameof(typeDescriptor.ctor);\n            const actualName = nameof(sourceObject.constructor);\n\n            this.errorHandler(new TypeError(\n                `Could not serialize '${memberName}': expected '${expectedName}',`\n                + ` got '${actualName}'.`,\n            ));\n            return;\n        }\n\n        const serializer = this.serializationStrategy.get(typeDescriptor.ctor);\n        if (serializer !== undefined) {\n            return serializer(sourceObject, typeDescriptor, memberName, this, memberOptions);\n        }\n        // if not present in the strategy do property by property serialization\n        if (typeof sourceObject === 'object') {\n            return convertAsObject(sourceObject, typeDescriptor, memberName, this, memberOptions);\n        }\n        this.errorHandler(new TypeError(\n            `Could not serialize '${memberName}': don't know how to serialize this type'.`,\n        ));\n    }\n}\n\n/**\n * Performs the conversion of a typed object (usually a class instance) to a simple\n * javascript object for serialization.\n */\nfunction convertAsObject(\n    sourceObject: IndexedObject,\n    typeDescriptor: ConcreteTypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n) {\n    let sourceTypeMetadata: JsonObjectMetadata | undefined;\n    let targetObject: IndexedObject;\n    let typeHintEmitter = serializer.getTypeHintEmitter();\n\n    if (sourceObject.constructor !== typeDescriptor.ctor\n        && sourceObject instanceof typeDescriptor.ctor) {\n        // The source object is not of the expected type, but it is a valid subtype.\n        // This is OK, and we'll proceed to gather object metadata from the subtype instead.\n        sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(sourceObject.constructor);\n    } else {\n        sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(typeDescriptor.ctor);\n    }\n\n    if (sourceTypeMetadata === undefined) {\n        // Untyped serialization, \"as-is\", we'll just pass the object on.\n        // We'll clone the source object, because type hints are added to the object itself, and we\n        // don't want to modify\n        // to the original object.\n        targetObject = {...sourceObject};\n    } else {\n        const beforeSerializationMethodName = sourceTypeMetadata.beforeSerializationMethodName;\n        if (beforeSerializationMethodName !== undefined) {\n            if (typeof (sourceObject as any)[beforeSerializationMethodName] === 'function') {\n                // check for member first\n                (sourceObject as any)[beforeSerializationMethodName]();\n            } else if (typeof (sourceObject.constructor as any)[beforeSerializationMethodName]\n                === 'function') {\n                // check for static\n                (sourceObject.constructor as any)[beforeSerializationMethodName]();\n            } else {\n                serializer.getErrorHandler()(new TypeError(\n                    `beforeSerialization callback '`\n                    + `${nameof(sourceTypeMetadata.classType)}.${beforeSerializationMethodName}`\n                    + `' is not a method.`,\n                ));\n            }\n        }\n\n        const sourceMeta = sourceTypeMetadata;\n        // Strong-typed serialization available.\n        // We'll serialize by members that have been marked with @jsonMember (including\n        // array/set/map members), and perform recursive conversion on each of them. The converted\n        // objects are put on the 'targetObject', which is what will be put into 'JSON.stringify'\n        // finally.\n        targetObject = {};\n\n        const classOptions = mergeOptions(serializer.options, sourceMeta.options);\n        if (sourceMeta.typeHintEmitter !== undefined) {\n            typeHintEmitter = sourceMeta.typeHintEmitter;\n        }\n\n        sourceMeta.dataMembers.forEach((objMemberMetadata) => {\n            const objMemberOptions = mergeOptions(classOptions, objMemberMetadata.options);\n            let serialized;\n            if (objMemberMetadata.serializer !== undefined) {\n                serialized = objMemberMetadata.serializer(sourceObject[objMemberMetadata.key]);\n            } else if (objMemberMetadata.type === undefined) {\n                throw new TypeError(\n                    `Could not serialize ${objMemberMetadata.name}, there is`\n                    + ` no constructor nor serialization function to use.`,\n                );\n            } else {\n                serialized = serializer.convertSingleValue(\n                    sourceObject[objMemberMetadata.key],\n                    objMemberMetadata.type,\n                    `${nameof(sourceMeta.classType)}.${objMemberMetadata.key}`,\n                    objMemberOptions,\n                );\n            }\n\n            if (isValueDefined(serialized)\n                // @todo check whether the or condition ever applies\n                // eslint-disable-next-line @typescript-eslint/tslint/config\n                || (serializer.retrievePreserveNull(objMemberOptions) && serialized === null)\n            ) {\n                targetObject[objMemberMetadata.name] = serialized;\n            }\n        });\n    }\n\n    // Add type-hint.\n    typeHintEmitter(targetObject, sourceObject, typeDescriptor.ctor, sourceTypeMetadata);\n\n    return targetObject;\n}\n\n/**\n * Performs the conversion of an array of typed objects (or primitive values) to an array of simple\n * javascript objects\n * (or primitive values) for serialization.\n */\nfunction convertAsArray(\n    sourceObject: Array<any>,\n    typeDescriptor: TypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n): Array<any> {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor)) {\n        throw new TypeError(\n            `Could not serialize ${memberName} as Array: incorrect TypeDescriptor detected, please`\n            + ' use proper annotation or function for this type',\n        );\n    }\n    if (typeDescriptor.elementType as any == null) {\n        throw new TypeError(\n            `Could not serialize ${memberName} as Array: missing element type definition.`,\n        );\n    }\n\n    // Check the type of each element, individually.\n    // If at least one array element type is incorrect, we return undefined, which results in no\n    // value emitted during serialization. This is so that invalid element types don't unexpectedly\n    // alter the ordering of other, valid elements, and that no unexpected undefined values are in\n    // the emitted array.\n    sourceObject.forEach((element, i) => {\n        if (!(serializer.retrievePreserveNull(memberOptions) && element === null)\n            && !isInstanceOf(element, typeDescriptor.elementType.ctor)\n        ) {\n            const expectedTypeName = nameof(typeDescriptor.elementType.ctor);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            const actualTypeName = element && nameof(element.constructor);\n            throw new TypeError(`Could not serialize ${memberName}[${i}]:`\n                + ` expected '${expectedTypeName}', got '${actualTypeName}'.`);\n        }\n    });\n\n    // @todo, is this necessary?\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (memberName) {\n        // Just for debugging purposes.\n        memberName += '[]';\n    }\n\n    return sourceObject.map(element => {\n        return serializer.convertSingleValue(\n            element,\n            typeDescriptor.elementType,\n            memberName,\n            memberOptions,\n        );\n    });\n}\n\n/**\n * Performs the conversion of a set of typed objects (or primitive values) into an array\n * of simple javascript objects.\n * @returns\n */\nfunction convertAsSet(\n    sourceObject: Set<any>,\n    typeDescriptor: TypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n): Array<any> {\n    if (!(typeDescriptor instanceof SetTypeDescriptor)) {\n        throw new TypeError(\n            `Could not serialize ${memberName} as Set: incorrect TypeDescriptor detected, please`\n            + ' use proper annotation or function for this type',\n        );\n    }\n    if (typeDescriptor.elementType as any == null) {\n        throw new TypeError(\n            `Could not serialize ${memberName} as Set: missing element type definition.`,\n        );\n    }\n\n    // For debugging and error tracking.\n    // @todo, is this necessary?\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (memberName) {\n        memberName += '[]';\n    }\n\n    const resultArray: Array<any> = [];\n\n    // Convert each element of the set, and put it into an output array.\n    // The output array is the one serialized, as JSON.stringify does not support Set serialization.\n    // (TODO: clarification needed)\n    sourceObject.forEach(element => {\n        const resultElement = serializer.convertSingleValue(\n            element,\n            typeDescriptor.elementType,\n            memberName,\n            memberOptions,\n        );\n\n        // Add to output if the source element was undefined, OR the converted element is defined.\n        // This will add intentionally undefined values to output, but not values that became\n        // undefined\n        // DURING serializing (usually because of a type-error).\n        if (!isValueDefined(element) || isValueDefined(resultElement)) {\n            resultArray.push(resultElement);\n        }\n    });\n\n    return resultArray;\n}\n\n/**\n * Performs the conversion of a map of typed objects (or primitive values) into an array\n * of simple javascript objects with `key` and `value` properties.\n */\nfunction convertAsMap(\n    sourceObject: Map<any, any>,\n    typeDescriptor: TypeDescriptor,\n    memberName: string,\n    serializer: Serializer,\n    memberOptions?: OptionsBase,\n): IndexedObject | Array<{key: any; value: any}> {\n    if (!(typeDescriptor instanceof MapTypeDescriptor)) {\n        throw new TypeError(\n            `Could not serialize ${memberName} as Map: incorrect TypeDescriptor detected, please`\n            + ' use proper annotation or function for this type',\n        );\n    }\n    if (typeDescriptor.valueType as any == null) { // @todo Check type\n        throw new TypeError(\n            `Could not serialize ${memberName} as Map: missing value type definition.`,\n        );\n    }\n\n    if (typeDescriptor.keyType as any == null) { // @todo Check type\n        throw new TypeError(\n            `Could not serialize ${memberName} as Map: missing key type definition.`,\n        );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (memberName) {\n        memberName += '[]';\n    }\n\n    // const resultArray: Array<{ key: any, value: any }> = [];\n    const resultShape = typeDescriptor.getCompleteOptions().shape;\n    const result = resultShape === MapShape.OBJECT ? ({} as IndexedObject) : [];\n    const preserveNull = serializer.retrievePreserveNull(memberOptions);\n\n    // Convert each *entry* in the map to a simple javascript object with key and value properties.\n    sourceObject.forEach((value, key) => {\n        const resultKeyValuePairObj = {\n            key: serializer.convertSingleValue(\n                key,\n                typeDescriptor.keyType,\n                memberName,\n                memberOptions,\n            ),\n            value: serializer.convertSingleValue(\n                value,\n                typeDescriptor.valueType,\n                memberName,\n                memberOptions,\n            ),\n        };\n\n        // We are not going to emit entries with undefined keys OR undefined values.\n        const keyDefined = isValueDefined(resultKeyValuePairObj.key);\n        const valueDefined = isValueDefined(resultKeyValuePairObj.value)\n            // @todo check\n            // eslint-disable-next-line @typescript-eslint/tslint/config\n            || (resultKeyValuePairObj.value === null && preserveNull);\n        if (keyDefined && valueDefined) {\n            if (resultShape === MapShape.OBJECT) {\n                result[resultKeyValuePairObj.key] = resultKeyValuePairObj.value;\n            } else {\n                result.push(resultKeyValuePairObj);\n            }\n        }\n    });\n\n    return result;\n}\n\n/**\n * Performs the conversion of a typed javascript array to a simple untyped javascript array.\n * This is needed because typed arrays are otherwise serialized as objects, so we'll end up\n * with something like \"{ 0: 0, 1: 1, ... }\".\n */\nfunction convertAsTypedArray(sourceObject: ArrayBufferView) {\n    return Array.from(sourceObject as any);\n}\n\n/**\n * Performs the conversion of a raw ArrayBuffer to a string.\n */\nfunction convertAsArrayBuffer(buffer: ArrayBuffer) {\n    // ArrayBuffer -> 16-bit character codes -> character array -> joined string.\n    return Array.from(new Uint16Array(buffer))\n        .map(charCode => String.fromCharCode(charCode)).join('');\n}\n\n/**\n * Performs the conversion of DataView, converting its internal ArrayBuffer to a string and\n * returning that string.\n */\nfunction convertAsDataView(dataView: DataView) {\n    return convertAsArrayBuffer(dataView.buffer);\n}\n","import {defaultTypeResolver, Deserializer} from './typedjson/deserializer';\nimport {logError, logWarning, nameof, parseToJSObject} from './typedjson/helpers';\nimport {createArrayType} from './typedjson/json-array-member';\nimport {JsonObjectMetadata, TypeHintEmitter, TypeResolver} from './typedjson/metadata';\nimport {extractOptionBase, OptionsBase} from './typedjson/options-base';\nimport {defaultTypeEmitter, Serializer} from './typedjson/serializer';\nimport {ensureTypeDescriptor, MapT, SetT} from './typedjson/type-descriptor';\nimport {Constructor, IndexedObject, Serializable} from './typedjson/types';\n\nexport type JsonTypes = Object | boolean | string | number | null | undefined;\nexport {defaultTypeResolver, defaultTypeEmitter};\n\nexport interface ITypedJSONSettings extends OptionsBase {\n    /**\n     * Sets the handler callback to invoke on errors during serializing and deserializing.\n     * Re-throwing errors in this function will halt serialization/deserialization.\n     * The default behavior is to log errors to the console.\n     */\n    errorHandler?: (e: Error) => void;\n\n    /**\n     * Sets a callback that determines the constructor of the correct sub-type of polymorphic\n     * objects while deserializing.\n     * The default behavior is to read the type-name from the '__type' property of 'sourceObject',\n     * and look it up in 'knownTypes'.\n     * The constructor of the sub-type should be returned.\n     */\n    typeResolver?: TypeResolver;\n\n    nameResolver?: (ctor: Function) => string;\n\n    /**\n     * Sets a callback that writes type-hints to serialized objects.\n     * The default behavior is to write the type-name to the '__type' property, if a derived type\n     * is present in place of a base type.\n     */\n    typeHintEmitter?: TypeHintEmitter;\n\n    /**\n     * Sets the amount of indentation to use in produced JSON strings.\n     * Default value is 0, or no indentation.\n     */\n    indent?: number;\n\n    replacer?: (key: string, value: any) => any;\n\n    knownTypes?: Array<Constructor<any>>;\n}\n\nexport class TypedJSON<T> {\n\n    private static _globalConfig: ITypedJSONSettings | undefined;\n\n    private serializer: Serializer = new Serializer();\n    private deserializer: Deserializer<T> = new Deserializer<T>();\n    private globalKnownTypes: Array<Constructor<any>> = [];\n    private indent: number = 0;\n    private rootConstructor: Serializable<T>;\n    private errorHandler: (e: Error) => void;\n    private nameResolver: (ctor: Function) => string;\n    private replacer?: (key: string, value: any) => any;\n\n    /**\n     * Creates a new TypedJSON instance to serialize (stringify) and deserialize (parse) object\n     *     instances of the specified root class type.\n     * @param rootConstructor The constructor of the root class type.\n     * @param settings Additional configuration settings.\n     */\n    constructor(rootConstructor: Serializable<T>, settings?: ITypedJSONSettings) {\n        const rootMetadata = JsonObjectMetadata.getFromConstructor(rootConstructor);\n\n        if (rootMetadata === undefined\n            || (!rootMetadata.isExplicitlyMarked && !rootMetadata.isHandledWithoutAnnotation)) {\n            throw new TypeError(\n                'The TypedJSON root data type must have the @jsonObject decorator used.',\n            );\n        }\n\n        this.nameResolver = (ctor) => nameof(ctor);\n        this.rootConstructor = rootConstructor;\n        this.errorHandler = (error) => logError(error);\n\n        if (settings !== undefined) {\n            this.config(settings);\n        } else if (TypedJSON._globalConfig !== undefined) {\n            this.config({});\n        }\n    }\n\n    static parse<T>(\n        object: any,\n        rootType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): T | undefined {\n        return new TypedJSON(rootType, settings).parse(object);\n    }\n\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: 1,\n    ): Array<T>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 2,\n    ): Array<Array<T>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 3,\n    ): Array<Array<Array<T>>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 4,\n    ): Array<Array<Array<Array<T>>>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings: ITypedJSONSettings | undefined,\n        dimensions: 5,\n    ): Array<Array<Array<Array<Array<T>>>>>;\n    static parseAsArray<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: number,\n    ): Array<any> {\n        return new TypedJSON(elementType, settings).parseAsArray(object, dimensions as any);\n    }\n\n    static parseAsSet<T>(\n        object: any,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): Set<T> {\n        return new TypedJSON(elementType, settings).parseAsSet(object);\n    }\n\n    static parseAsMap<K, V>(\n        object: any,\n        keyType: Serializable<K>,\n        valueType: Serializable<V>,\n        settings?: ITypedJSONSettings,\n    ): Map<K, V> {\n        return new TypedJSON(valueType, settings).parseAsMap(object, keyType);\n    }\n\n    static toPlainJson<T>(\n        object: T,\n        rootType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): JsonTypes {\n        return new TypedJSON(rootType, settings).toPlainJson(object);\n    }\n\n    static toPlainArray<T>(\n        object: Array<T>,\n        elementType: Serializable<T>,\n        dimensions?: 1,\n        settings?: ITypedJSONSettings,\n    ): Array<Object>;\n    static toPlainArray<T>(\n        object: Array<Array<T>>,\n        elementType: Serializable<T>,\n        dimensions: 2,\n        settings?: ITypedJSONSettings,\n    ): Array<Array<Object>>;\n    static toPlainArray<T>(\n        object: Array<Array<Array<T>>>,\n        elementType: Serializable<T>,\n        dimensions: 3,\n        settings?: ITypedJSONSettings,\n    ): Array<Array<Array<Object>>>;\n    static toPlainArray<T>(\n        object: Array<Array<Array<Array<T>>>>,\n        elementType: Serializable<T>,\n        dimensions: 4, settings?: ITypedJSONSettings,\n    ): Array<Array<Array<Array<Object>>>>;\n    static toPlainArray<T>(\n        object: Array<Array<Array<Array<Array<T>>>>>,\n        elementType: Serializable<T>,\n        dimensions: 5,\n        settings?: ITypedJSONSettings,\n    ): Array<Array<Array<Array<Array<Object>>>>>;\n    static toPlainArray<T>(\n        object: Array<any>,\n        elementType: Serializable<T>,\n        dimensions: number,\n        settings?: ITypedJSONSettings,\n    ): Array<any>;\n    static toPlainArray<T>(\n        object: Array<any>,\n        elementType: Serializable<T>,\n        dimensions?: any,\n        settings?: ITypedJSONSettings,\n    ): Array<any> {\n        return new TypedJSON(elementType, settings).toPlainArray(object, dimensions);\n    }\n\n    static toPlainSet<T>(\n        object: Set<T>,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): Array<Object> | undefined {\n        return new TypedJSON(elementType, settings).toPlainSet(object);\n    }\n\n    static toPlainMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Serializable<K>,\n        valueCtor: Serializable<V>,\n        settings?: ITypedJSONSettings,\n    ): IndexedObject | Array<{key: any; value: any}> | undefined {\n        return new TypedJSON(valueCtor, settings).toPlainMap(object, keyCtor);\n    }\n\n    static stringify<T>(\n        object: T,\n        rootType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(rootType, settings).stringify(object);\n    }\n\n    static stringifyAsArray<T>(\n        object: Array<T>,\n        elementType: Serializable<T>,\n        dimensions?: 1,\n        settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<T>>,\n        elementType: Serializable<T>,\n        dimensions: 2,\n        settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<Array<T>>>,\n        elementType: Serializable<T>,\n        dimensions: 3,\n        settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<Array<Array<T>>>>,\n        elementType: Serializable<T>,\n        dimensions: 4,\n        settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<Array<Array<Array<Array<T>>>>>,\n        elementType: Serializable<T>,\n        dimensions: 5,\n        settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<any>,\n        elementType: Serializable<T>,\n        dimensions: number, settings?: ITypedJSONSettings,\n    ): string;\n    static stringifyAsArray<T>(\n        object: Array<any>,\n        elementType: Serializable<T>,\n        dimensions?: any,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(elementType, settings).stringifyAsArray(object, dimensions);\n    }\n\n    static stringifyAsSet<T>(\n        object: Set<T>,\n        elementType: Serializable<T>,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(elementType, settings).stringifyAsSet(object);\n    }\n\n    static stringifyAsMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Serializable<K>,\n        valueCtor: Serializable<V>,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(valueCtor, settings).stringifyAsMap(object, keyCtor);\n    }\n\n    static setGlobalConfig(config: ITypedJSONSettings) {\n        if (this._globalConfig === undefined) {\n            this._globalConfig = config;\n        } else {\n            Object.assign(this._globalConfig, config);\n        }\n    }\n\n    /**\n     * Configures TypedJSON through a settings object.\n     * @param settings The configuration settings object.\n     */\n    config(settings: ITypedJSONSettings) {\n        if (TypedJSON._globalConfig !== undefined) {\n            settings = {\n                ...TypedJSON._globalConfig,\n                ...settings,\n            };\n\n            if (settings.knownTypes !== undefined\n                && TypedJSON._globalConfig.knownTypes !== undefined) {\n                // Merge known-types (also de-duplicate them, so Array -> Set -> Array).\n                settings.knownTypes = Array.from(new Set(\n                    settings.knownTypes.concat(TypedJSON._globalConfig.knownTypes),\n                ));\n            }\n        }\n\n        const options = extractOptionBase(settings);\n        this.serializer.options = options;\n        this.deserializer.options = options;\n\n        if (settings.errorHandler !== undefined) {\n            this.errorHandler = settings.errorHandler;\n            this.deserializer.setErrorHandler(settings.errorHandler);\n            this.serializer.setErrorHandler(settings.errorHandler);\n        }\n\n        if (settings.replacer !== undefined) {\n            this.replacer = settings.replacer;\n        }\n        if (settings.typeResolver !== undefined) {\n            this.deserializer.setTypeResolver(settings.typeResolver);\n        }\n        if (settings.typeHintEmitter !== undefined) {\n            this.serializer.setTypeHintEmitter(settings.typeHintEmitter);\n        }\n        if (settings.indent !== undefined) {\n            this.indent = settings.indent;\n        }\n\n        if (settings.nameResolver !== undefined) {\n            this.nameResolver = settings.nameResolver;\n            this.deserializer.setNameResolver(settings.nameResolver);\n            // this.serializer.set\n        }\n\n        if (settings.knownTypes !== undefined) {\n            // Type-check knownTypes elements to recognize errors in advance.\n            settings.knownTypes.forEach((knownType: any, i) => {\n                // tslint:disable-next-line:no-null-keyword\n                if (typeof knownType === 'undefined' || knownType === null) {\n                    logWarning(\n                        `TypedJSON.config: 'knownTypes' contains an undefined/null value`\n                        + ` (element ${i}).`,\n                    );\n                }\n            });\n\n            this.globalKnownTypes = settings.knownTypes;\n        }\n    }\n\n    /**\n     * Converts a JSON string to the root class type.\n     * @param object The JSON to parse and convert.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns Deserialized T or undefined if there were errors.\n     */\n    parse(object: any): T | undefined {\n        const json = parseToJSObject(object, this.rootConstructor);\n\n        const rootMetadata = JsonObjectMetadata.getFromConstructor(this.rootConstructor);\n        let result: T | undefined;\n        const knownTypes = new Map<string, Function>();\n\n        this.globalKnownTypes.filter(ktc => ktc).forEach(knownTypeCtor => {\n            knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n        });\n\n        if (rootMetadata !== undefined) {\n            rootMetadata.knownTypes.forEach(knownTypeCtor => {\n                knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n            });\n        }\n\n        try {\n            result = this.deserializer.convertSingleValue(\n                json,\n                ensureTypeDescriptor(this.rootConstructor),\n                knownTypes,\n            ) as T;\n        } catch (e) {\n            this.errorHandler(e);\n        }\n\n        return result;\n    }\n\n    parseAsArray(object: any, dimensions?: 1): Array<T>;\n    parseAsArray(object: any, dimensions: 2): Array<Array<T>>;\n    parseAsArray(object: any, dimensions: 3): Array<Array<Array<T>>>;\n    parseAsArray(object: any, dimensions: 4): Array<Array<Array<Array<T>>>>;\n    parseAsArray(object: any, dimensions: 5): Array<Array<Array<Array<Array<T>>>>>;\n    parseAsArray(object: any, dimensions: number): Array<any>;\n    parseAsArray(object: any, dimensions: number = 1): Array<any> {\n        const json = parseToJSObject(object, Array);\n        return this.deserializer.convertSingleValue(\n            json,\n            createArrayType(ensureTypeDescriptor(this.rootConstructor), dimensions),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    parseAsSet(object: any): Set<T> {\n        const json = parseToJSObject(object, Set);\n        return this.deserializer.convertSingleValue(\n            json,\n            SetT(this.rootConstructor),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    parseAsMap<K>(object: any, keyConstructor: Serializable<K>): Map<K, T> {\n        const json = parseToJSObject(object, Map);\n        return this.deserializer.convertSingleValue(\n            json,\n            MapT(keyConstructor, this.rootConstructor),\n            this._mapKnownTypes(this.globalKnownTypes),\n        );\n    }\n\n    /**\n     * Converts an instance of the specified class type to a plain JSON object.\n     * @param object The instance to convert to a JSON string.\n     * @returns Serialized object or undefined if an error has occured.\n     */\n    toPlainJson(object: T): JsonTypes {\n        try {\n            return this.serializer.convertSingleValue(\n                object,\n                ensureTypeDescriptor(this.rootConstructor),\n            );\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    toPlainArray(object: Array<T>, dimensions?: 1): Array<Object>;\n    toPlainArray(object: Array<Array<T>>, dimensions: 2): Array<Array<Object>>;\n    toPlainArray(object: Array<Array<Array<T>>>, dimensions: 3): Array<Array<Array<Object>>>;\n    toPlainArray(\n        object: Array<Array<Array<Array<T>>>>,\n        dimensions: 4,\n    ): Array<Array<Array<Array<Object>>>>;\n    toPlainArray(\n        object: Array<Array<Array<Array<Array<T>>>>>,\n        dimensions: 5,\n    ): Array<Array<Array<Array<Array<Object>>>>>;\n    toPlainArray(object: Array<any>, dimensions: 1 | 2 | 3 | 4 | 5 = 1): Array<Object> | undefined {\n        try {\n            return this.serializer.convertSingleValue(\n                object,\n                createArrayType(ensureTypeDescriptor(this.rootConstructor), dimensions),\n            );\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    toPlainSet(object: Set<T>): Array<Object> | undefined {\n        try {\n            return this.serializer.convertSingleValue(object, SetT(this.rootConstructor));\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    toPlainMap<K>(\n        object: Map<K, T>,\n        keyConstructor: Serializable<K>,\n    ): IndexedObject | Array<{key: any; value: any}> | undefined {\n        try {\n            return this.serializer.convertSingleValue(\n                object,\n                MapT(keyConstructor, this.rootConstructor),\n            );\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Converts an instance of the specified class type to a JSON string.\n     * @param object The instance to convert to a JSON string.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns String with the serialized object or an empty string if an error has occured, but\n     *     the errorHandler did not throw.\n     */\n    stringify(object: T): string {\n        const result = this.toPlainJson(object);\n        if (result === undefined) {\n            return '';\n        }\n        return JSON.stringify(result, this.replacer, this.indent);\n    }\n\n    stringifyAsArray(object: Array<T>, dimensions?: 1): string;\n    stringifyAsArray(object: Array<Array<T>>, dimensions: 2): string;\n    stringifyAsArray(object: Array<Array<Array<T>>>, dimensions: 3): string;\n    stringifyAsArray(object: Array<Array<Array<Array<T>>>>, dimensions: 4): string;\n    stringifyAsArray(object: Array<Array<Array<Array<Array<T>>>>>, dimensions: 5): string;\n    stringifyAsArray(object: Array<any>, dimensions: any): string {\n        return JSON.stringify(this.toPlainArray(object, dimensions), this.replacer, this.indent);\n    }\n\n    stringifyAsSet(object: Set<T>): string {\n        return JSON.stringify(this.toPlainSet(object), this.replacer, this.indent);\n    }\n\n    stringifyAsMap<K>(object: Map<K, T>, keyConstructor: Serializable<K>): string {\n        return JSON.stringify(this.toPlainMap(object, keyConstructor), this.replacer, this.indent);\n    }\n\n    private _mapKnownTypes(constructors: Array<Constructor<any>>) {\n        const map = new Map<string, Constructor<any>>();\n\n        constructors.filter(ctor => ctor).forEach(ctor => map.set(this.nameResolver(ctor), ctor));\n\n        return map;\n    }\n}\n","import {JsonObjectMetadata, TypeHintEmitter, TypeResolver} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {Serializable} from './types';\n\nexport type InitializerCallback<T> = (sourceObject: T, rawSourceObject: T) => T;\n\nexport interface IJsonObjectOptionsBase extends OptionsBase {\n    /**\n     * An array of known types to recognize when encountering type-hints.\n     */\n    knownTypes?: Array<Function>;\n\n    /**\n     * A function that will emit a type hint on the resulting JSON. It will override the global\n     * typeEmitter.\n     */\n    typeHintEmitter?: TypeHintEmitter;\n\n    /**\n     * A function that given a source object will resolve the type that should be instantiated.\n     * It will override the global type resolver.\n     */\n    typeResolver?: TypeResolver;\n\n    /**\n     * The name of a static or instance method to call when deserialization\n     * of the object is completed.\n     */\n    onDeserialized?: string;\n\n    /**\n     * The name of a static or instance method to call before the serialization\n     * of the typed object is started.\n     */\n    beforeSerialization?: string;\n\n    /**\n     * The name used to differentiate between different polymorphic types.\n     */\n    name?: string;\n}\n\nexport interface IJsonObjectOptionsWithInitializer<T> extends IJsonObjectOptionsBase {\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer: InitializerCallback<T>;\n}\n\nexport interface IJsonObjectOptions<T> extends IJsonObjectOptionsBase {\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer?: InitializerCallback<T>;\n}\n\n/**\n * Marks that a class with a parameterized constructor is serializable using TypedJSON, with\n * additional settings. The 'initializer' setting must be specified.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(\n    options?: IJsonObjectOptionsWithInitializer<T>,\n): (target: Serializable<T>) => void;\n\n/**\n * Marks that a class is serializable using TypedJSON, with additional settings.\n * @param options Configuration settings.\n */\n// eslint-disable-next-line @typescript-eslint/unified-signatures\nexport function jsonObject<T>(options?: IJsonObjectOptions<T>): (target: Serializable<T>) => void;\n\n/**\n * Marks that a class with a parameterless constructor is serializable using TypedJSON.\n */\nexport function jsonObject<T>(target: Serializable<T>): void;\n\nexport function jsonObject<T extends Object>(\n    optionsOrTarget?: IJsonObjectOptions<T> | Serializable<T>,\n): ((target: Serializable<T>) => void) | void {\n    let options: IJsonObjectOptions<T>;\n\n    if (typeof optionsOrTarget === 'function') {\n        // jsonObject is being used as a decorator, directly.\n        options = {};\n    } else {\n        // jsonObject is being used as a decorator factory.\n        options = optionsOrTarget ?? {};\n    }\n\n    function decorator(\n        target: Serializable<T>,\n    ): void {\n        // Create or obtain JsonObjectMetadata object.\n        const objectMetadata = JsonObjectMetadata.ensurePresentInPrototype(target.prototype);\n\n        // Fill JsonObjectMetadata.\n        objectMetadata.isExplicitlyMarked = true;\n        objectMetadata.onDeserializedMethodName = options.onDeserialized;\n        objectMetadata.beforeSerializationMethodName = options.beforeSerialization;\n\n        if (options.typeResolver !== undefined) {\n            objectMetadata.typeResolver = options.typeResolver;\n        }\n        if (options.typeHintEmitter !== undefined) {\n            objectMetadata.typeHintEmitter = options.typeHintEmitter;\n        }\n\n        // T extend Object so it is fine\n        objectMetadata.initializerCallback = options.initializer as any;\n        if (options.name !== undefined) {\n            objectMetadata.name = options.name;\n        }\n        const optionsBase = extractOptionBase(options);\n        if (optionsBase !== undefined) {\n            objectMetadata.options = optionsBase;\n        }\n\n        if (options.knownTypes !== undefined) {\n            options.knownTypes\n                .filter(knownType => Boolean(knownType))\n                .forEach(knownType => objectMetadata.knownTypes.add(knownType));\n        }\n    }\n\n    if (typeof optionsOrTarget === 'function') {\n        // jsonObject is being used as a decorator, directly.\n        decorator(optionsOrTarget);\n    } else {\n        // jsonObject is being used as a decorator factory.\n        return decorator;\n    }\n}\n\nfunction isSubClass<T>(target: Serializable<T>) {\n    return;\n}\n","import {\n    isReflectMetadataSupported,\n    isSubtypeOf,\n    isValueDefined,\n    logError,\n    logWarning,\n    MISSING_REFLECT_CONF_MSG,\n    nameof,\n} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {\n    ArrayTypeDescriptor,\n    ensureTypeDescriptor,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from './type-descriptor';\nimport {IndexedObject} from './types';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMemberOptions extends OptionsBase {\n    /**\n     * Sets the constructor of the property.\n     * Optional with ReflectDecorators.\n     */\n    constructor?: Function | TypeDescriptor;\n\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted if the property is uninitialized/undefined. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name. */\n    name?: string;\n\n    /**\n     * When set, this deserializer will be used to deserialize the member. The callee must assure\n     * the correct type.\n     */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property is part of the object when serializing, with additional options.\n * Omitting the 'constructor' option requires ReflectDecorators and that the property type is always\n * explicitly declared.\n * @param options Additional options.\n */\nexport function jsonMember(options: IJsonMemberOptions): PropertyDecorator;\n\n/**\n * Specifies that a property is part of the object when serializing.\n * This call signature requires ReflectDecorators and that the property type is always explicitly\n * declared.\n */\nexport function jsonMember<T extends Function>(\n    prototype: IndexedObject,\n    propertyKey: string | symbol,\n): void;\n\nexport function jsonMember<T extends Function>(\n    optionsOrPrototype?: IJsonMemberOptions | IndexedObject,\n    propKey?: string | symbol,\n): PropertyDecorator | void {\n    // @todo, why do we check if propkey is string or symbol? the type only allows symbol/string\n    //    The check is not required.\n    if (propKey !== undefined\n        && (typeof propKey === 'string' || typeof propKey as any === 'symbol')) {\n        const prototype = optionsOrPrototype as IndexedObject;\n        // For error messages.\n        const decoratorName = `@jsonMember on ${nameof(prototype.constructor)}.${String(propKey)}`;\n\n        // jsonMember used directly, no additional information directly available besides target and\n        // propKey.\n        // Obtain property constructor through ReflectDecorators.\n        if (!isReflectMetadataSupported) {\n            logError(\n                `${decoratorName}: ReflectDecorators is required if no 'constructor' option is`\n                + ` specified.`,\n            );\n            return;\n        }\n\n        const reflectPropCtor: Function | null | undefined =\n            Reflect.getMetadata('design:type', prototype, propKey);\n\n        if (reflectPropCtor == null) {\n            logError(\n                `${decoratorName}: could not resolve detected property constructor at runtime.${\n                    MISSING_REFLECT_CONF_MSG}`,\n            );\n            return;\n        }\n\n        const typeDescriptor = ensureTypeDescriptor(reflectPropCtor);\n        if (isSpecialPropertyType(decoratorName, typeDescriptor)) {\n            return;\n        }\n\n        injectMetadataInformation(prototype, propKey, {\n            type: typeDescriptor,\n            key: propKey.toString(),\n            name: propKey.toString(),\n        });\n    } else {\n        // jsonMember used as a decorator factory.\n        return (target: Object, _propKey: string | symbol) => {\n            const options: IJsonMemberOptions = optionsOrPrototype as IJsonMemberOptions ?? {};\n            let typeDescriptor: TypeDescriptor | undefined;\n            const decoratorName =\n                `@jsonMember on ${nameof(target.constructor)}.${String(_propKey)}`;\n\n            if (options.hasOwnProperty('constructor')) {\n                if (!isValueDefined(options.constructor)) {\n                    logError(\n                        `${decoratorName}: cannot resolve specified property constructor at`\n                        + ' runtime.',\n                    );\n                    return;\n                }\n\n                // Property constructor has been specified. Use ReflectDecorators (if available) to\n                // check whether that constructor is correct. Warn if not.\n                typeDescriptor = ensureTypeDescriptor(options.constructor);\n                if (isReflectMetadataSupported && !isSubtypeOf(\n                    typeDescriptor.ctor,\n                    Reflect.getMetadata('design:type', target, _propKey),\n                )) {\n                    logWarning(\n                        `${decoratorName}: detected property type does not match`\n                        + ` 'constructor' option.`,\n                    );\n                }\n            } else {\n                // Use ReflectDecorators to obtain property constructor.\n                if (isReflectMetadataSupported) {\n                    const reflectCtor = Reflect.getMetadata(\n                        'design:type',\n                        target,\n                        _propKey,\n                    ) as Function | null | undefined;\n\n                    if (reflectCtor == null) {\n                        logError(\n                            `${decoratorName}: cannot resolve detected property constructor at`\n                            + ` runtime.`,\n                        );\n                        return;\n                    }\n                    typeDescriptor = ensureTypeDescriptor(reflectCtor);\n                } else if (options.deserializer === undefined) {\n                    logError(\n                        `${decoratorName}: ReflectDecorators is required if no 'constructor' option`\n                        + ` is specified.`,\n                    );\n                    return;\n                }\n            }\n\n            if (typeDescriptor !== undefined\n                && isSpecialPropertyType(decoratorName, typeDescriptor)) {\n                return;\n            }\n            injectMetadataInformation(target, _propKey, {\n                type: typeDescriptor,\n                emitDefaultValue: options.emitDefaultValue,\n                isRequired: options.isRequired,\n                options: extractOptionBase(options),\n                key: _propKey.toString(),\n                name: options.name ?? _propKey.toString(),\n                deserializer: options.deserializer,\n                serializer: options.serializer,\n            });\n        };\n    }\n}\n\nfunction isSpecialPropertyType(decoratorName: string, typeDescriptor: TypeDescriptor) {\n    if (!(typeDescriptor instanceof ArrayTypeDescriptor) && typeDescriptor.ctor === Array) {\n        logError(`${decoratorName}: property is an Array. Use the jsonArrayMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (!(typeDescriptor instanceof SetTypeDescriptor) && typeDescriptor.ctor === Set) {\n        logError(`${decoratorName}: property is a Set. Use the jsonSetMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (!(typeDescriptor instanceof MapTypeDescriptor) && typeDescriptor.ctor === Map) {\n        logError(`${decoratorName}: property is a Map. Use the jsonMapMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    return false;\n}\n","import {isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {isTypelike, SetT} from './type-descriptor';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonSetMemberOptions extends OptionsBase {\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /**\n     * When set, this deserializer will be used to deserialize the member. The callee must assure\n     * the correct type.\n     */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Set<T>.\n * @param elementConstructor Constructor of set elements (e.g. 'Number' for Set<number> or 'Date'\n * for Set<Date>).\n * @param options Additional options.\n */\nexport function jsonSetMember(elementConstructor: Function, options: IJsonSetMemberOptions = {}) {\n    return (target: Object, propKey: string | symbol) => {\n        // For error messages\n        const decoratorName = `@jsonSetMember on ${nameof(target.constructor)}.${String(propKey)}`;\n\n        if (!isTypelike(elementConstructor)) {\n            logError(`${decoratorName}: could not resolve constructor of set elements at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonSetMember' has been used\n        // on a set. Warn if not.\n        if (isReflectMetadataSupported\n            && Reflect.getMetadata('design:type', target, propKey) !== Set) {\n            logError(`${decoratorName}: property is not a Set. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: SetT(elementConstructor),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name ?? propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import {isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof} from './helpers';\nimport {injectMetadataInformation} from './metadata';\nimport {extractOptionBase, OptionsBase} from './options-base';\nimport {isTypelike, MapOptions, MapT, TypeDescriptor} from './type-descriptor';\n\ndeclare abstract class Reflect {\n    static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMapMemberOptions extends OptionsBase, Partial<MapOptions> {\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /**\n     * When set, this deserializer will be used to deserialize the member. The callee must assure\n     * the correct type.\n     */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Map<K, V>.\n * @param keyConstructor Constructor of map keys (e.g. 'Number' for 'Map<number, Date>').\n * @param valueConstructor Constructor of map values (e.g. 'Date' for 'Map<number, Date>').\n * @param options Additional options.\n */\nexport function jsonMapMember(\n    keyConstructor: Function | TypeDescriptor,\n    valueConstructor: Function | TypeDescriptor,\n    options: IJsonMapMemberOptions = {},\n) {\n    return (target: Object, propKey: string | symbol) => {\n        // For error messages\n        const decoratorName = `@jsonMapMember on ${nameof(target.constructor)}.${String(propKey)}`;\n\n        if (!isTypelike(keyConstructor)) {\n            logError(`${decoratorName}: could not resolve constructor of map keys at runtime.`);\n            return;\n        }\n\n        if (!isTypelike(valueConstructor)) {\n            logError(`${decoratorName}: could not resolve constructor of map values at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonMapMember' has been used\n        // on a map. Warn if not.\n        if (isReflectMetadataSupported\n            && Reflect.getMetadata('design:type', target, propKey) !== Map) {\n            logError(`${decoratorName}: property is not a Map. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: MapT(keyConstructor, valueConstructor, {shape: options.shape}),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name ?? propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import {TypedJSON} from '../parser';\n\n/**\n * Options for the @toJson decorator.\n */\nexport interface IToJsonOptions {\n    /**\n     * When set to true it will overwrite any toJSON already existing on the prototype.\n     */\n    overwrite?: boolean;\n}\n\n/**\n * Decorator that will generate toJSON function on the class prototype that allows\n * JSON.stringify to be used instead of TypedJSON.stringify. Under the hood it will\n * simply delegate to TypedJSON.\n * By default it will throw if the prototype already has a toJSON function defined.\n * @param target the class which prototype should be modified.\n */\nexport function toJson<T extends Object>(target: Function): void;\n/**\n * Decorator factory that accepts the options interface.\n * @param options for configuring the toJSON creation.\n */\nexport function toJson<T extends Object>(options: IToJsonOptions): ((target: Function) => void);\nexport function toJson<T extends Object>(\n    optionsOrTarget: IToJsonOptions | Function,\n): ((target: Function) => void) | void {\n    if (typeof optionsOrTarget === 'function') {\n        // used directly\n        toJsonDecorator(optionsOrTarget, {});\n        return;\n    }\n    // used as a factory\n    return (target: Function) => {\n        toJsonDecorator(target, optionsOrTarget);\n    };\n}\n\nfunction toJsonDecorator<T extends Object>(target: Function, options: IToJsonOptions): void {\n    if (options.overwrite !== true && target.prototype.toJSON !== undefined) {\n        throw new Error(`${target.name} already has toJSON defined!`);\n    }\n    target.prototype.toJSON = function () {\n        return TypedJSON.toPlainJson(this, Object.getPrototypeOf(this).constructor);\n    };\n}\n","export {\n    TypedJSON,\n    ITypedJSONSettings,\n    JsonTypes,\n    defaultTypeResolver,\n    defaultTypeEmitter,\n} from './parser';\nexport {TypeResolver, TypeHintEmitter, JsonObjectMetadata} from './typedjson/metadata';\nexport {jsonObject} from './typedjson/json-object';\nexport {jsonMember} from './typedjson/json-member';\nexport {jsonArrayMember} from './typedjson/json-array-member';\nexport {jsonSetMember} from './typedjson/json-set-member';\nexport {jsonMapMember} from './typedjson/json-map-member';\nexport {toJson} from './typedjson/to-json';\nexport {ArrayT, SetT, MapT} from './typedjson/type-descriptor';\n"],"sourceRoot":""}